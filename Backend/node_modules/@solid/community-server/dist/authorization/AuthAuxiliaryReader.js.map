{"version":3,"file":"AuthAuxiliaryReader.js","sourceRoot":"","sources":["../../src/authorization/AuthAuxiliaryReader.ts"],"names":[],"mappings":";;;AAEA,gDAAkD;AAClD,6DAAkE;AAElE,iDAA6C;AAE7C,yDAAsD;AACtD,qEAAyD;AAIzD;;;;;;;GAOG;AACH,MAAa,mBAAoB,SAAQ,mCAAgB;IACpC,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE9B,MAAM,CAAmB;IACzB,YAAY,CAAoB;IAEjD,YAAmB,MAAwB,EAAE,YAA+B;QAC1E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,cAAc,EAAE,WAAW,EAAyB;QACxE,gCAAgC;QAChC,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC;QAEvD,yEAAyE;QACzE,MAAM,UAAU,GAAG,IAAA,gBAAM,EACvB,IAAI,qCAAqB,CAAC,cAAc,CAAC,EACzC,EAAE,GAAG,EAAE,OAAO,CAAC,MAAM,EAAE,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,EAAE,EAAE,CAClD,CAAC;QACF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,cAAc,EAAE,UAAU,EAAE,WAAW,EAAE,CAAC,CAAC;QAEzF,oEAAoE;QACpE,KAAK,MAAM,CAAE,UAAU,EAAE,CAAE,OAAO,CAAE,CAAC,IAAI,OAAO,EAAE,CAAC;YACjD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,OAAO,CAAC,IAAI,8CAA8C,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YAC1G,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACjF,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,CAAE,QAAQ,CAAC,SAAoB;QACpC,KAAK,MAAM,CAAE,UAAU,CAAE,IAAI,SAAS,EAAE,CAAC;YACvC,IAAI,IAAI,CAAC,YAAY,CAAC,qBAAqB,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxD,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;gBACnE,0EAA0E;gBAC1E,MAAM,CAAE,UAAU,EAAE,CAAE,OAAO,EAAE,IAAI,GAAG,CAAC,CAAE,0BAAO,CAAC,OAAO,CAA6B,CAAC,CAAE,CAAC,CAAC;YAC5F,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;OAGG;IACO,gBAAgB,CAAC,UAA8B,EAAE,gBAAkC,EAAE;QAC7F,MAAM,EAAE,OAAO,EAAE,GAAG,aAAa,CAAC;QAClC,OAAO;YACL,IAAI,EAAE,OAAO;YACb,MAAM,EAAE,OAAO;YACf,KAAK,EAAE,OAAO;YACd,OAAO;SACY,CAAC;IACxB,CAAC;CACF;AAzDD,kDAyDC","sourcesContent":["import type { AuxiliaryStrategy } from '../http/auxiliary/AuxiliaryStrategy';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { IdentifierSetMultiMap } from '../util/map/IdentifierMap';\nimport type { MapEntry } from '../util/map/MapUtil';\nimport { modify } from '../util/map/MapUtil';\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport { AclMode } from './permissions/AclPermissionSet';\nimport type { AclPermissionSet } from './permissions/AclPermissionSet';\nimport type { AccessMap, AccessMode, PermissionMap, PermissionSet } from './permissions/Permissions';\n\n/**\n * Determines the permission for authorization resources (such as ACL or ACR).\n * In contrast to the regular resource mechanism, read/write access to authorization resources\n * is obtained by setting Control permissions on the corresponding subject resource\n * rather than directly setting permissions for the authorization resource itself.\n * Hence, this class transforms Control permissions on the subject resource\n * to Read/Write permissions on the authorization resource.\n */\nexport class AuthAuxiliaryReader extends PermissionReader {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly reader: PermissionReader;\n  private readonly authStrategy: AuxiliaryStrategy;\n\n  public constructor(reader: PermissionReader, authStrategy: AuxiliaryStrategy) {\n    super();\n    this.reader = reader;\n    this.authStrategy = authStrategy;\n  }\n\n  public async handle({ requestedModes, credentials }: PermissionReaderInput): Promise<PermissionMap> {\n    // Finds all the ACL identifiers\n    const authMap = new Map(this.findAuth(requestedModes));\n\n    // Replaces the ACL identifies with the corresponding subject identifiers\n    const updatedMap = modify(\n      new IdentifierSetMultiMap(requestedModes),\n      { add: authMap.values(), remove: authMap.keys() },\n    );\n    const result = await this.reader.handleSafe({ requestedModes: updatedMap, credentials });\n\n    // Extracts the permissions based on the subject control permissions\n    for (const [ identifier, [ subject ]] of authMap) {\n      this.logger.debug(`Mapping ${subject.path} control permission to all permissions for ${identifier.path}`);\n      result.set(identifier, this.interpretControl(identifier, result.get(subject)));\n    }\n    return result;\n  }\n\n  /**\n   * Finds all authorization resource identifiers and maps them to their subject identifier and the requested modes.\n   */\n  private* findAuth(accessMap: AccessMap): Iterable<[ResourceIdentifier, MapEntry<AccessMap>]> {\n    for (const [ identifier ] of accessMap) {\n      if (this.authStrategy.isAuxiliaryIdentifier(identifier)) {\n        const subject = this.authStrategy.getSubjectIdentifier(identifier);\n        // Unfortunately there is no enum inheritance so we have to cast like this\n        yield [ identifier, [ subject, new Set([ AclMode.control ] as unknown as AccessMode[]) ]];\n      }\n    }\n  }\n\n  /**\n   * Updates the permissions for an authorization resource\n   * by interpreting the Control access mode as allowing full access.\n   */\n  protected interpretControl(identifier: ResourceIdentifier, permissionSet: AclPermissionSet = {}): PermissionSet {\n    const { control } = permissionSet;\n    return {\n      read: control,\n      append: control,\n      write: control,\n      control,\n    } as AclPermissionSet;\n  }\n}\n"]}