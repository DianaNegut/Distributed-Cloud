{"version":3,"file":"PermissionBasedAuthorizer.js","sourceRoot":"","sources":["../../src/authorization/PermissionBasedAuthorizer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Credentials } from '../authentication/Credentials';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { ResourceSet } from '../storage/ResourceSet';\nimport { ForbiddenHttpError } from '../util/errors/ForbiddenHttpError';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport { UnauthorizedHttpError } from '../util/errors/UnauthorizedHttpError';\nimport type { AuthorizerInput } from './Authorizer';\nimport { Authorizer } from './Authorizer';\nimport type { PermissionSet } from './permissions/Permissions';\nimport { AccessMode } from './permissions/Permissions';\n\n/**\n * Authorizer that bases its decision on the output it gets from its PermissionReader.\n * For each permission it checks if the reader allows that for at least one credential type,\n * if yes, authorization is granted.\n * `undefined` values for reader results are interpreted as `false`.\n */\nexport class PermissionBasedAuthorizer extends Authorizer {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly resourceSet: ResourceSet;\n\n  /**\n   * The existence of the target resource determines the output status code for certain situations.\n   * The provided {@link ResourceSet} will be used for that.\n   *\n   * @param resourceSet - {@link ResourceSet} that can verify the target resource existence.\n   */\n  public constructor(resourceSet: ResourceSet) {\n    super();\n    this.resourceSet = resourceSet;\n  }\n\n  public async handle(input: AuthorizerInput): Promise<void> {\n    const { credentials, requestedModes, availablePermissions } = input;\n\n    // Ensure all required modes are within the agent's permissions.\n    for (const [ identifier, modes ] of requestedModes.entrySets()) {\n      const modeString = [ ...modes ].join(',');\n      this.logger.debug(\n        `Checking if ${JSON.stringify(credentials)} has ${modeString} permissions for ${identifier.path}`,\n      );\n      const permissionSet = availablePermissions.get(identifier) ?? {};\n      for (const mode of modes) {\n        try {\n          this.requireModePermission(credentials, permissionSet, mode);\n        } catch (error: unknown) {\n          await this.reportAccessError(identifier, modes, permissionSet, error);\n        }\n      }\n      this.logger.debug(`${JSON.stringify(credentials)} has ${modeString} permissions for ${identifier.path}`);\n    }\n  }\n\n  /**\n   * If we know the operation will return a 404 regardless (= resource does not exist and is not being created),\n   * and the agent is allowed to know about its existence (= the agent has Read permissions),\n   * then immediately send the 404 here, as it makes any other agent permissions irrelevant.\n   *\n   * Otherwise, deny access based on existing grounds.\n   */\n  private async reportAccessError(\n    identifier: ResourceIdentifier,\n    modes: ReadonlySet<AccessMode>,\n    permissionSet: PermissionSet,\n    cause: unknown,\n  ): Promise<never> {\n    const exposeExistence = permissionSet[AccessMode.read];\n    if (exposeExistence && !modes.has(AccessMode.create) && !await this.resourceSet.hasResource(identifier)) {\n      throw new NotFoundHttpError();\n    }\n\n    throw cause;\n  }\n\n  /**\n   * Ensures that at least one of the credentials provides permissions for the given mode.\n   * Throws a {@link ForbiddenHttpError} or {@link UnauthorizedHttpError} depending on the credentials\n   * if access is not allowed.\n   *\n   * @param credentials - Credentials that require access.\n   * @param permissionSet - PermissionSet describing the available permissions of the credentials.\n   * @param mode - Which mode is requested.\n   */\n  private requireModePermission(credentials: Credentials, permissionSet: PermissionSet, mode: AccessMode): void {\n    if (!permissionSet[mode]) {\n      if (this.isAuthenticated(credentials)) {\n        this.logger.warn(`Agent ${JSON.stringify(credentials)} has no ${mode} permissions`);\n        throw new ForbiddenHttpError();\n      } else {\n        // Solid, ยง2.1: \"When a client does not provide valid credentials when requesting a resource that requires it,\n        // the data pod MUST send a response with a 401 status code (unless 404 is preferred for security reasons).\"\n        // https://solid.github.io/specification/protocol#http-server\n        this.logger.warn(`Unauthenticated agent has no ${mode} permissions`);\n        throw new UnauthorizedHttpError();\n      }\n    }\n  }\n\n  /**\n   * Checks whether the agent is authenticated (logged in) or not (public/anonymous).\n   *\n   * @param credentials - Credentials to check.\n   */\n  private isAuthenticated(credentials: Credentials): boolean {\n    return Object.values(credentials).some((cred): boolean => cred !== undefined);\n  }\n}\n"]}