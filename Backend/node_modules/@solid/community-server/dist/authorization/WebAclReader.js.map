{"version":3,"file":"WebAclReader.js","sourceRoot":"","sources":["../../src/authorization/WebAclReader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Store } from 'n3';\nimport type { Credentials } from '../authentication/Credentials';\nimport type { AuxiliaryIdentifierStrategy } from '../http/auxiliary/AuxiliaryIdentifierStrategy';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { ResourceSet } from '../storage/ResourceSet';\nimport type { ResourceStore } from '../storage/ResourceStore';\nimport { INTERNAL_QUADS } from '../util/ContentTypes';\nimport { createErrorMessage } from '../util/errors/ErrorUtil';\nimport { ForbiddenHttpError } from '../util/errors/ForbiddenHttpError';\nimport { InternalServerError } from '../util/errors/InternalServerError';\nimport type { IdentifierStrategy } from '../util/identifiers/IdentifierStrategy';\nimport { IdentifierMap, IdentifierSetMultiMap } from '../util/map/IdentifierMap';\nimport { readableToQuads } from '../util/StreamUtil';\nimport { ACL, RDF } from '../util/Vocabularies';\nimport type { AccessChecker } from './access/AccessChecker';\nimport type { PermissionReaderInput } from './PermissionReader';\nimport { PermissionReader } from './PermissionReader';\nimport type { AclPermissionSet } from './permissions/AclPermissionSet';\nimport { AclMode } from './permissions/AclPermissionSet';\nimport type { PermissionMap } from './permissions/Permissions';\nimport { AccessMode } from './permissions/Permissions';\n\n// Maps WebACL-specific modes to generic access modes.\nconst modesMap: Record<string, readonly (keyof AclPermissionSet)[]> = {\n  [ACL.Read]: [ AccessMode.read ],\n  [ACL.Write]: [ AccessMode.append, AccessMode.write ],\n  [ACL.Append]: [ AccessMode.append ],\n  [ACL.Control]: [ AclMode.control ],\n} as const;\n\n/**\n * Finds the permissions of a resource as defined in the corresponding ACL resource.\n * Does not make any deductions such as checking parent containers for create permissions\n * or applying control permissions for ACL resources.\n *\n * Specific access checks are done by the provided {@link AccessChecker}.\n */\nexport class WebAclReader extends PermissionReader {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly aclStrategy: AuxiliaryIdentifierStrategy;\n  private readonly resourceSet: ResourceSet;\n  private readonly aclStore: ResourceStore;\n  private readonly identifierStrategy: IdentifierStrategy;\n  private readonly accessChecker: AccessChecker;\n\n  public constructor(\n    aclStrategy: AuxiliaryIdentifierStrategy,\n    resourceSet: ResourceSet,\n    aclStore: ResourceStore,\n    identifierStrategy: IdentifierStrategy,\n    accessChecker: AccessChecker,\n  ) {\n    super();\n    this.aclStrategy = aclStrategy;\n    this.resourceSet = resourceSet;\n    this.aclStore = aclStore;\n    this.identifierStrategy = identifierStrategy;\n    this.accessChecker = accessChecker;\n  }\n\n  /**\n   * Checks if an agent is allowed to execute the requested actions.\n   * Will throw an error if this is not the case.\n   */\n  public async handle({ credentials, requestedModes }: PermissionReaderInput): Promise<PermissionMap> {\n    // Determine the required access modes\n    this.logger.debug(`Retrieving permissions of ${credentials.agent?.webId ?? 'an unknown agent'}`);\n    const aclMap = await this.getAclMatches(requestedModes.distinctKeys());\n    const storeMap = await this.findAuthorizationStatements(aclMap);\n    return this.findPermissions(storeMap, credentials);\n  }\n\n  /**\n   * Finds the permissions in the provided WebACL quads.\n   *\n   * Rather than restricting the search to only the required modes,\n   * we collect all modes in order to have complete metadata (for instance, for the WAC-Allow header).\n   *\n   * @param aclMap - A map containing stores of ACL data linked to their relevant identifiers.\n   * @param credentials - Credentials to check permissions for.\n   */\n  private async findPermissions(aclMap: Map<Store, ResourceIdentifier[]>, credentials: Credentials):\n  Promise<PermissionMap> {\n    const result: PermissionMap = new IdentifierMap();\n    for (const [ store, aclIdentifiers ] of aclMap) {\n      const permissionSet = await this.determinePermissions(store, credentials);\n      for (const identifier of aclIdentifiers) {\n        result.set(identifier, permissionSet);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Determines the available permissions for the given credentials.\n   *\n   * @param acl - Store containing all relevant authorization triples.\n   * @param credentials - Credentials to find the permissions for.\n   */\n  private async determinePermissions(acl: Store, credentials: Credentials): Promise<AclPermissionSet> {\n    const aclPermissions: AclPermissionSet = {};\n\n    // Apply all ACL rules\n    const aclRules = acl.getSubjects(RDF.type, ACL.Authorization, null);\n    for (const rule of aclRules) {\n      const hasAccess = await this.accessChecker.handleSafe({ acl, rule, credentials });\n      if (hasAccess) {\n        // Set all allowed modes to true\n        const modes = acl.getObjects(rule, ACL.mode, null);\n        for (const { value: aclMode } of modes) {\n          if (aclMode in modesMap) {\n            for (const mode of modesMap[aclMode]) {\n              aclPermissions[mode] = true;\n            }\n          }\n        }\n      }\n    }\n\n    return aclPermissions;\n  }\n\n  /**\n   * Finds the ACL data relevant for all the given resources.\n   * The input set will be modified in place.\n   *\n   * @param targets - Targets to find ACL data for.\n   *\n   * @returns A map linking ACL resources to the relevant identifiers.\n   */\n  private async getAclMatches(targets: Iterable<ResourceIdentifier>):\n  Promise<IdentifierSetMultiMap<ResourceIdentifier>> {\n    const aclMap = new IdentifierSetMultiMap<ResourceIdentifier>();\n\n    for (const target of targets) {\n      this.logger.debug(`Searching ACL data for ${target.path}`);\n      const aclIdentifier = await this.getAclRecursive(target);\n      aclMap.add(aclIdentifier, target);\n    }\n\n    return aclMap;\n  }\n\n  /**\n   * Finds the ACL document relevant for the given identifier,\n   * following the steps defined in https://solidproject.org/TR/2021/wac-20210711#effective-acl-resource.\n   *\n   * @param identifier - {@link ResourceIdentifier} of which we need the ACL document.\n   *\n   * @returns The {@link ResourceIdentifier} of the relevant ACL document.\n   */\n  private async getAclRecursive(identifier: ResourceIdentifier): Promise<ResourceIdentifier> {\n    // Obtain the direct ACL document for the resource, if it exists\n    this.logger.debug(`Trying to read the direct ACL document of ${identifier.path}`);\n\n    const acl = this.aclStrategy.getAuxiliaryIdentifier(identifier);\n    this.logger.debug(`Determining existence of  ${acl.path}`);\n    if (await this.resourceSet.hasResource(acl)) {\n      this.logger.info(`Found applicable ACL document ${acl.path}`);\n      return acl;\n    }\n    this.logger.debug(`No direct ACL document found for ${identifier.path}`);\n\n    // Find the applicable ACL document of the parent container\n    this.logger.debug(`Traversing to the parent of ${identifier.path}`);\n    if (this.identifierStrategy.isRootContainer(identifier)) {\n      this.logger.error(`No ACL document found for root container ${identifier.path}`);\n      // https://solidproject.org/TR/2021/wac-20210711#acl-resource-representation\n      // The root container MUST have an ACL resource with a representation.\n      throw new ForbiddenHttpError('No ACL document found for root container');\n    }\n    const parent = this.identifierStrategy.getParentContainer(identifier);\n    return this.getAclRecursive(parent);\n  }\n\n  /**\n   * For every ACL/identifier combination it finds the relevant ACL triples for that identifier.\n   * This is done in such a way that store results are reused for all matching identifiers.\n   * The split is based on the `acl:accessTo` and `acl:default` triples.\n   *\n   * @param map - Map of matches that need to be filtered.\n   */\n  private async findAuthorizationStatements(map: IdentifierSetMultiMap<ResourceIdentifier>):\n  Promise<Map<Store, ResourceIdentifier[]>> {\n    // For every found ACL document, filter out triples that match for specific identifiers\n    const result = new Map<Store, ResourceIdentifier[]>();\n    for (const [ aclIdentifier, matchedTargets ] of map.entrySets()) {\n      const subject = this.aclStrategy.getSubjectIdentifier(aclIdentifier);\n      this.logger.debug(`Trying to read the ACL document ${aclIdentifier.path}`);\n      let contents: Store;\n      try {\n        const data = await this.aclStore.getRepresentation(aclIdentifier, { type: { [INTERNAL_QUADS]: 1 }});\n        contents = await readableToQuads(data.data);\n      } catch (error: unknown) {\n        // Something is wrong with the server if we can't read the resource\n        const message = `Error reading ACL resource ${aclIdentifier.path}: ${createErrorMessage(error)}`;\n        this.logger.error(message);\n        throw new InternalServerError(message, { cause: error });\n      }\n\n      // SubjectIdentifiers are those that match the subject identifier of the found ACL document (so max 1).\n      // Due to how the effective ACL document is found, all other identifiers must be (transitive) children.\n      // This has impact on whether the `acl:accessTo` or `acl:default` predicate needs to be checked.\n      const subjectIdentifiers: ResourceIdentifier[] = [];\n      const childIdentifiers: ResourceIdentifier[] = [];\n      for (const target of matchedTargets) {\n        (target.path === subject.path ? subjectIdentifiers : childIdentifiers).push(target);\n      }\n      if (subjectIdentifiers.length > 0) {\n        const subjectStore = await this.filterStore(contents, subject.path, true);\n        result.set(subjectStore, subjectIdentifiers);\n      }\n      if (childIdentifiers.length > 0) {\n        const childStore = await this.filterStore(contents, subject.path, false);\n        result.set(childStore, childIdentifiers);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Extracts all rules from the store that are relevant for the given target,\n   * based on either the `acl:accessTo` or `acl:default` predicates.\n   *\n   * @param store - Store to filter.\n   * @param target - The identifier of which the acl rules need to be known.\n   * @param directAcl - If the store contains triples from the direct acl resource of the target or not.\n   *                    Determines if `acl:accessTo` or `acl:default` are used.\n   *\n   * @returns A store containing the relevant triples for the given target.\n   */\n  private async filterStore(store: Store, target: string, directAcl: boolean): Promise<Store> {\n    // Find subjects that occur with a given predicate/object, and collect all their triples\n    const subjectData = new Store();\n    const subjects = store.getSubjects(directAcl ? ACL.terms.accessTo : ACL.terms.default, target, null);\n    for (const subject of subjects) {\n      subjectData.addQuads(store.getQuads(subject, null, null, null));\n    }\n    return subjectData;\n  }\n}\n"]}