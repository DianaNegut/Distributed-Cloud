{"version":3,"file":"AuthorizationParser.js","sourceRoot":"","sources":["../../../../src/http/input/metadata/AuthorizationParser.ts"],"names":[],"mappings":";;;AAAA,2BAAiC;AAGjC,yDAAsE;AACtE,6DAAwD;AAExD,qDAAkD;AAClD,IAAO,SAAS,GAAG,gBAAW,CAAC,SAAS,CAAC;AAEzC;;;;;;;;GAQG;AACH,MAAa,mBAAoB,SAAQ,+BAAc;IACpC,OAAO,CAA4B;IAEpD,YAAmB,OAA+B;QAChD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,WAAW,CAC/B,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAE,MAAM,EAAE,GAAG,CAAE,EAAuB,EAAE,CAAC,CAAE,MAAM,EAAE,SAAS,CAAC,GAAG,CAAC,CAAE,CAAC,CAClG,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAiE;QACnF,MAAM,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC;QACvD,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,OAAO;QACT,CAAC;QACD,KAAK,MAAM,CAAE,MAAM,EAAE,GAAG,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;YAC3D,IAAI,IAAA,uCAA0B,EAAC,MAAM,EAAE,UAAU,CAAC,EAAE,CAAC;gBACnD,qCAAqC;gBACrC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,yBAAU,CAAC,gBAAgB,CAAC,CAAC;gBAC1F,4BAA4B;gBAC5B,OAAO;YACT,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAxBD,kDAwBC","sourcesContent":["import { DataFactory } from 'n3';\nimport type { NamedNode } from '@rdfjs/types';\nimport type { HttpRequest } from '../../../server/HttpRequest';\nimport { matchesAuthorizationScheme } from '../../../util/HeaderUtil';\nimport { SOLID_META } from '../../../util/Vocabularies';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataParser } from './MetadataParser';\nimport namedNode = DataFactory.namedNode;\n\n/**\n * Parses specific authorization schemes and stores their value as metadata.\n * The keys of the input `authMap` should be the schemes,\n * and the values the corresponding predicate that should be used to store the value in the metadata.\n * The scheme will be sliced off the value, after which it is used as the object in the metadata triple.\n *\n * This should be used for custom authorization schemes,\n * for things like OIDC tokens a {@link CredentialsExtractor} should be used.\n */\nexport class AuthorizationParser extends MetadataParser {\n  private readonly authMap: Record<string, NamedNode>;\n\n  public constructor(authMap: Record<string, string>) {\n    super();\n    this.authMap = Object.fromEntries(\n      Object.entries(authMap).map(([ scheme, uri ]): [string, NamedNode] => [ scheme, namedNode(uri) ]),\n    );\n  }\n\n  public async handle(input: { request: HttpRequest; metadata: RepresentationMetadata }): Promise<void> {\n    const authHeader = input.request.headers.authorization;\n    if (!authHeader) {\n      return;\n    }\n    for (const [ scheme, uri ] of Object.entries(this.authMap)) {\n      if (matchesAuthorizationScheme(scheme, authHeader)) {\n        // This metadata should not be stored\n        input.metadata.add(uri, authHeader.slice(scheme.length + 1), SOLID_META.ResponseMetadata);\n        // There can only be 1 match\n        return;\n      }\n    }\n  }\n}\n"]}