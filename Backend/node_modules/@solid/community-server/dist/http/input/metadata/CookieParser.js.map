{"version":3,"file":"CookieParser.js","sourceRoot":"","sources":["../../../../src/http/input/metadata/CookieParser.ts"],"names":[],"mappings":";;;AAAA,mCAA+B;AAC/B,2BAAiC;AAGjC,6DAAwD;AAExD,qDAAkD;AAClD,IAAO,SAAS,GAAG,gBAAW,CAAC,SAAS,CAAC;AAEzC;;;;;GAKG;AACH,MAAa,YAAa,SAAQ,+BAAc;IAC7B,SAAS,CAA4B;IAEtD,YAAmB,SAAiC;QAClD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,WAAW,CACjC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,CAAE,IAAI,EAAE,GAAG,CAAE,EAAuB,EAAE,CAAC,CAAE,IAAI,EAAE,SAAS,CAAC,GAAG,CAAC,CAAE,CAAC,CAChG,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAiE;QACnF,MAAM,OAAO,GAAG,IAAA,cAAK,EAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;QAC1D,KAAK,MAAM,CAAE,IAAI,EAAE,GAAG,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;YAC3D,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;YAC5B,IAAI,KAAK,EAAE,CAAC;gBACV,qCAAqC;gBACrC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,yBAAU,CAAC,gBAAgB,CAAC,CAAC;YAC9D,CAAC;QACH,CAAC;IACH,CAAC;CACF;AApBD,oCAoBC","sourcesContent":["import { parse } from 'cookie';\nimport { DataFactory } from 'n3';\nimport type { NamedNode } from '@rdfjs/types';\nimport type { HttpRequest } from '../../../server/HttpRequest';\nimport { SOLID_META } from '../../../util/Vocabularies';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataParser } from './MetadataParser';\nimport namedNode = DataFactory.namedNode;\n\n/**\n * Parses the cookie header and stores their values as metadata.\n * The keys of the input `cookieMap` should be the cookie names,\n * and the values the corresponding predicate that should be used to store the value in the metadata.\n * The values of the cookies will be used as objects in the generated triples\n */\nexport class CookieParser extends MetadataParser {\n  private readonly cookieMap: Record<string, NamedNode>;\n\n  public constructor(cookieMap: Record<string, string>) {\n    super();\n    this.cookieMap = Object.fromEntries(\n      Object.entries(cookieMap).map(([ name, uri ]): [string, NamedNode] => [ name, namedNode(uri) ]),\n    );\n  }\n\n  public async handle(input: { request: HttpRequest; metadata: RepresentationMetadata }): Promise<void> {\n    const cookies = parse(input.request.headers.cookie ?? '');\n    for (const [ name, uri ] of Object.entries(this.cookieMap)) {\n      const value = cookies[name];\n      if (value) {\n        // This metadata should not be stored\n        input.metadata.add(uri, value, SOLID_META.ResponseMetadata);\n      }\n    }\n  }\n}\n"]}