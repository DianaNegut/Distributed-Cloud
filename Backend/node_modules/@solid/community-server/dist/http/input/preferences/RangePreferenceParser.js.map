{"version":3,"file":"RangePreferenceParser.js","sourceRoot":"","sources":["../../../../src/http/input/preferences/RangePreferenceParser.ts"],"names":[],"mappings":";;;AACA,kFAA+E;AAE/E,yDAAsD;AAEtD;;;GAGG;AACH,MAAa,qBAAsB,SAAQ,mCAAgB;IAClD,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,EAAE,OAAO,EAAE,EAAE,KAAK,EAAE,EAAC,EAA2B;QAC7E,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,MAAM,CAAE,IAAI,EAAE,SAAS,CAAE,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,EAAU,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;QAClF,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACtB,MAAM,IAAI,yCAAmB,CAAC,wCAAwC,KAAK,EAAE,CAAC,CAAC;QACjF,CAAC;QACD,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,MAAM,IAAI,yCAAmB,CAAC,+BAA+B,KAAK,EAAE,CAAC,CAAC;QACxE,CAAC;QAED,MAAM,MAAM,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,EAAU,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;QACzE,MAAM,KAAK,GAAsC,EAAE,CAAC;QACpD,KAAK,MAAM,UAAU,IAAI,MAAM,EAAE,CAAC;YAChC,MAAM,CAAE,KAAK,EAAE,GAAG,CAAE,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,EAAU,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;YAClF,8EAA8E;YAC9E,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;gBAC5B,MAAM,IAAI,yCAAmB,CAAC,+BAA+B,KAAK,EAAE,CAAC,CAAC;YACxE,CAAC;YACD,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACvB,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACrB,MAAM,IAAI,yCAAmB,CAAC,+BAA+B,KAAK,EAAE,CAAC,CAAC;gBACxE,CAAC;gBACD,KAAK,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;YACnD,CAAC;iBAAM,CAAC;gBACN,MAAM,IAAI,GAAyB,EAAE,KAAK,EAAE,MAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,CAAC;gBACzE,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACnB,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;gBACtC,CAAC;gBACD,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACnB,CAAC;QACH,CAAC;QAED,OAAO,EAAE,KAAK,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,EAAC,CAAC;IACnC,CAAC;CACF;AAtCD,sDAsCC","sourcesContent":["import type { HttpRequest } from '../../../server/HttpRequest';\nimport { BadRequestHttpError } from '../../../util/errors/BadRequestHttpError';\nimport type { RepresentationPreferences } from '../../representation/RepresentationPreferences';\nimport { PreferenceParser } from './PreferenceParser';\n\n/**\n * Parses the range header into range preferences.\n * If the range corresponds to a suffix-length range, it will be stored in `start` as a negative value.\n */\nexport class RangePreferenceParser extends PreferenceParser {\n  public async handle({ request: { headers: { range }}}: { request: HttpRequest }): Promise<RepresentationPreferences> {\n    if (!range) {\n      return {};\n    }\n\n    const [ unit, rangeTail ] = range.split('=').map((entry): string => entry.trim());\n    if (unit.length === 0) {\n      throw new BadRequestHttpError(`Missing unit value from range header ${range}`);\n    }\n    if (!rangeTail) {\n      throw new BadRequestHttpError(`Invalid range header format ${range}`);\n    }\n\n    const ranges = rangeTail.split(',').map((entry): string => entry.trim());\n    const parts: { start: number; end?: number }[] = [];\n    for (const rangeEntry of ranges) {\n      const [ start, end ] = rangeEntry.split('-').map((entry): string => entry.trim());\n      // This can actually be undefined if the split results in less than 2 elements\n      if (typeof end !== 'string') {\n        throw new BadRequestHttpError(`Invalid range header format ${range}`);\n      }\n      if (start.length === 0) {\n        if (end.length === 0) {\n          throw new BadRequestHttpError(`Invalid range header format ${range}`);\n        }\n        parts.push({ start: -Number.parseInt(end, 10) });\n      } else {\n        const part: typeof parts[number] = { start: Number.parseInt(start, 10) };\n        if (end.length > 0) {\n          part.end = Number.parseInt(end, 10);\n        }\n        parts.push(part);\n      }\n    }\n\n    return { range: { unit, parts }};\n  }\n}\n"]}