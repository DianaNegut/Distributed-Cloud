{"version":3,"file":"BasicResponseWriter.js","sourceRoot":"","sources":["../../../src/http/output/BasicResponseWriter.ts"],"names":[],"mappings":";;;AAAA,mDAAqD;AAErD,4EAAgF;AAChF,uFAAoF;AACpF,sDAAmD;AAGnD,qDAAkD;AAElD;;GAEG;AACH,MAAa,mBAAoB,SAAQ,+BAAc;IAClC,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAC9B,cAAc,CAAiB;IAEhD,YAAmB,cAA8B;QAC/C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAA8D;QACnF,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,EAAE,WAAW,CAAC;QACvD,IAAI,IAAA,sCAAqB,EAAC,WAAW,CAAC,EAAE,CAAC;YACvC,MAAM,IAAI,iDAAuB,CAAC,8CAA8C,WAAW,EAAE,CAAC,CAAC;QACjG,CAAC;IACH,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAA8D;QAChF,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;YAC1B,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,KAAK,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;QACtG,CAAC;QAED,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QAElD,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;YACtB,MAAM,IAAI,GAAG,IAAA,uBAAU,EAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC3D,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAK,EAAQ,EAAE;gBAC/B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4EAA4E,CAAC,CAAC;gBAChG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,mBAAmB,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;YACxD,CAAC,CAAC,CAAC;QACL,CAAC;aAAM,CAAC;YACN,0EAA0E;YAC1E,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;QACvB,CAAC;IACH,CAAC;CACF;AAlCD,kDAkCC","sourcesContent":["import { getLoggerFor } from '../../logging/LogUtil';\nimport type { HttpResponse } from '../../server/HttpResponse';\nimport { isInternalContentType } from '../../storage/conversion/ConversionUtil';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { pipeSafely } from '../../util/StreamUtil';\nimport type { MetadataWriter } from './metadata/MetadataWriter';\nimport type { ResponseDescription } from './response/ResponseDescription';\nimport { ResponseWriter } from './ResponseWriter';\n\n/**\n * Writes to an {@link HttpResponse} based on the incoming {@link ResponseDescription}.\n */\nexport class BasicResponseWriter extends ResponseWriter {\n  protected readonly logger = getLoggerFor(this);\n  private readonly metadataWriter: MetadataWriter;\n\n  public constructor(metadataWriter: MetadataWriter) {\n    super();\n    this.metadataWriter = metadataWriter;\n  }\n\n  public async canHandle(input: { response: HttpResponse; result: ResponseDescription }): Promise<void> {\n    const contentType = input.result.metadata?.contentType;\n    if (isInternalContentType(contentType)) {\n      throw new NotImplementedHttpError(`Cannot serialize the internal content type ${contentType}`);\n    }\n  }\n\n  public async handle(input: { response: HttpResponse; result: ResponseDescription }): Promise<void> {\n    if (input.result.metadata) {\n      await this.metadataWriter.handleSafe({ response: input.response, metadata: input.result.metadata });\n    }\n\n    input.response.writeHead(input.result.statusCode);\n\n    if (input.result.data) {\n      const pipe = pipeSafely(input.result.data, input.response);\n      pipe.on('error', (error): void => {\n        this.logger.error(`Aborting streaming response because of server error; headers already sent.`);\n        this.logger.error(`Response error: ${error.message}`);\n      });\n    } else {\n      // If there is input data the response will end once the input stream ends\n      input.response.end();\n    }\n  }\n}\n"]}