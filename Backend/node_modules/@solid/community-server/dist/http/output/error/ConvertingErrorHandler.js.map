{"version":3,"file":"ConvertingErrorHandler.js","sourceRoot":"","sources":["../../../../src/http/output/error/ConvertingErrorHandler.ts"],"names":[],"mappings":";;;AAIA,6DAA4D;AAE5D,kFAA+E;AAI/E,iDAA8C;AAQ9C;;;GAGG;AACH,MAAa,sBAAuB,SAAQ,2BAAY;IACrC,SAAS,CAA0B;IACnC,gBAAgB,CAAmB;IACnC,cAAc,CAAU;IAEzC,YAAmB,SAAkC,EAAE,gBAAkC,EAAE,cAAc,GAAG,KAAK;QAC/G,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAuB;QAC5C,MAAM,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QAClE,MAAM,EAAE,cAAc,EAAE,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAEjE,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;IACjD,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAuB;QACzC,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAE7E,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;QAE9D,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;IACpD,CAAC;IAEM,KAAK,CAAC,UAAU,CAAC,KAAuB;QAC7C,MAAM,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;QAClE,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAE7E,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;QAElE,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;IACpD,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,mBAAmB,CAAC,EAAE,KAAK,EAAE,OAAO,EAAoB;QACpE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;YACzB,OAAO,KAAK,CAAC,KAAK,CAAC;YACnB,2CAA2C;YAC3C,OAAQ,KAA4B,CAAC,KAAK,CAAC;QAC7C,CAAC;QACD,MAAM,cAAc,GAAG,IAAI,yCAAmB,CAAC,CAAE,KAAK,CAAE,EAAE,KAAK,CAAC,QAAQ,EAAE,6BAAc,EAAE,KAAK,CAAC,CAAC;QACjG,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACtE,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC;QACpE,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC,UAAU,EAAE,cAAc,EAAE,EAAE,UAAU,EAAE,cAAc,EAAE,WAAW,EAAE,EAAC,CAAC;IACtG,CAAC;IAED;;OAEG;IACK,cAAc,CAAC,UAAkB,EAAE,SAAyB;QAClE,OAAO;YACL,UAAU;YACV,QAAQ,EAAE,SAAS,CAAC,QAAQ;YAC5B,IAAI,EAAE,SAAS,CAAC,IAAI;SACrB,CAAC;IACJ,CAAC;CACF;AA7DD,wDA6DC","sourcesContent":["import type {\n  RepresentationConverter,\n  RepresentationConverterArgs,\n} from '../../../storage/conversion/RepresentationConverter';\nimport { INTERNAL_ERROR } from '../../../util/ContentTypes';\nimport type { PreferenceParser } from '../../input/preferences/PreferenceParser';\nimport { BasicRepresentation } from '../../representation/BasicRepresentation';\nimport type { Representation } from '../../representation/Representation';\nimport type { ResponseDescription } from '../response/ResponseDescription';\nimport type { ErrorHandlerArgs } from './ErrorHandler';\nimport { ErrorHandler } from './ErrorHandler';\n\n// Used by internal helper function\ntype PreparedArguments = {\n  statusCode: number;\n  conversionArgs: RepresentationConverterArgs;\n};\n\n/**\n * Converts an error into a Representation of content type internal/error.\n * Then feeds that representation into its converter to create a representation based on the given preferences.\n */\nexport class ConvertingErrorHandler extends ErrorHandler {\n  private readonly converter: RepresentationConverter;\n  private readonly preferenceParser: PreferenceParser;\n  private readonly showStackTrace: boolean;\n\n  public constructor(converter: RepresentationConverter, preferenceParser: PreferenceParser, showStackTrace = false) {\n    super();\n    this.converter = converter;\n    this.preferenceParser = preferenceParser;\n    this.showStackTrace = showStackTrace;\n  }\n\n  public async canHandle(input: ErrorHandlerArgs): Promise<void> {\n    await this.preferenceParser.canHandle({ request: input.request });\n    const { conversionArgs } = await this.extractErrorDetails(input);\n\n    await this.converter.canHandle(conversionArgs);\n  }\n\n  public async handle(input: ErrorHandlerArgs): Promise<ResponseDescription> {\n    const { statusCode, conversionArgs } = await this.extractErrorDetails(input);\n\n    const converted = await this.converter.handle(conversionArgs);\n\n    return this.createResponse(statusCode, converted);\n  }\n\n  public async handleSafe(input: ErrorHandlerArgs): Promise<ResponseDescription> {\n    await this.preferenceParser.canHandle({ request: input.request });\n    const { statusCode, conversionArgs } = await this.extractErrorDetails(input);\n\n    const converted = await this.converter.handleSafe(conversionArgs);\n\n    return this.createResponse(statusCode, converted);\n  }\n\n  /**\n   * Prepares the arguments used by all functions.\n   */\n  private async extractErrorDetails({ error, request }: ErrorHandlerArgs): Promise<PreparedArguments> {\n    if (!this.showStackTrace) {\n      delete error.stack;\n      // Cheating here to delete a readonly field\n      delete (error as { cause: unknown }).cause;\n    }\n    const representation = new BasicRepresentation([ error ], error.metadata, INTERNAL_ERROR, false);\n    const identifier = { path: representation.metadata.identifier.value };\n    const preferences = await this.preferenceParser.handle({ request });\n    return { statusCode: error.statusCode, conversionArgs: { identifier, representation, preferences }};\n  }\n\n  /**\n   * Creates a ResponseDescription based on the Representation.\n   */\n  private createResponse(statusCode: number, converted: Representation): ResponseDescription {\n    return {\n      statusCode,\n      metadata: converted.metadata,\n      data: converted.data,\n    };\n  }\n}\n"]}