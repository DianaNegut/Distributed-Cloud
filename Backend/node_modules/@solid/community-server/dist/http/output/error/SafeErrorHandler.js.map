{"version":3,"file":"SafeErrorHandler.js","sourceRoot":"","sources":["../../../../src/http/output/error/SafeErrorHandler.ts"],"names":[],"mappings":";;;AAAA,sDAAwD;AACxD,8DAAoE;AACpE,yDAA6D;AAG7D,iDAA8C;AAE9C;;;GAGG;AACH,MAAa,gBAAiB,SAAQ,2BAAY;IAC7B,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE9B,YAAY,CAAe;IAC3B,cAAc,CAAU;IAEzC,YAAmB,YAA0B,EAAE,cAAc,GAAG,KAAK;QACnE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAuB;QACzC,IAAI,CAAC;YACH,OAAO,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QACnD,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,0CAA0C,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC3F,CAAC;QACD,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC;QACxB,KAAK,CAAC,QAAQ,CAAC,WAAW,GAAG,YAAY,CAAC;QAE1C,MAAM,IAAI,GAAG,OAAO,KAAK,CAAC,KAAK,KAAK,QAAQ,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC;YACnE,GAAG,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;YACpB,GAAG,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC;QAEtC,OAAO;YACL,UAAU,EAAE,KAAK,CAAC,UAAU;YAC5B,QAAQ,EAAE,KAAK,CAAC,QAAQ;YACxB,IAAI,EAAE,IAAA,8BAAiB,EAAC,IAAI,CAAC;SAC9B,CAAC;IACJ,CAAC;CACF;AA/BD,4CA+BC","sourcesContent":["import { getLoggerFor } from '../../../logging/LogUtil';\nimport { createErrorMessage } from '../../../util/errors/ErrorUtil';\nimport { guardedStreamFrom } from '../../../util/StreamUtil';\nimport type { ResponseDescription } from '../response/ResponseDescription';\nimport type { ErrorHandlerArgs } from './ErrorHandler';\nimport { ErrorHandler } from './ErrorHandler';\n\n/**\n * Returns a simple text description of an error.\n * This class is a failsafe in case the wrapped error handler fails.\n */\nexport class SafeErrorHandler extends ErrorHandler {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly errorHandler: ErrorHandler;\n  private readonly showStackTrace: boolean;\n\n  public constructor(errorHandler: ErrorHandler, showStackTrace = false) {\n    super();\n    this.errorHandler = errorHandler;\n    this.showStackTrace = showStackTrace;\n  }\n\n  public async handle(input: ErrorHandlerArgs): Promise<ResponseDescription> {\n    try {\n      return await this.errorHandler.handleSafe(input);\n    } catch (error: unknown) {\n      this.logger.debug(`Recovering from error handler failure: ${createErrorMessage(error)}`);\n    }\n    const { error } = input;\n    error.metadata.contentType = 'text/plain';\n\n    const text = typeof error.stack === 'string' && this.showStackTrace ?\n      `${error.stack}\\n` :\n      `${error.name}: ${error.message}\\n`;\n\n    return {\n      statusCode: error.statusCode,\n      metadata: error.metadata,\n      data: guardedStreamFrom(text),\n    };\n  }\n}\n"]}