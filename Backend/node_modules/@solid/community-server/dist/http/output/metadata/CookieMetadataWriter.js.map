{"version":3,"file":"CookieMetadataWriter.js","sourceRoot":"","sources":["../../../../src/http/output/metadata/CookieMetadataWriter.ts"],"names":[],"mappings":";;;AAAA,mCAAmC;AAEnC,2BAAiC;AAEjC,yDAAqD;AAErD,qDAAkD;AAElD;;;;;;;;GAQG;AACH,MAAa,oBAAqB,SAAQ,+BAAc;IACrC,SAAS,CAA8D;IAExF,YAAmB,SAAmE;QACpF,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,CAAyD,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC;aACvG,GAAG,CAAC,CAAC,CAAE,GAAG,EAAE,EAAE,IAAI,EAAE,aAAa,EAAE,CAAC,EAA8D,EAAE,CACnG;YACE,gBAAW,CAAC,SAAS,CAAC,GAAG,CAAC;YAC1B;gBACE,IAAI;gBACJ,aAAa,EAAE,aAAa,CAAC,CAAC,CAAC,gBAAW,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,SAAS;aAChF;SACF,CAAC,CAAC,CAAC;IACV,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAmE;QACrF,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC;QACrC,KAAK,MAAM,CAAE,GAAG,EAAE,EAAE,IAAI,EAAE,aAAa,EAAE,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,EAAE,CAAC;YACvE,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC;YACvC,IAAI,KAAK,EAAE,CAAC;gBACV,MAAM,UAAU,GAAG,aAAa,IAAI,QAAQ,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE,KAAK,CAAC;gBACvE,MAAM,OAAO,GAAG,OAAO,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBAClF,yGAAyG;gBACzG,qEAAqE;gBACrE,8EAA8E;gBAC9E,uDAAuD;gBACvD,8DAA8D;gBAC9D,IAAA,sBAAS,EAAC,QAAQ,EAAE,YAAY,EAAE,IAAA,kBAAS,EAAC,IAAI,EAAE,KAAK,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;YACrG,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAhCD,oDAgCC","sourcesContent":["import { serialize } from 'cookie';\nimport type { NamedNode } from 'n3';\nimport { DataFactory } from 'n3';\nimport type { HttpResponse } from '../../../server/HttpResponse';\nimport { addHeader } from '../../../util/HeaderUtil';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataWriter } from './MetadataWriter';\n\n/**\n * Generates the necessary `Set-Cookie` header if a cookie value is detected in the metadata.\n * The keys of the input `cookieMap` should be the URIs of the predicates\n * used in the metadata when the object is a cookie value.\n * The value of the map are objects that contain the name of the cookie,\n * and the URI that is used to store the expiration date in the metadata, if any.\n * If no expiration date is found in the metadata, none will be set for the cookie,\n * causing it to be a session cookie.\n */\nexport class CookieMetadataWriter extends MetadataWriter {\n  private readonly cookieMap: Map<NamedNode, { name: string; expirationUri?: NamedNode }>;\n\n  public constructor(cookieMap: Record<string, { name: string; expirationUri?: string }>) {\n    super();\n    this.cookieMap = new Map<NamedNode, { name: string; expirationUri?: NamedNode }>(Object.entries(cookieMap)\n      .map(([ uri, { name, expirationUri }]): [ NamedNode, { name: string; expirationUri?: NamedNode } ] =>\n        [\n          DataFactory.namedNode(uri),\n          {\n            name,\n            expirationUri: expirationUri ? DataFactory.namedNode(expirationUri) : undefined,\n          },\n        ]));\n  }\n\n  public async handle(input: { response: HttpResponse; metadata: RepresentationMetadata }): Promise<void> {\n    const { response, metadata } = input;\n    for (const [ uri, { name, expirationUri }] of this.cookieMap.entries()) {\n      const value = metadata.get(uri)?.value;\n      if (value) {\n        const expiration = expirationUri && metadata.get(expirationUri)?.value;\n        const expires = typeof expiration === 'string' ? new Date(expiration) : undefined;\n        // Not setting secure flag since not all tools realize those cookies are also valid for http://localhost.\n        // Not setting the httpOnly flag as that would prevent JS API access.\n        // SameSite: Lax makes it so the cookie gets sent if the origin is the server,\n        // or if the browser navigates there from another site.\n        // Setting the path to `/` so it applies to the entire server.\n        addHeader(response, 'Set-Cookie', serialize(name, value, { path: '/', sameSite: 'lax', expires }));\n      }\n    }\n  }\n}\n"]}