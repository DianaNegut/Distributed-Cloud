{"version":3,"file":"RangeMetadataWriter.js","sourceRoot":"","sources":["../../../../src/http/output/metadata/RangeMetadataWriter.ts"],"names":[],"mappings":";;;AAAA,sDAAwD;AAExD,yDAAqD;AACrD,qDAAmD;AACnD,6DAA+D;AAE/D,qDAAkD;AAElD;;;;;;;;;;GAUG;AACH,MAAa,mBAAoB,SAAQ,+BAAc;IAClC,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAExC,KAAK,CAAC,MAAM,CAAC,KAAmE;QACrF,MAAM,IAAI,GAAG,IAAA,oBAAS,EAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,oBAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;QAC7D,MAAM,IAAI,GAAG,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,yBAAU,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC;QAC9D,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;gBAC7B,IAAA,sBAAS,EAAC,KAAK,CAAC,QAAQ,EAAE,gBAAgB,EAAE,GAAG,IAAI,EAAE,CAAC,CAAC;YACzD,CAAC;YACD,OAAO;QACT,CAAC;QAED,IAAI,KAAK,GAAG,IAAA,oBAAS,EAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,yBAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;QAClE,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,GAAG,CAAC,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;YACvE,KAAK,GAAG,IAAI,GAAG,KAAK,CAAC;QACvB,CAAC;QACD,IAAI,GAAG,GAAG,IAAA,oBAAS,EAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,yBAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;QAC9D,IAAI,OAAO,GAAG,KAAK,QAAQ,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,CAAC;YACxD,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC;QACjB,CAAC;QAED,MAAM,WAAW,GAAG,GAAG,IAAI,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;QAC3E,IAAA,sBAAS,EAAC,KAAK,CAAC,QAAQ,EAAE,eAAe,EAAE,WAAW,CAAC,CAAC;QACxD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,CAAC;YACzD,IAAA,sBAAS,EAAC,KAAK,CAAC,QAAQ,EAAE,gBAAgB,EAAE,GAAG,GAAG,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC;QACpE,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,4EAA4E,WAAW,EAAE,CAAC,CAAC;QAC9G,CAAC;IACH,CAAC;CACF;AA9BD,kDA8BC","sourcesContent":["import { getLoggerFor } from '../../../logging/LogUtil';\nimport type { HttpResponse } from '../../../server/HttpResponse';\nimport { addHeader } from '../../../util/HeaderUtil';\nimport { termToInt } from '../../../util/QuadUtil';\nimport { POSIX, SOLID_HTTP } from '../../../util/Vocabularies';\nimport type { RepresentationMetadata } from '../../representation/RepresentationMetadata';\nimport { MetadataWriter } from './MetadataWriter';\n\n/**\n * Generates the necessary `content-range` header if there is range metadata.\n * If the start or end is unknown, a `*` will be used instead.\n * According to the RFC, this is incorrect,\n * but is all we can do as long as we don't know the full length of the representation in advance.\n * For the same reason, the total length of the representation will always be `*`.\n *\n * This class also adds the content-length header.\n * This will contain either the full size for standard requests,\n * or the size of the slice for range requests.\n */\nexport class RangeMetadataWriter extends MetadataWriter {\n  protected readonly logger = getLoggerFor(this);\n\n  public async handle(input: { response: HttpResponse; metadata: RepresentationMetadata }): Promise<void> {\n    const size = termToInt(input.metadata.get(POSIX.terms.size));\n    const unit = input.metadata.get(SOLID_HTTP.terms.unit)?.value;\n    if (!unit) {\n      if (typeof size === 'number') {\n        addHeader(input.response, 'Content-Length', `${size}`);\n      }\n      return;\n    }\n\n    let start = termToInt(input.metadata.get(SOLID_HTTP.terms.start));\n    if (typeof start === 'number' && start < 0 && typeof size === 'number') {\n      start = size + start;\n    }\n    let end = termToInt(input.metadata.get(SOLID_HTTP.terms.end));\n    if (typeof end !== 'number' && typeof size === 'number') {\n      end = size - 1;\n    }\n\n    const rangeHeader = `${unit} ${start ?? '*'}-${end ?? '*'}/${size ?? '*'}`;\n    addHeader(input.response, 'Content-Range', rangeHeader);\n    if (typeof start === 'number' && typeof end === 'number') {\n      addHeader(input.response, 'Content-Length', `${end - start + 1}`);\n    } else {\n      this.logger.warn(`Generating invalid content-range header due to missing size information: ${rangeHeader}`);\n    }\n  }\n}\n"]}