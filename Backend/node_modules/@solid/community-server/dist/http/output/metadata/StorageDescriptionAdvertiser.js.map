{"version":3,"file":"StorageDescriptionAdvertiser.js","sourceRoot":"","sources":["../../../../src/http/output/metadata/StorageDescriptionAdvertiser.ts"],"names":[],"mappings":";;;AAAA,sDAAwD;AAExD,8DAAoE;AACpE,yDAAqD;AACrD,qDAAiD;AACjD,6DAA6D;AAG7D,qDAAkD;AAElD;;;;GAIG;AACH,MAAa,4BAA6B,SAAQ,+BAAc;IAC3C,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE9B,eAAe,CAA0B;IACzC,YAAY,CAAS;IAEtC,YAAmB,eAAwC,EAAE,YAAoB;QAC/E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAuB;QAC7D,uEAAuE;QACvE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,kBAAG,CAAC,KAAK,CAAC,IAAI,EAAE,kBAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;YACtD,OAAO;QACT,CAAC;QACD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QACvD,IAAI,WAA+B,CAAC;QACpC,IAAI,CAAC;YACH,WAAW,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;YAC1E,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,sBAAsB,WAAW,CAAC,IAAI,EAAE,CAAC,CAAC;QAC9D,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,gCAAgC,IAAA,8BAAkB,EAAC,KAAK,CAC1E,8EAA8E,CAAC,CAAC;YAChF,OAAO;QACT,CAAC;QACD,MAAM,kBAAkB,GAAG,IAAA,kBAAO,EAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;QACxE,IAAA,sBAAS,EAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,kBAAkB,WAAW,oBAAK,CAAC,kBAAkB,GAAG,CAAC,CAAC;IAC5F,CAAC;CACF;AA9BD,oEA8BC","sourcesContent":["import { getLoggerFor } from '../../../logging/LogUtil';\nimport type { StorageLocationStrategy } from '../../../server/description/StorageLocationStrategy';\nimport { createErrorMessage } from '../../../util/errors/ErrorUtil';\nimport { addHeader } from '../../../util/HeaderUtil';\nimport { joinUrl } from '../../../util/PathUtil';\nimport { LDP, RDF, SOLID } from '../../../util/Vocabularies';\nimport type { ResourceIdentifier } from '../../representation/ResourceIdentifier';\nimport type { MetadataWriterInput } from './MetadataWriter';\nimport { MetadataWriter } from './MetadataWriter';\n\n/**\n * Adds a link header pointing to the relevant storage description resource.\n * Recursively checks parent containers until a storage container is found,\n * and then appends the provided relative path to determine the storage description resource.\n */\nexport class StorageDescriptionAdvertiser extends MetadataWriter {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly storageStrategy: StorageLocationStrategy;\n  private readonly relativePath: string;\n\n  public constructor(storageStrategy: StorageLocationStrategy, relativePath: string) {\n    super();\n    this.storageStrategy = storageStrategy;\n    this.relativePath = relativePath;\n  }\n\n  public async handle({ response, metadata }: MetadataWriterInput): Promise<void> {\n    // This indicates this is the response of a successful GET/HEAD request\n    if (!metadata.has(RDF.terms.type, LDP.terms.Resource)) {\n      return;\n    }\n    const identifier = { path: metadata.identifier.value };\n    let storageRoot: ResourceIdentifier;\n    try {\n      storageRoot = await this.storageStrategy.getStorageIdentifier(identifier);\n      this.logger.debug(`Found storage root ${storageRoot.path}`);\n    } catch (error: unknown) {\n      this.logger.error(`Unable to find storage root: ${createErrorMessage(error)\n      }. The storage/location import in the server configuration is probably wrong.`);\n      return;\n    }\n    const storageDescription = joinUrl(storageRoot.path, this.relativePath);\n    addHeader(response, 'Link', `<${storageDescription}>; rel=\"${SOLID.storageDescription}\"`);\n  }\n}\n"]}