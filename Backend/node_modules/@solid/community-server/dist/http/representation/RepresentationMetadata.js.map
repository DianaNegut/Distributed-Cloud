{"version":3,"file":"RepresentationMetadata.js","sourceRoot":"","sources":["../../../src/http/representation/RepresentationMetadata.ts"],"names":[],"mappings":"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","sourcesContent":["import { DataFactory, Store } from 'n3';\nimport type { BlankNode, DefaultGraph, Literal, NamedNode, Quad, Term } from '@rdfjs/types';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { ContentType, SIMPLE_MEDIA_RANGE } from '../../util/Header';\nimport { isTerm, toLiteral, toNamedTerm, toObjectTerm } from '../../util/TermUtil';\nimport { CONTENT_LENGTH_TERM, CONTENT_TYPE_TERM, RDFS, SOLID_META, XSD } from '../../util/Vocabularies';\nimport type { ResourceIdentifier } from './ResourceIdentifier';\nimport { isResourceIdentifier } from './ResourceIdentifier';\n\nexport type MetadataIdentifier = ResourceIdentifier | NamedNode | BlankNode;\nexport type MetadataValue = NamedNode | BlankNode | Literal | string | (NamedNode | Literal | BlankNode | string)[];\nexport type MetadataRecord = Record<string, MetadataValue>;\nexport type MetadataGraph = NamedNode | BlankNode | DefaultGraph | string;\n\n/**\n * Determines whether the object is a `RepresentationMetadata`.\n */\nexport function isRepresentationMetadata(object: unknown): object is RepresentationMetadata {\n  return typeof (object as RepresentationMetadata)?.setMetadata === 'function';\n}\n\n// Caches named node conversions\nconst cachedNamedNodes: Record<string, NamedNode> = {};\n\n/**\n * Converts the incoming name (URI or shorthand) to a named node.\n * The generated terms get cached to reduce the number of created nodes,\n * so only use this for internal constants!\n *\n * @param name - Predicate to potentially transform.\n */\nfunction toCachedNamedNode(name: string): NamedNode {\n  if (!(name in cachedNamedNodes)) {\n    cachedNamedNodes[name] = DataFactory.namedNode(name);\n  }\n  return cachedNamedNodes[name];\n}\n\n/**\n * Stores the metadata triples and provides methods for easy access.\n * Most functions return the metadata object to allow for chaining.\n */\nexport class RepresentationMetadata {\n  protected readonly logger = getLoggerFor(this);\n\n  private store: Store;\n  private id: NamedNode | BlankNode;\n\n  /**\n   * @param identifier - Identifier of the resource relevant to this metadata.\n   *                     A blank node will be generated if none is provided.\n   *                     Strings will be converted to named nodes. @ignored\n   * @param overrides - Key/value map of extra values that need to be added to the metadata. @ignored\n   *\n   * `@ignored` tag is necessary for Components-Generator.js\n   */\n  public constructor(identifier?: MetadataIdentifier, overrides?: MetadataRecord);\n\n  /**\n   * @param metadata - Starts as a copy of the input metadata.\n   * @param overrides - Key/value map of extra values that need to be added to the metadata.\n   *                    Will override values that were set by the input metadata.\n   */\n  public constructor(metadata?: RepresentationMetadata, overrides?: MetadataRecord);\n\n  /**\n   * @param identifier - Identifier of the resource relevant to this metadata.\n   * @param contentType - Override for the content type of the representation.\n   */\n  public constructor(identifier?: MetadataIdentifier, contentType?: string | ContentType);\n\n  /**\n   * @param metadata - Starts as a copy of the input metadata.\n   * @param contentType - Override for the content type of the representation.\n   */\n  public constructor(metadata?: RepresentationMetadata, contentType?: string | ContentType);\n\n  /**\n   * @param contentType - The content type of the representation.\n   */\n  public constructor(contentType?: string | ContentType);\n\n  /**\n   * @param metadata - Metadata values (defaulting to content type if a string)\n   */\n  public constructor(metadata?: RepresentationMetadata | MetadataRecord | string);\n\n  public constructor(\n    input?: MetadataIdentifier | RepresentationMetadata | MetadataRecord | ContentType | string,\n    overrides?: MetadataRecord | string | ContentType,\n  ) {\n    this.store = new Store();\n    if (isResourceIdentifier(input)) {\n      this.id = DataFactory.namedNode(input.path);\n    } else if (isTerm(input)) {\n      this.id = input;\n    } else if (isRepresentationMetadata(input)) {\n      this.id = input.identifier;\n      this.addQuads(input.quads());\n    } else {\n      overrides = input;\n      this.id = this.store.createBlankNode();\n    }\n\n    if (overrides) {\n      if (typeof overrides === 'string') {\n        this.contentType = overrides;\n      } else if (overrides instanceof ContentType) {\n        this.contentTypeObject = overrides;\n      } else {\n        this.setOverrides(overrides);\n      }\n    }\n  }\n\n  private setOverrides(overrides: Record<string, MetadataValue>): void {\n    for (const predicate of Object.keys(overrides)) {\n      const namedPredicate = toCachedNamedNode(predicate);\n      this.removeAll(namedPredicate);\n\n      let objects = overrides[predicate];\n      if (!Array.isArray(objects)) {\n        objects = [ objects ];\n      }\n      for (const object of objects) {\n        this.store.addQuad(this.id, namedPredicate, toObjectTerm(object, true));\n      }\n    }\n  }\n\n  /**\n   * @returns All matching metadata quads.\n   */\n  public quads(\n    subject: NamedNode | BlankNode | string | null = null,\n    predicate: NamedNode | null = null,\n    object: NamedNode | BlankNode | Literal | string | null = null,\n    graph: MetadataGraph | null = null,\n  ): Quad[] {\n    return this.store.getQuads(subject, predicate, object, graph);\n  }\n\n  /**\n   * Identifier of the resource this metadata is relevant to.\n   * Will update all relevant triples if this value gets changed.\n   */\n  public get identifier(): NamedNode | BlankNode {\n    return this.id;\n  }\n\n  public set identifier(id: NamedNode | BlankNode) {\n    if (!id.equals(this.id)) {\n      // Convert all instances of the old identifier to the new identifier in the stored quads\n      const quads = this.quads().map((quad): Quad => {\n        if (quad.subject.equals(this.id)) {\n          return DataFactory.quad(id, quad.predicate, quad.object, quad.graph);\n        }\n        if (quad.object.equals(this.id)) {\n          return DataFactory.quad(quad.subject, quad.predicate, id, quad.graph);\n        }\n        return quad;\n      });\n      this.store = new Store(quads);\n      this.id = id;\n    }\n  }\n\n  /**\n   * Helper function to import all entries from the given metadata.\n   * If the new metadata has a different identifier the internal one will be updated.\n   *\n   * @param metadata - Metadata to import.\n   */\n  public setMetadata(metadata: RepresentationMetadata): this {\n    this.identifier = metadata.identifier;\n    this.addQuads(metadata.quads());\n    return this;\n  }\n\n  /**\n   * @param subject - Subject of quad to add.\n   * @param predicate - Predicate of quad to add.\n   * @param object - Object of quad to add.\n   * @param graph - Optional graph of quad to add.\n   */\n  public addQuad(\n    subject: NamedNode | BlankNode | string,\n    predicate: NamedNode,\n    object: NamedNode | BlankNode | Literal | string,\n    graph?: MetadataGraph,\n  ): this {\n    this.store.addQuad(\n      toNamedTerm(subject),\n      predicate,\n      toObjectTerm(object, true),\n      graph ? toNamedTerm(graph) : undefined,\n    );\n    return this;\n  }\n\n  /**\n   * @param quads - Quads to add to the metadata.\n   */\n  public addQuads(quads: Quad[]): this {\n    this.store.addQuads(quads);\n    return this;\n  }\n\n  /**\n   * @param subject - Subject of quad to remove.\n   * @param predicate - Predicate of quad to remove.\n   * @param object - Object of quad to remove.\n   * @param graph - Optional graph of quad to remove.\n   */\n  public removeQuad(\n    subject: NamedNode | BlankNode | string,\n    predicate: NamedNode,\n    object: NamedNode | BlankNode | Literal | string,\n    graph?: MetadataGraph,\n  ): this {\n    const quads = this.quads(\n      toNamedTerm(subject),\n      predicate,\n      toObjectTerm(object, true),\n      graph ? toNamedTerm(graph) : undefined,\n    );\n    return this.removeQuads(quads);\n  }\n\n  /**\n   * @param quads - Quads to remove from the metadata.\n   */\n  public removeQuads(quads: Quad[]): this {\n    this.store.removeQuads(quads);\n    return this;\n  }\n\n  /**\n   * Adds a value linked to the identifier. Strings get converted to literals.\n   *\n   * @param predicate - Predicate linking identifier to value.\n   * @param object - Value(s) to add.\n   * @param graph - Optional graph of where to add the values to.\n   */\n  public add(predicate: NamedNode, object: MetadataValue, graph?: MetadataGraph): this {\n    return this.forQuads(predicate, object, (pred, obj): unknown => this.addQuad(this.id, pred, obj, graph));\n  }\n\n  /**\n   * Removes the given value from the metadata. Strings get converted to literals.\n   *\n   * @param predicate - Predicate linking identifier to value.\n   * @param object - Value(s) to remove.\n   * @param graph - Optional graph of where to remove the values from.\n   */\n  public remove(predicate: NamedNode, object: MetadataValue, graph?: MetadataGraph): this {\n    return this.forQuads(predicate, object, (pred, obj): unknown => this.removeQuad(this.id, pred, obj, graph));\n  }\n\n  /**\n   * Helper function to simplify add/remove\n   * Runs the given function on all predicate/object pairs, but only converts the predicate to a named node once.\n   */\n  private forQuads(\n    predicate: NamedNode,\n    object: MetadataValue,\n    forFn: (pred: NamedNode, obj: NamedNode | BlankNode | Literal) => void,\n  ): this {\n    const objects = Array.isArray(object) ? object : [ object ];\n    for (const obj of objects) {\n      forFn(predicate, toObjectTerm(obj, true));\n    }\n    return this;\n  }\n\n  /**\n   * Removes all values linked through the given predicate.\n   *\n   * @param predicate - Predicate to remove.\n   * @param graph - Optional graph where to remove from.\n   */\n  public removeAll(predicate: NamedNode, graph?: MetadataGraph): this {\n    this.removeQuads(this.store.getQuads(this.id, predicate, null, graph ?? null));\n    return this;\n  }\n\n  /**\n   * Verifies if a specific triple can be found in the metadata.\n   * Undefined parameters are interpreted as wildcards.\n   */\n  public has(\n    predicate: NamedNode | string | null = null,\n    object: NamedNode | BlankNode | Literal | string | null = null,\n    graph: MetadataGraph | null = null,\n  ): boolean {\n    // This works with N3.js but at the time of writing the typings have not been updated yet.\n    // If you see this line of code check if the typings are already correct and update this if so.\n    return (this.store as unknown as {\n      has: (subject: Term,\n        predicate: Term | string | null,\n        object: Term | string | null,\n        graph: Term | string | null) => boolean;\n    }).has(this.id, predicate, object, graph);\n  }\n\n  /**\n   * Finds all object values matching the given predicate and/or graph.\n   *\n   * @param predicate - Optional predicate to get the values for.\n   * @param graph - Optional graph where to get from.\n   *\n   * @returns An array with all matches.\n   */\n  public getAll(predicate: NamedNode, graph?: MetadataGraph): Term[] {\n    return this.store.getQuads(this.id, predicate, null, graph ?? null)\n      .map((quad): Term => quad.object);\n  }\n\n  /**\n   * @param predicate - Predicate to get the value for.\n   * @param graph - Optional graph where the triple should be found.\n   *\n   * @returns The corresponding value. Undefined if there is no match\n   *\n   * @throws Error\n   * If there are multiple matching values.\n   */\n  public get(predicate: NamedNode, graph?: MetadataGraph): Term | undefined {\n    const terms = this.getAll(predicate, graph);\n    if (terms.length === 0) {\n      return;\n    }\n    if (terms.length > 1) {\n      this.logger.error(`Multiple results for ${predicate.value}`);\n      // We can not use an `InternalServerError` here as otherwise errors and metadata files would depend on each other\n      throw new Error(\n        `Multiple results for ${predicate.value}`,\n      );\n    }\n    return terms[0];\n  }\n\n  /**\n   * Sets the value for the given predicate, removing all other instances.\n   * In case the object is undefined this is identical to `removeAll(predicate)`.\n   *\n   * @param predicate - Predicate linking to the value.\n   * @param object - Value(s) to set.\n   * @param graph - Optional graph where the triple should be stored.\n   */\n  public set(predicate: NamedNode, object?: MetadataValue, graph?: MetadataGraph): this {\n    this.removeAll(predicate, graph);\n    if (object) {\n      this.add(predicate, object, graph);\n    }\n    return this;\n  }\n\n  private setContentType(input?: ContentType | string): void {\n    // Make sure complete Content-Type RDF structure is gone\n    this.removeContentType();\n\n    if (!input) {\n      return;\n    }\n\n    if (typeof input === 'string') {\n      // Simple check to estimate if this is a simple content type.\n      // If not, mention that the `contentTypeObject` should be used instead.\n      // Not calling `parseContentType` here as that would cause a dependency loop with `HttpError`.\n      if (!SIMPLE_MEDIA_RANGE.test(input)) {\n        // Not using an HttpError as HttpError depends on metadata\n        throw new Error(\n          'Only simple content types can be set by string. Use the `contentTypeObject` function for complexer types.',\n        );\n      }\n      input = new ContentType(input);\n    }\n\n    for (const [ key, value ] of Object.entries(input.parameters)) {\n      const node = DataFactory.blankNode();\n      this.addQuad(this.id, SOLID_META.terms.contentTypeParameter, node);\n      this.addQuad(node, RDFS.terms.label, key);\n      this.addQuad(node, SOLID_META.terms.value, value);\n    }\n\n    // Set base content type string\n    this.set(CONTENT_TYPE_TERM, input.value);\n  }\n\n  /**\n   * Parse the internal RDF structure to retrieve the Record with ContentType Parameters.\n   *\n   * @returns A {@link ContentType} object containing the value and optional parameters if there is one.\n   */\n  private getContentType(): ContentType | undefined {\n    const value = this.get(CONTENT_TYPE_TERM)?.value;\n    if (!value) {\n      return;\n    }\n    const params = this.getAll(SOLID_META.terms.contentTypeParameter);\n    const parameters = Object.fromEntries(params.map((param): [string, string] => {\n      const labels = this.store.getObjects(param, RDFS.terms.label, null);\n      const values = this.store.getObjects(param, SOLID_META.terms.value, null);\n      if (labels.length !== 1 || values.length !== 1) {\n        this.logger.error(`Detected invalid content-type metadata for ${this.id.value}`);\n        return [ 'invalid', '' ];\n      }\n      return [ labels[0].value, values[0].value ];\n    }));\n    return new ContentType(value, parameters);\n  }\n\n  private removeContentType(): void {\n    this.removeAll(CONTENT_TYPE_TERM);\n    const params = this.quads(this.id, SOLID_META.terms.contentTypeParameter);\n    for (const quad of params) {\n      const paramEntries = this.quads(quad.object as BlankNode);\n      this.store.removeQuads(paramEntries);\n    }\n    this.store.removeQuads(params);\n  }\n\n  // Syntactic sugar for common predicates\n\n  /**\n   * Shorthand for the CONTENT_TYPE predicate.\n   */\n  public get contentType(): string | undefined {\n    return this.get(CONTENT_TYPE_TERM)?.value;\n  }\n\n  public set contentType(input) {\n    this.setContentType(input);\n  }\n\n  /**\n   * Shorthand for the ContentType as an object (with parameters)\n   */\n  public get contentTypeObject(): ContentType | undefined {\n    return this.getContentType();\n  }\n\n  public set contentTypeObject(contentType) {\n    this.setContentType(contentType);\n  }\n\n  /**\n   * Shorthand for the CONTENT_LENGTH predicate.\n   */\n  public get contentLength(): number | undefined {\n    const length = this.get(CONTENT_LENGTH_TERM);\n    return length?.value ? Number(length.value) : undefined;\n  }\n\n  public set contentLength(input) {\n    if (input) {\n      this.set(CONTENT_LENGTH_TERM, toLiteral(input, XSD.terms.integer));\n    }\n  }\n}\n"]}