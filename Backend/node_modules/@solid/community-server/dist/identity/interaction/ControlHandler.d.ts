import type { Json } from '../../util/Json';
import type { JsonRepresentation } from './InteractionUtil';
import type { JsonInteractionHandlerInput } from './JsonInteractionHandler';
import { JsonInteractionHandler } from './JsonInteractionHandler';
import type { InteractionRoute } from './routing/InteractionRoute';
import Dict = NodeJS.Dict;
/**
 * Creates an object with the keys matching those of the input `controls`,
 * and the values being the results received by the matching values in the same input.
 *
 * If `source` is defined, the controls will be added to the output of that handler after passing the input.
 * In case the control keys conflict with a key already present in the resulting object,
 * the results will be merged.
 */
export declare class ControlHandler extends JsonInteractionHandler {
    private readonly controls;
    private readonly source?;
    constructor(controls: Record<string, InteractionRoute | JsonInteractionHandler>, source?: JsonInteractionHandler);
    canHandle(input: JsonInteractionHandlerInput): Promise<void>;
    handle(input: JsonInteractionHandlerInput): Promise<JsonRepresentation>;
    protected isRoute(value: InteractionRoute | JsonInteractionHandler): value is InteractionRoute;
    /**
     * Generate the controls for all the stored keys.
     */
    protected generateControls(input: JsonInteractionHandlerInput): Promise<Dict<Json>>;
    protected generateControlSet(input: JsonInteractionHandlerInput, value: InteractionRoute | JsonInteractionHandler): Promise<Json | undefined>;
    /**
     * Merge the two objects.
     * Generally this will probably not be necessary, or be very simple merges,
     * but this ensures that we handle all possibilities.
     */
    protected mergeControls(original?: Json, controls?: Json): Json;
}
