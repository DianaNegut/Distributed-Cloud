{"version":3,"file":"ControlHandler.js","sourceRoot":"","sources":["../../../src/identity/interaction/ControlHandler.ts"],"names":[],"mappings":";;;AACA,6DAA0D;AAG1D,qEAAkE;AAIlE;;;;;;;GAOG;AACH,MAAa,cAAe,SAAQ,+CAAsB;IACvC,QAAQ,CAA4D;IACpE,MAAM,CAA0B;IAEjD,YACE,QAAmE,EACnE,MAA+B;QAE/B,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAkC;QACvD,MAAM,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAkC;QACpD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;QAChD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;QAEpD,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAe,CAAC;QAEtE,OAAO;YACL,IAAI;YACJ,QAAQ,EAAE,MAAM,EAAE,QAAQ;SAC3B,CAAC;IACJ,CAAC;IAES,OAAO,CAAC,KAAgD;QAChE,OAAO,OAAO,CAAE,KAA0B,CAAC,OAAO,CAAC,CAAC;IACtD,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,gBAAgB,CAAC,KAAkC;QACjE,IAAI,QAAQ,GAAyB,EAAE,CAAC;QAExC,KAAK,MAAM,CAAE,GAAG,EAAE,KAAK,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC3D,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAC/D,IAAI,UAAU,EAAE,CAAC;gBACf,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,UAAU,EAAE,CAAyB,CAAC;YACzF,CAAC;QACH,CAAC;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAES,KAAK,CAAC,kBAAkB,CAChC,KAAkC,EAClC,KAAgD;QAEhD,IAAI,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;YACxB,IAAI,CAAC;gBACH,OAAO,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,+BAAc,CAAC,EAAE,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC;YAC9D,CAAC;YAAC,MAAM,CAAC;gBACP,+CAA+C;gBAC/C,OAAO;YACT,CAAC;QACH,CAAC;QACD,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAC/C,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC7C,OAAO;QACT,CAAC;QACD,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC/D,OAAO;QACT,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IACO,aAAa,CAAC,QAAe,EAAE,QAAe;QACtD,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;YACpC,OAAO,QAAS,CAAC;QACnB,CAAC;QAED,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;YACpC,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE,CAAC;YACjE,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC5B,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC;gBAC5B,OAAO,CAAE,GAAG,QAAQ,EAAE,GAAG,QAAQ,CAAE,CAAC;YACtC,CAAC;YACD,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC5B,OAAO,QAAQ,CAAC;QAClB,CAAC;QAED,MAAM,MAAM,GAAyB,EAAE,CAAC;QACxC,KAAK,MAAM,GAAG,IAAI,IAAI,GAAG,CAAC,CAAE,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAE,CAAC,EAAE,CAAC;YAClF,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;QACjE,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA1GD,wCA0GC","sourcesContent":["import type { Json } from '../../util/Json';\nimport { ACCOUNT_ID_KEY } from './account/AccountIdRoute';\nimport type { JsonRepresentation } from './InteractionUtil';\nimport type { JsonInteractionHandlerInput } from './JsonInteractionHandler';\nimport { JsonInteractionHandler } from './JsonInteractionHandler';\nimport type { InteractionRoute } from './routing/InteractionRoute';\nimport Dict = NodeJS.Dict;\n\n/**\n * Creates an object with the keys matching those of the input `controls`,\n * and the values being the results received by the matching values in the same input.\n *\n * If `source` is defined, the controls will be added to the output of that handler after passing the input.\n * In case the control keys conflict with a key already present in the resulting object,\n * the results will be merged.\n */\nexport class ControlHandler extends JsonInteractionHandler {\n  private readonly controls: Record<string, InteractionRoute | JsonInteractionHandler>;\n  private readonly source?: JsonInteractionHandler;\n\n  public constructor(\n    controls: Record<string, InteractionRoute | JsonInteractionHandler>,\n    source?: JsonInteractionHandler,\n  ) {\n    super();\n    this.controls = controls;\n    this.source = source;\n  }\n\n  public async canHandle(input: JsonInteractionHandlerInput): Promise<void> {\n    await this.source?.canHandle(input);\n  }\n\n  public async handle(input: JsonInteractionHandlerInput): Promise<JsonRepresentation> {\n    const result = await this.source?.handle(input);\n    const controls = await this.generateControls(input);\n\n    const json = this.mergeControls(result?.json, controls) as Dict<Json>;\n\n    return {\n      json,\n      metadata: result?.metadata,\n    };\n  }\n\n  protected isRoute(value: InteractionRoute | JsonInteractionHandler): value is InteractionRoute {\n    return Boolean((value as InteractionRoute).getPath);\n  }\n\n  /**\n   * Generate the controls for all the stored keys.\n   */\n  protected async generateControls(input: JsonInteractionHandlerInput): Promise<Dict<Json>> {\n    let controls: Record<string, Json> = {};\n\n    for (const [ key, value ] of Object.entries(this.controls)) {\n      const controlSet = await this.generateControlSet(input, value);\n      if (controlSet) {\n        controls = this.mergeControls(controls, { [key]: controlSet }) as Record<string, Json>;\n      }\n    }\n\n    return controls;\n  }\n\n  protected async generateControlSet(\n    input: JsonInteractionHandlerInput,\n    value: InteractionRoute | JsonInteractionHandler,\n  ): Promise<Json | undefined> {\n    if (this.isRoute(value)) {\n      try {\n        return value.getPath({ [ACCOUNT_ID_KEY]: input.accountId });\n      } catch {\n        // Path required an account ID which is missing\n        return;\n      }\n    }\n    const { json } = await value.handleSafe(input);\n    if (Array.isArray(json) && json.length === 0) {\n      return;\n    }\n    if (typeof json === 'object' && Object.keys(json).length === 0) {\n      return;\n    }\n    return json;\n  }\n\n  /**\n   * Merge the two objects.\n   * Generally this will probably not be necessary, or be very simple merges,\n   * but this ensures that we handle all possibilities.\n   */\n  protected mergeControls(original?: Json, controls?: Json): Json {\n    if (typeof original === 'undefined') {\n      return controls!;\n    }\n\n    if (typeof controls === 'undefined') {\n      return original;\n    }\n\n    if (typeof original !== 'object' || typeof controls !== 'object') {\n      return original;\n    }\n\n    if (Array.isArray(original)) {\n      if (Array.isArray(controls)) {\n        return [ ...original, ...controls ];\n      }\n      return original;\n    }\n\n    if (Array.isArray(controls)) {\n      return original;\n    }\n\n    const result: Record<string, Json> = {};\n    for (const key of new Set([ ...Object.keys(original), ...Object.keys(controls) ])) {\n      result[key] = this.mergeControls(original[key], controls[key]);\n    }\n    return result;\n  }\n}\n"]}