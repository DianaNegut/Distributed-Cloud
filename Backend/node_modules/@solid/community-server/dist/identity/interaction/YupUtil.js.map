{"version":3,"file":"YupUtil.js","sourceRoot":"","sources":["../../../src/identity/interaction/YupUtil.ts"],"names":[],"mappings":";;;AAsDA,kCAGC;AAKD,8CAUC;AAxED,6BAA6B;AAE7B,+EAA4E;AAC5E,2DAAiE;AAEjE,sDAA8C;AAK9C,wGAAwG;AACxG,kEAAkE;AAClE,4EAA4E;AAC/D,QAAA,UAAU,GAAG,IAAA,YAAM,GAAE,CAAC,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC;IACxD,IAAI,EAAE,KAAK;IACX,OAAO,EAAE,CAAC,KAAwB,EAAU,EAAE,CAAC,IAAI,KAAK,CAAC,KAAK,sBAAsB;IACpF,IAAI,CAAC,KAAK;QACR,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO,IAAI,CAAC;QACd,CAAC;QACD,OAAO,IAAA,kBAAK,EAAC,KAAK,CAAC,CAAC;IACtB,CAAC;CACF,CAAC,CAAC;AAEH,SAAS,cAAc,CAAC,MAAc;IACpC,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,CAAC;AAClC,CAAC;AAUD;;GAEG;AACH,SAAS,sBAAsB,CAAmB,MAAS;IACzD,MAAM,MAAM,GAAe,EAAE,QAAQ,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,EAAE,CAAC;IAClF,IAAI,cAAc,CAAC,MAAM,CAAC,EAAE,CAAC;QAC3B,MAAM,CAAC,MAAM,GAAG,EAAE,CAAC;QACnB,KAAK,MAAM,CAAE,KAAK,EAAE,WAAW,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC;YACnE,+CAA+C;YAC/C,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,sBAAsB,CAAC,WAAqB,CAAC,CAAC;QACvE,CAAC;IACH,CAAC;IACD,OAAO,MAAuB,CAAC;AACjC,CAAC;AAED;;GAEG;AACH,SAAgB,WAAW,CAA6B,MAAS;IAC/D,MAAM,MAAM,GAAG,sBAAsB,CAAC,MAAM,CAAC,CAAC;IAC9C,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;AACnC,CAAC;AAED;;GAEG;AACI,KAAK,UAAU,iBAAiB,CACrC,MAAS,EACT,IAAa,EACb,OAAoC;IAEpC,IAAI,CAAC;QACH,OAAO,MAAM,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC9C,CAAC;IAAC,OAAO,KAAc,EAAE,CAAC;QACxB,MAAM,IAAI,yCAAmB,CAAC,IAAA,8BAAkB,EAAC,KAAK,CAAC,CAAC,CAAC;IAC3D,CAAC;AACH,CAAC","sourcesContent":["import { string } from 'yup';\nimport type { AnyObject, Maybe, ObjectSchema, Schema, ValidateOptions } from 'yup';\nimport { BadRequestHttpError } from '../../util/errors/BadRequestHttpError';\nimport { createErrorMessage } from '../../util/errors/ErrorUtil';\nimport type { Json } from '../../util/Json';\nimport { isUrl } from '../../util/StringUtil';\nimport Dict = NodeJS.Dict;\n\ntype BaseObjectSchema = ObjectSchema<Maybe<AnyObject>>;\n\n// The builtin `url` validator of `yup` does not support localhost URLs, so we create a custom one here.\n// We validate the WebID URL to prevent generation of invalid ACL,\n// which would break the pod creation, causing us to have an incomplete pod.\nexport const URL_SCHEMA = string().trim().optional().test({\n  name: 'url',\n  message: (value: { value: string }): string => `\"${value.value}\" is not a valid URL`,\n  test(value): boolean {\n    if (!value) {\n      return true;\n    }\n    return isUrl(value);\n  },\n});\n\nfunction isObjectSchema(schema: Schema): schema is BaseObjectSchema {\n  return schema.type === 'object';\n}\n\n// `T` can't extend Schema since it could also be a Reference, which is a type `yup` doesn't export\ntype SchemaType<T> = T extends BaseObjectSchema ? ObjectType<T> : { required: boolean; type: string };\n// The type of the fields in an object schema\ntype FieldType<T extends BaseObjectSchema> = T extends { fields: Record<infer R, unknown> } ? R : never;\n// Simplified type we use to represent yup objects\ntype ObjectType<T extends BaseObjectSchema> =\n  { required: boolean; type: 'object'; fields: {[ K in FieldType<T> ]: SchemaType<T['fields'][K]> }};\n\n/**\n * Recursive function used when generating yup schema representations.\n */\nfunction parseSchemaDescription<T extends Schema>(schema: T): SchemaType<T> {\n  const result: Dict<Json> = { required: !schema.spec.optional, type: schema.type };\n  if (isObjectSchema(schema)) {\n    result.fields = {};\n    for (const [ field, description ] of Object.entries(schema.fields)) {\n      // We never use references so this cast is fine\n      result.fields[field] = parseSchemaDescription(description as Schema);\n    }\n  }\n  return result as SchemaType<T>;\n}\n\n/**\n * Generates a simplified representation of a yup schema.\n */\nexport function parseSchema<T extends BaseObjectSchema>(schema: T): Pick<SchemaType<T>, 'fields'> {\n  const result = parseSchemaDescription(schema);\n  return { fields: result.fields };\n}\n\n/**\n * Same functionality as the yup validate function, but throws a {@link BadRequestHttpError} if there is an error.\n */\nexport async function validateWithError<T extends BaseObjectSchema>(\n  schema: T,\n  data: unknown,\n  options?: ValidateOptions<AnyObject>,\n): Promise<T['__outputType']> {\n  try {\n    return await schema.validate(data, options);\n  } catch (error: unknown) {\n    throw new BadRequestHttpError(createErrorMessage(error));\n  }\n}\n"]}