import type { CreateTypeObject, IndexedQuery, IndexedStorage, IndexTypeCollection, StringKey, TypeObject, ValueType } from '../../../../storage/keyvalue/IndexedStorage';
import type { LoginStorage } from './LoginStorage';
/**
 * A {@link LoginStorage} that wraps around another {@link IndexedStorage} to add specific account requirements.
 *   * New accounts will be removed after expiration time, in seconds, default is 1800,
 *     if no login method was added to them in that time.
 *   * Non-login types can not be created until the associated account has at least 1 login method.
 *   * Login types can not be deleted if they are the last login of the associated account.
 *
 * All of this is tracked by adding a new field to the account object,
 * that keeps track of how many login objects are associated with the account.
 */
export declare class BaseLoginAccountStorage<T extends IndexTypeCollection<T>> implements LoginStorage<T> {
    private readonly logger;
    protected readonly loginTypes: string[];
    protected readonly storage: IndexedStorage<T>;
    private readonly expiration;
    protected readonly accountKeys: NodeJS.Dict<string>;
    constructor(storage: IndexedStorage<T>, expiration?: number);
    defineType<TType extends StringKey<T>>(type: TType, description: T[TType], isLogin: boolean): Promise<void>;
    createIndex<TType extends StringKey<T>>(type: TType, key: StringKey<T[TType]>): Promise<void>;
    create<TType extends StringKey<T>>(type: TType, value: CreateTypeObject<T[TType]>): Promise<TypeObject<T[TType]>>;
    has<TType extends StringKey<T>>(type: TType, id: string): Promise<boolean>;
    get<TType extends StringKey<T>>(type: TType, id: string): Promise<TypeObject<T[TType]> | undefined>;
    find<TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>): Promise<TypeObject<T[TType]>[]>;
    findIds<TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>): Promise<string[]>;
    set<TType extends StringKey<T>>(type: TType, value: TypeObject<T[TType]>): Promise<void>;
    setField<TType extends StringKey<T>, TKey extends StringKey<T[TType]>>(type: TType, id: string, key: TKey, value: ValueType<T[TType][TKey]>): Promise<void>;
    delete<TType extends StringKey<T>>(type: TType, id: string): Promise<void>;
    entries<TType extends StringKey<T>>(type: TType): AsyncIterableIterator<TypeObject<T[TType]>>;
    /**
     * Creates a timer that removes the account with the given ID if
     * it doesn't have a login method when the timer runs out.
     */
    protected createAccountTimeout(id: string): void;
    /**
     * Makes sure of the operation, adding or removing an object of the given type,
     * is allowed, based on the current amount of login methods on the given account.
     */
    protected checkAccount(type: string, accountId: string, add: boolean): Promise<void>;
    /**
     * Removes the field that keeps track of the login counts, to hide this from the output.
     */
    protected cleanOutput<TVal extends Record<string, unknown> | undefined>(this: void, value: TVal): TVal;
}
