{"version":3,"file":"BaseLoginAccountStorage.js","sourceRoot":"","sources":["../../../../../src/identity/interaction/account/util/BaseLoginAccountStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { getLoggerFor } from '../../../../logging/LogUtil';\nimport type {\n  CreateTypeObject,\n  IndexedQuery,\n  IndexedStorage,\n  IndexTypeCollection,\n  StringKey,\n  TypeObject,\n  ValueType,\n} from '../../../../storage/keyvalue/IndexedStorage';\nimport { BadRequestHttpError } from '../../../../util/errors/BadRequestHttpError';\nimport { NotFoundHttpError } from '../../../../util/errors/NotFoundHttpError';\nimport type { LoginStorage } from './LoginStorage';\nimport { ACCOUNT_TYPE } from './LoginStorage';\n\nconst LOGIN_COUNT = 'linkedLoginsCount';\n\nconst MINIMUM_ACCOUNT_DESCRIPTION = {\n  [LOGIN_COUNT]: 'number',\n} as const;\n\n/**\n * A {@link LoginStorage} that wraps around another {@link IndexedStorage} to add specific account requirements.\n *   * New accounts will be removed after expiration time, in seconds, default is 1800,\n *     if no login method was added to them in that time.\n *   * Non-login types can not be created until the associated account has at least 1 login method.\n *   * Login types can not be deleted if they are the last login of the associated account.\n *\n * All of this is tracked by adding a new field to the account object,\n * that keeps track of how many login objects are associated with the account.\n */\nexport class BaseLoginAccountStorage<T extends IndexTypeCollection<T>> implements LoginStorage<T> {\n  private readonly logger = getLoggerFor(this);\n\n  protected readonly loginTypes: string[];\n  protected readonly storage: IndexedStorage<T>;\n  private readonly expiration: number;\n  protected readonly accountKeys: NodeJS.Dict<string>;\n\n  public constructor(storage: IndexedStorage<T>, expiration = 30 * 60) {\n    this.loginTypes = [];\n    this.storage = storage;\n    this.expiration = expiration * 1000;\n    this.accountKeys = {};\n  }\n\n  public async defineType<TType extends StringKey<T>>(type: TType, description: T[TType], isLogin: boolean):\n  Promise<void> {\n    // Determine potential new key pointing to account ID\n    this.accountKeys[type] = Object.entries(description)\n      .find(([ , desc ]): boolean => desc === `id:${ACCOUNT_TYPE}` as `id:${string & keyof T}`)?.[0];\n\n    if (type === ACCOUNT_TYPE) {\n      description = { ...description, ...MINIMUM_ACCOUNT_DESCRIPTION };\n    }\n\n    if (isLogin) {\n      this.loginTypes.push(type);\n    }\n\n    return this.storage.defineType(type, description);\n  }\n\n  public async createIndex<TType extends StringKey<T>>(type: TType, key: StringKey<T[TType]>): Promise<void> {\n    return this.storage.createIndex(type, key);\n  }\n\n  public async create<TType extends StringKey<T>>(type: TType, value: CreateTypeObject<T[TType]>):\n  Promise<TypeObject<T[TType]>> {\n    // Check login count if it is not a new login method that we are trying to add,\n    // to make sure the account is already valid.\n    // If we are adding a new login method: increase the login counter by 1.\n    const accountKey = this.accountKeys[type];\n    if (accountKey) {\n      const accountId = value[accountKey] as string;\n      await this.checkAccount(type, accountId, true);\n    }\n\n    if (type === ACCOUNT_TYPE) {\n      value = { ...value, [LOGIN_COUNT]: 0 };\n    }\n\n    const result = await this.storage.create(type, value);\n\n    if (type === ACCOUNT_TYPE) {\n      this.createAccountTimeout(result.id);\n    }\n\n    return this.cleanOutput(result);\n  }\n\n  public async has<TType extends StringKey<T>>(type: TType, id: string): Promise<boolean> {\n    return this.storage.has(type, id);\n  }\n\n  public async get<TType extends StringKey<T>>(type: TType, id: string): Promise<TypeObject<T[TType]> | undefined> {\n    return this.cleanOutput(await this.storage.get(type, id));\n  }\n\n  public async find<TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>):\n  Promise<TypeObject<T[TType]>[]> {\n    return (await this.storage.find(type, query)).map(this.cleanOutput);\n  }\n\n  public async findIds<TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>): Promise<string[]> {\n    return this.storage.findIds(type, query);\n  }\n\n  public async set<TType extends StringKey<T>>(type: TType, value: TypeObject<T[TType]>): Promise<void> {\n    if (type === ACCOUNT_TYPE) {\n      // Get login count from original object\n      const original = await this.storage.get(type, value.id);\n      if (!original) {\n        throw new NotFoundHttpError();\n      }\n      // This makes sure we don't lose the login count\n      value = { ...value, [LOGIN_COUNT]: original[LOGIN_COUNT] };\n    }\n\n    return this.storage.set(type, value);\n  }\n\n  public async setField<TType extends StringKey<T>, TKey extends StringKey<T[TType]>>(\n    type: TType,\n    id: string,\n    key: TKey,\n    value: ValueType<T[TType][TKey]>,\n  ): Promise<void> {\n    return this.storage.setField(type, id, key, value);\n  }\n\n  public async delete<TType extends StringKey<T>>(type: TType, id: string): Promise<void> {\n    const accountKey = this.accountKeys[type];\n    if (accountKey && this.loginTypes.includes(type)) {\n      const original = await this.storage.get(type, id);\n      if (!original) {\n        throw new NotFoundHttpError();\n      }\n      const accountId = original[accountKey] as string;\n      await this.checkAccount(type, accountId, false);\n    }\n    return this.storage.delete(type, id);\n  }\n\n  public async* entries<TType extends StringKey<T>>(type: TType): AsyncIterableIterator<TypeObject<T[TType]>> {\n    for await (const entry of this.storage.entries(type)) {\n      yield this.cleanOutput(entry);\n    }\n  }\n\n  /**\n   * Creates a timer that removes the account with the given ID if\n   * it doesn't have a login method when the timer runs out.\n   */\n  protected createAccountTimeout(id: string): void {\n    // eslint-disable-next-line ts/no-misused-promises\n    const timer = setTimeout(async(): Promise<void> => {\n      const account = await this.storage.get(ACCOUNT_TYPE, id);\n      if (account && account[LOGIN_COUNT] === 0) {\n        this.logger.debug(`Removing account with no login methods ${id}`);\n        await this.storage.delete(ACCOUNT_TYPE, id);\n      }\n    }, this.expiration);\n    timer.unref();\n  }\n\n  /**\n   * Makes sure of the operation, adding or removing an object of the given type,\n   * is allowed, based on the current amount of login methods on the given account.\n   */\n  protected async checkAccount(type: string, accountId: string, add: boolean): Promise<void> {\n    const account = await this.storage.get(ACCOUNT_TYPE, accountId);\n    if (!account) {\n      throw new NotFoundHttpError();\n    }\n\n    if (this.loginTypes.includes(type)) {\n      if (!add && account[LOGIN_COUNT] === 1) {\n        this.logger.warn(`Trying to remove last login method from account ${accountId}`);\n        throw new BadRequestHttpError('An account needs at least 1 login method.');\n      }\n      (account as TypeObject<typeof MINIMUM_ACCOUNT_DESCRIPTION>)[LOGIN_COUNT] += add ? 1 : -1;\n      await this.storage.set(ACCOUNT_TYPE, account);\n    } else if (account[LOGIN_COUNT] === 0) {\n      this.logger.warn(`Trying to update account ${accountId} without login methods`);\n      throw new BadRequestHttpError('An account needs at least 1 login method.');\n    }\n  }\n\n  /**\n   * Removes the field that keeps track of the login counts, to hide this from the output.\n   */\n  protected cleanOutput<TVal extends Record<string, unknown> | undefined>(this: void, value: TVal): TVal {\n    if (value) {\n      delete value[LOGIN_COUNT];\n    }\n    return value;\n  }\n}\n"]}