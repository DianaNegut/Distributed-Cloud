{"version":3,"file":"PickWebIdHandler.js","sourceRoot":"","sources":["../../../../src/identity/interaction/oidc/PickWebIdHandler.ts"],"names":[],"mappings":";;;AAAA,6BAA8C;AAE9C,sDAAwD;AACxD,kFAA+E;AAC/E,wEAAqE;AAErE,6DAA8D;AAE9D,wDAA2F;AAE3F,sEAAmE;AAGnE,wCAA4D;AAE5D,MAAM,QAAQ,GAAG,IAAA,YAAM,EAAC;IACtB,KAAK,EAAE,IAAA,YAAM,GAAE,CAAC,IAAI,EAAE,CAAC,QAAQ,EAAE;IACjC,QAAQ,EAAE,IAAA,aAAO,GAAE,CAAC,OAAO,CAAC,KAAK,CAAC;CACnC,CAAC,CAAC;AAEH;;;;;;;;;GASG;AACH,MAAa,gBAAiB,SAAQ,+CAA6B;IAChD,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE5B,UAAU,CAAa;IACvB,eAAe,CAAkB;IAElD,YAAmB,UAAsB,EAAE,eAAgC;QACzE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;IACzC,CAAC;IAEM,KAAK,CAAC,OAAO,CAAC,EAAE,SAAS,EAA+B;QAC7D,IAAA,6BAAe,EAAC,SAAS,CAAC,CAAC;QAC3B,MAAM,WAAW,GAAG,IAAA,qBAAW,EAAC,QAAQ,CAAC,CAAC;QAC1C,MAAM,MAAM,GAAG,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAU,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC9F,OAAO,EAAE,IAAI,EAAE,EAAE,GAAG,WAAW,EAAE,MAAM,EAAE,EAAC,CAAC;IAC7C,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,eAAe,EAAE,SAAS,EAAE,IAAI,EAA+B;QACnF,IAAA,uCAAqB,EAAC,eAAe,CAAC,CAAC;QACvC,IAAA,6BAAe,EAAC,SAAS,CAAC,CAAC;QAE3B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAA,2BAAiB,EAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QACpE,IAAI,CAAC,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE,CAAC;YACtD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,wBAAwB,KAAK,qCAAqC,SAAS,EAAE,CAAC,CAAC;YAChG,MAAM,IAAI,yCAAmB,CAAC,wCAAwC,CAAC,CAAC;QAC1E,CAAC;QAED,4GAA4G;QAC5G,MAAM,IAAA,6BAAW,EAAC,MAAM,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,EAAE,eAAe,CAAC,CAAC;QAE7E,iDAAiD;QACjD,MAAM,KAAK,GAAgC;YACzC,+FAA+F;YAC/F,SAAS,EAAE,KAAK;YAChB,QAAQ;SACT,CAAC;QAEF,MAAM,QAAQ,GAAG,MAAM,IAAA,mCAAiB,EAAC,eAAe,EAAE,EAAE,KAAK,EAAE,EAAE,IAAI,CAAC,CAAC;QAC3E,MAAM,IAAI,+BAAc,CAAC,QAAQ,CAAC,CAAC;IACrC,CAAC;CACF;AA1CD,4CA0CC","sourcesContent":["import { boolean, object, string } from 'yup';\nimport type { InteractionResults } from '../../../../templates/types/oidc-provider';\nimport { getLoggerFor } from '../../../logging/LogUtil';\nimport { BadRequestHttpError } from '../../../util/errors/BadRequestHttpError';\nimport { FoundHttpError } from '../../../util/errors/FoundHttpError';\nimport type { ProviderFactory } from '../../configuration/ProviderFactory';\nimport { assertAccountId } from '../account/util/AccountUtil';\nimport type { JsonRepresentation } from '../InteractionUtil';\nimport { assertOidcInteraction, finishInteraction, forgetWebId } from '../InteractionUtil';\nimport type { JsonInteractionHandlerInput } from '../JsonInteractionHandler';\nimport { JsonInteractionHandler } from '../JsonInteractionHandler';\nimport type { JsonView } from '../JsonView';\nimport type { WebIdStore } from '../webid/util/WebIdStore';\nimport { parseSchema, validateWithError } from '../YupUtil';\n\nconst inSchema = object({\n  webId: string().trim().required(),\n  remember: boolean().default(false),\n});\n\n/**\n * Allows users to choose which WebID they want to authenticate as during an OIDC interaction.\n *\n * One of the main reason picking a WebID is a separate class/request from consenting to the OIDC interaction,\n * is because the OIDC-provider will only give the information we need for consent\n * once we have added an accountId to the OIDC interaction, which we do in this class.\n * The library also really wants to use that accountId as the value that you use for generating the tokens,\n * meaning we can't just use another value there, so we need to assign the WebID to it,\n * unless we use a hacky workaround.\n */\nexport class PickWebIdHandler extends JsonInteractionHandler<never> implements JsonView {\n  private readonly logger = getLoggerFor(this);\n\n  private readonly webIdStore: WebIdStore;\n  private readonly providerFactory: ProviderFactory;\n\n  public constructor(webIdStore: WebIdStore, providerFactory: ProviderFactory) {\n    super();\n    this.webIdStore = webIdStore;\n    this.providerFactory = providerFactory;\n  }\n\n  public async getView({ accountId }: JsonInteractionHandlerInput): Promise<JsonRepresentation> {\n    assertAccountId(accountId);\n    const description = parseSchema(inSchema);\n    const webIds = (await this.webIdStore.findLinks(accountId)).map((link): string => link.webId);\n    return { json: { ...description, webIds }};\n  }\n\n  public async handle({ oidcInteraction, accountId, json }: JsonInteractionHandlerInput): Promise<never> {\n    assertOidcInteraction(oidcInteraction);\n    assertAccountId(accountId);\n\n    const { webId, remember } = await validateWithError(inSchema, json);\n    if (!await this.webIdStore.isLinked(webId, accountId)) {\n      this.logger.warn(`Trying to pick WebID ${webId} which does not belong to account ${accountId}`);\n      throw new BadRequestHttpError('WebID does not belong to this account.');\n    }\n\n    // We need to explicitly forget the WebID from the session or the library won't allow us to update the value\n    await forgetWebId(await this.providerFactory.getProvider(), oidcInteraction);\n\n    // Update the interaction to get the redirect URL\n    const login: InteractionResults['login'] = {\n      // Note that `accountId` here is unrelated to our user accounts but is part of the OIDC library\n      accountId: webId,\n      remember,\n    };\n\n    const location = await finishInteraction(oidcInteraction, { login }, true);\n    throw new FoundHttpError(location);\n  }\n}\n"]}