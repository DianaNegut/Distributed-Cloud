{"version":3,"file":"OwnerMetadataWriter.js","sourceRoot":"","sources":["../../../../../src/identity/interaction/pod/util/OwnerMetadataWriter.ts"],"names":[],"mappings":";;;AAAA,2BAA0B;AAE1B,oFAAiF;AAEjF,yDAA2D;AAE3D,iEAAuE;AACvE,4DAAwD;AAExD,IAAO,WAAW,GAAG,SAAI,CAAC,WAAW,CAAC;AAEtC;;;;;;;;GAQG;AACH,MAAa,mBAAoB,SAAQ,+BAAc;IAC3C,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE5B,QAAQ,CAAW;IACnB,eAAe,CAA0B;IAEnD,YAAmB,QAAkB,EAAE,eAAwC;QAC7E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;IACzC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAuB;QAC7D,kGAAkG;QAClG,kEAAkE;QAClE,IAAI,WAAW,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;YACrC,8BAA8B;YAC9B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,qEAAqE,CAAC,CAAC;YACzF,OAAO;QACT,CAAC;QACD,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;QAEvD,IAAI,iBAAqC,CAAC;QAC1C,IAAI,CAAC;YACH,iBAAiB,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;QAClF,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,CAAC,MAAM;iBACR,KAAK,CAAC,wEAAwE,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAC9G,OAAO;QACT,CAAC;QAED,sEAAsE;QACtE,IAAI,UAAU,CAAC,IAAI,KAAK,iBAAiB,CAAC,IAAI,EAAE,CAAC;YAC/C,OAAO;QACT,CAAC;QAED,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC/D,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,oCAAoC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YACzE,OAAO;QACT,CAAC;QAED,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACrD,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,iCAAiC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YACtE,OAAO;QACT,CAAC;QAED,KAAK,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI,MAAM,EAAE,CAAC;YACxC,IAAI,OAAO,EAAE,CAAC;gBACZ,IAAA,sBAAS,EAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,KAAK,iDAAiD,CAAC,CAAC;YAC1F,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAtDD,kDAsDC","sourcesContent":["import { Util } from 'n3';\nimport type { MetadataWriterInput } from '../../../../http/output/metadata/MetadataWriter';\nimport { MetadataWriter } from '../../../../http/output/metadata/MetadataWriter';\nimport type { ResourceIdentifier } from '../../../../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../../../../logging/LogUtil';\nimport type { StorageLocationStrategy } from '../../../../server/description/StorageLocationStrategy';\nimport { createErrorMessage } from '../../../../util/errors/ErrorUtil';\nimport { addHeader } from '../../../../util/HeaderUtil';\nimport type { PodStore } from './PodStore';\nimport isBlankNode = Util.isBlankNode;\n\n/**\n * Adds link headers indicating who the owners are when accessing the base URL of a pod.\n * Only owners that have decided to be visible will be shown.\n *\n * Solid, ยง4.1: \"When a server wants to advertise the owner of a storage,\n * the server MUST include the Link header with rel=\"http://www.w3.org/ns/solid/terms#owner\"\n * targeting the URI of the owner in the response of HTTP HEAD or GET requests targeting the root container.\"\n * https://solidproject.org/TR/2022/protocol-20221231#server-storage-link-owner\n */\nexport class OwnerMetadataWriter extends MetadataWriter {\n  protected logger = getLoggerFor(this);\n\n  protected podStore: PodStore;\n  protected storageStrategy: StorageLocationStrategy;\n\n  public constructor(podStore: PodStore, storageStrategy: StorageLocationStrategy) {\n    super();\n    this.podStore = podStore;\n    this.storageStrategy = storageStrategy;\n  }\n\n  public async handle({ metadata, response }: MetadataWriterInput): Promise<void> {\n    // Doing all checks here instead of in `canHandle` as this is currently used in a ParallelHandler,\n    // which doesn't correctly check the canHandle/handle combination.\n    if (isBlankNode(metadata.identifier)) {\n      // Blank nodes indicate errors\n      this.logger.debug('Skipping owner link headers as metadata identifier is a blank node.');\n      return;\n    }\n    const identifier = { path: metadata.identifier.value };\n\n    let storageIdentifier: ResourceIdentifier;\n    try {\n      storageIdentifier = await this.storageStrategy.getStorageIdentifier(identifier);\n    } catch (error: unknown) {\n      this.logger\n        .debug(`Skipping owner link headers as no storage identifier could be found: ${createErrorMessage(error)}`);\n      return;\n    }\n\n    // Only need to expose headers when requesting the base URl of the pod\n    if (identifier.path !== storageIdentifier.path) {\n      return;\n    }\n\n    const pod = await this.podStore.findByBaseUrl(identifier.path);\n    if (!pod) {\n      this.logger.debug(`No pod object found for base URL ${identifier.path}`);\n      return;\n    }\n\n    const owners = await this.podStore.getOwners(pod.id);\n    if (!owners) {\n      this.logger.error(`Unable to find owners for pod ${identifier.path}`);\n      return;\n    }\n\n    for (const { webId, visible } of owners) {\n      if (visible) {\n        addHeader(response, 'Link', `<${webId}>; rel=\"http://www.w3.org/ns/solid/terms#owner\"`);\n      }\n    }\n  }\n}\n"]}