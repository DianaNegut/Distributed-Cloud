{"version":3,"file":"InteractionRoute.js","sourceRoot":"","sources":["../../../../src/identity/interaction/routing/InteractionRoute.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * The parameters supported for the given route.\n */\nexport type RouteParameter<TRoute extends InteractionRoute<string>> =\n  TRoute extends InteractionRoute<infer TParam> ? TParam : never;\n\n/**\n * A route that adds a parameter to an existing route type.\n */\nexport type ExtendedRoute<TRoute extends InteractionRoute<string>, TParam extends string> =\n  InteractionRoute<RouteParameter<TRoute> | TParam>;\n\n/**\n * Routes are used to handle the pathing for API calls.\n *\n * They can have dynamic values in the paths they support.\n * Typings are used to indicate the keys used to indicate what the corresponding values are.\n */\nexport interface InteractionRoute<T extends string = never> {\n  /**\n   * Returns the path that is the result of having the specified values for the dynamic parameters.\n   *\n   * Will throw an error in case the input `parameters` object is missing one of the expected keys.\n   *\n   * @param parameters - Values for the dynamic parameters.\n   */\n  getPath: (parameters?: Record<T, string>) => string;\n\n  /**\n   * Checks if the provided path matches the route (pattern).\n   *\n   * The result will be `undefined` if there is no match.\n   *\n   * If there is a match the result object will have the corresponding values for all the parameters.\n   *\n   * @param path - The path to verify.\n   */\n  matchPath: (path: string) => Record<T, string> | undefined;\n}\n"]}