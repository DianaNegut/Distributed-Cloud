{"version":3,"file":"SingleContainerJsonStorage.js","sourceRoot":"","sources":["../../../src/init/migration/SingleContainerJsonStorage.ts"],"names":[],"mappings":";;;AACA,oFAAiF;AACjF,2DAAiE;AACjE,kDAA4D;AAC5D,sDAAyD;AACzD,0DAA8C;AAE9C;;;;;;;GAOG;AACH,MAAa,0BAA8B,SAAQ,yCAAsB;IAC7D,KAAK,CAAA,CAAE,kBAAkB,CAAC,WAA+B;QACjE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAC5D,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,OAAO;QACT,CAAC;QAED,yBAAyB;QACzB,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;QACzB,MAAM,OAAO,GAAG,SAAS,CAAC,QAAQ,CAAC,MAAM,CAAC,kBAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAU,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEhG,KAAK,MAAM,IAAI,IAAI,OAAO,EAAE,CAAC;YAC3B,MAAM,UAAU,GAAG,EAAE,IAAI,EAAE,CAAC;YAC5B,IAAI,IAAA,gCAAqB,EAAC,UAAU,CAAC,EAAE,CAAC;gBACtC,SAAS;YACX,CAAC;YAED,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;YAC1D,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACd,SAAS;YACX,CAAC;YAED,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;YAC7C,IAAI,CAAC;gBACH,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,IAAA,6BAAgB,EAAC,QAAQ,CAAC,IAAI,CAAC,CAAM,CAAC;gBACpE,MAAM,CAAE,GAAG,EAAE,IAAI,CAAE,CAAC;YACtB,CAAC;YAAC,OAAO,KAAc,EAAE,CAAC;gBACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,mBAAmB,IAAI,+DACvC,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAhCD,gEAgCC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { JsonResourceStorage } from '../../storage/keyvalue/JsonResourceStorage';\nimport { createErrorMessage } from '../../util/errors/ErrorUtil';\nimport { isContainerIdentifier } from '../../util/PathUtil';\nimport { readableToString } from '../../util/StreamUtil';\nimport { LDP } from '../../util/Vocabularies';\n\n/**\n * A variant of a {@link JsonResourceStorage} where the `entries()` call\n * does not recursively iterate through all containers.\n * Only the documents that are found in the root container are returned.\n *\n * This class was created to support migration where different storages are nested in one main `.internal` container,\n * and we specifically want to only return entries of one storage.\n */\nexport class SingleContainerJsonStorage<T> extends JsonResourceStorage<T> {\n  protected async* getResourceEntries(containerId: ResourceIdentifier): AsyncIterableIterator<[string, T]> {\n    const container = await this.safelyGetResource(containerId);\n    if (!container) {\n      return;\n    }\n\n    // Only need the metadata\n    container.data.destroy();\n    const members = container.metadata.getAll(LDP.terms.contains).map((term): string => term.value);\n\n    for (const path of members) {\n      const documentId = { path };\n      if (isContainerIdentifier(documentId)) {\n        continue;\n      }\n\n      const document = await this.safelyGetResource(documentId);\n      if (!document) {\n        continue;\n      }\n\n      const key = this.identifierToKey(documentId);\n      try {\n        const json = JSON.parse(await readableToString(document.data)) as T;\n        yield [ key, json ];\n      } catch (error: unknown) {\n        this.logger.error(`Unable to parse ${path}. You should probably delete this resource manually. Error: ${\n          createErrorMessage(error)}`);\n      }\n    }\n  }\n}\n"]}