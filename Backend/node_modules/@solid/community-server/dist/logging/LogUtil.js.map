{"version":3,"file":"LogUtil.js","sourceRoot":"","sources":["../../src/logging/LogUtil.ts"],"names":[],"mappings":";;AAuBA,oCAgBC;AAQD,wDAEC;AAMD,gEAGC;AA1DD,2DAAwD;AAIxD,IAAI,oBAAoB,GAAG,IAAI,qCAAiB,EAAE,CAAC;AACnD,IAAI,YAAY,GAAG,IAAI,OAAO,EAAuB,CAAC;AAEtD;;;;;;;;;;;;;;;GAeG;AACH,SAAgB,YAAY,CAAC,QAA2B;IACtD,IAAI,MAAc,CAAC;IACnB,oCAAoC;IACpC,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE,CAAC;QACjC,MAAM,GAAG,oBAAoB,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACvD,gDAAgD;IAChD,CAAC;SAAM,CAAC;QACN,MAAM,EAAE,WAAW,EAAE,GAAG,QAAQ,CAAC;QACjC,IAAI,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC;YAClC,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,WAAW,CAAE,CAAC;QAC1C,CAAC;aAAM,CAAC;YACN,MAAM,GAAG,oBAAoB,CAAC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YAC7D,YAAY,CAAC,GAAG,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;QACxC,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;;GAKG;AACH,SAAgB,sBAAsB,CAAC,aAA4B;IACjE,oBAAoB,CAAC,aAAa,GAAG,aAAa,CAAC;AACrD,CAAC;AAED;;;GAGG;AACH,SAAgB,0BAA0B,CAAC,OAAO,GAAG,IAAI,qCAAiB,EAAE;IAC1E,oBAAoB,GAAG,OAAO,CAAC;IAC/B,YAAY,GAAG,IAAI,OAAO,EAAE,CAAC;AAC/B,CAAC","sourcesContent":["import { LazyLoggerFactory } from './LazyLoggerFactory';\nimport type { Logger } from './Logger';\nimport type { LoggerFactory } from './LoggerFactory';\n\nlet loggerFactoryWrapper = new LazyLoggerFactory();\nlet classLoggers = new WeakMap<Constructor, Logger>();\n\n/**\n * Gets a logger instance for the given class instance.\n *\n * The following shows a typical pattern on how to create loggers:\n * ```\n * class MyClass {\n *   protected readonly logger = getLoggerFor(this);\n * }\n * ```\n * If no class is applicable, a logger can also be created as follows:\n * ```\n * const logger = getLoggerFor('MyFunction');\n * ```\n *\n * @param loggable - A class instance or a class string name.\n */\nexport function getLoggerFor(loggable: string | Instance): Logger {\n  let logger: Logger;\n  // Create a logger with a text label\n  if (typeof loggable === 'string') {\n    logger = loggerFactoryWrapper.createLogger(loggable);\n  // Create or reuse a logger for a specific class\n  } else {\n    const { constructor } = loggable;\n    if (classLoggers.has(constructor)) {\n      logger = classLoggers.get(constructor)!;\n    } else {\n      logger = loggerFactoryWrapper.createLogger(constructor.name);\n      classLoggers.set(constructor, logger);\n    }\n  }\n  return logger;\n}\n\n/**\n * Sets the global logger factory.\n * This causes loggers created by {@link getLoggerFor} to delegate to a logger from the given factory.\n *\n * @param loggerFactory - A logger factory.\n */\nexport function setGlobalLoggerFactory(loggerFactory: LoggerFactory): void {\n  loggerFactoryWrapper.loggerFactory = loggerFactory;\n}\n\n/**\n * Resets the internal logger factory, which holds the global logger factory.\n * For testing purposes only.\n */\nexport function resetInternalLoggerFactory(factory = new LazyLoggerFactory()): void {\n  loggerFactoryWrapper = factory;\n  classLoggers = new WeakMap();\n}\n\n/**\n * Any class constructor.\n */\ninterface Constructor {\n  name: string;\n}\n\n/**\n * Any class instance.\n */\ninterface Instance {\n  constructor: Constructor;\n}\n"]}