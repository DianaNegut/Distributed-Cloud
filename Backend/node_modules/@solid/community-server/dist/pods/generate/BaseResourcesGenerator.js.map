{"version":3,"file":"BaseResourcesGenerator.js","sourceRoot":"","sources":["../../../src/pods/generate/BaseResourcesGenerator.ts"],"names":[],"mappings":";;;AAAA,qCAAmE;AAEnE,uCAAsC;AACtC,2BAA4B;AAE5B,uFAAoF;AACpF,6FAA0F;AAE1F,mDAAqD;AAOrD,0DAAyD;AACzD,4DAAuD;AAEvD,kDAA4F;AAC5F,0DAA8D;AAC9D,sDAA4E;AAqC5E,sDAAsD;AACtD,SAAS,UAAU,CAAC,IAAoC,EAAE,KAAqC;IAC7F,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAC7E,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAa,sBAAsB;IACd,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE9B,OAAO,CAA8B;IACrC,cAAc,CAAiB;IAC/B,iBAAiB,CAAS;IAC1B,gBAAgB,CAAoB;IACpC,KAAK,CAAc;IAEpC;;;;OAIG;IACH,YAAmB,IAAqC;QACtD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC1C,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,IAAI,MAAM,CAAC;QAC1D,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC9C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;IAC1B,CAAC;IAEM,KAAK,CAAA,CAAE,QAAQ,CAAC,cAAsB,EAAE,QAA4B,EAAE,OAAsB;QAEjG,cAAc,GAAG,IAAA,2BAAgB,EAAC,cAAc,CAAC,CAAC;QAElD,kCAAkC;QAClC,IAAI,CAAC,MAAM,IAAA,qBAAU,EAAC,cAAc,CAAC,EAAE,CAAC;YACtC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,yCAAyC,cAAc,EAAE,CAAC,CAAC;YAC5E,OAAO;QACT,CAAC;QAED,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;QACxE,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;QACrE,KAAK,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IACzD,CAAC;IAED;;OAEG;IACK,KAAK,CAAA,CAAE,aAAa,CAAC,UAAgC,EAAE,MAA4B,EAAE,OAAsB;QAEjH,+DAA+D;QAC/D,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAEjE,oCAAoC;QACpC,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC;QACzD,OAAO,KAAK,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAEzC,KAAK,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,UAAU,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;QAE5D,mCAAmC;QACnC,KAAK,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;YACnE,IAAI,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;gBAC3C,KAAK,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;YACnD,CAAC;iBAAM,CAAC;gBACN,KAAK,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;YACpD,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACK,KAAK,CAAC,cAAc,CAAC,QAAgB,EAAE,MAA4B;QACzE,MAAM,KAAK,GAAG,MAAM,kBAAU,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAE/C,mFAAmF;QACnF,MAAM,UAAU,GAAG,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC7D,MAAM,UAAU,GAAG,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;QAC7F,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;QAC5E,+DAA+D;QAC/D,OAAO;YACL,GAAG,IAAI;YACP,QAAQ;YACR,UAAU;SACX,CAAC;IACJ,CAAC;IAED;;;OAGG;IACK,KAAK,CAAC,UAAU,CAAC,UAAkB,EAAE,MAA4B;QAEvE,MAAM,KAAK,GAAG,MAAM,kBAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QACnD,MAAM,KAAK,GAAgF,EAAE,CAAC;QAC9F,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAA,uBAAY,EAAC,UAAU,EAAE,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;YAC/E,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC;YACjC,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;QAC9F,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;OAKG;IACK,KAAK,CAAA,CAAE,gBAAgB,CAAC,IAA0B,EAAE,OAAsB,EAAE,QAA+B;QAEjH,IAAI,IAAmC,CAAC;QACxC,MAAM,QAAQ,GAAG,IAAI,+CAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAE7D,qCAAqC;QACrC,IAAI,CAAC,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;YAC5C,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YAC7C,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QAC1C,CAAC;QAED,+CAA+C;QAC/C,IAAI,QAAQ,EAAE,CAAC;YACb,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACnE,IAAI,WAAW,CAAC,WAAW,EAAE,CAAC;gBAC5B,iCAAiC;gBACjC,QAAQ,CAAC,WAAW,GAAG,SAAS,CAAC;YACnC,CAAC;YACD,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YAClC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,uBAAuB,QAAQ,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;QACvE,CAAC;QAED,MAAM,WAAW,GAAG,CAAC,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC9G,IAAI,WAAW,EAAE,CAAC;YAChB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,uBAAuB,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YACjE,MAAM;gBACJ,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,cAAc,EAAE,IAAI,yCAAmB,CAAC,IAAI,IAAI,EAAE,EAAE,QAAQ,CAAC;aAC9D,CAAC;QACJ,CAAC;QAED,iFAAiF;QACjF,yFAAyF;QACzF,IAAI,QAAQ,IAAI,CAAC,CAAC,WAAW,IAAI,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC;YACzE,MAAM,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACrF,IAAA,kCAAmB,EAAC,QAAQ,EAAE,IAAA,gCAAqB,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YACtE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,uBAAuB,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC;YAChE,MAAM;gBACJ,UAAU,EAAE,cAAc;gBAC1B,cAAc,EAAE,IAAI,yCAAmB,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,cAAc,EAAE,6BAAc,CAAC;aAC1F,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,gBAAgB,CAAC,QAA8B,EAAE,OAAsB;QAEnF,MAAM,QAAQ,GAAG,IAAI,+CAAsB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;QAEjE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACvD,MAAM,MAAM,GAAG,IAAI,WAAM,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC,WAAW,EAAE,OAAO,EAAE,QAAQ,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;QAC/F,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,IAAA,6BAAgB,EAAC,IAAI,CAAC,CAAC,CAAC;QACzD,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAEzB,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,WAAW,CAAC,IAA0B,EAAE,QAAuB;QAC3E,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACpB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,QAAQ,EAAE,EAAE,YAAY,EAAE,IAAI,CAAC,QAAQ,EAAE,EAAC,CAAC,CAAC;YAC9G,OAAO,IAAA,8BAAiB,EAAC,QAAQ,CAAC,CAAC;QACrC,CAAC;QACD,OAAO,IAAA,2BAAW,EAAC,IAAA,0BAAgB,EAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IACtD,CAAC;CACF;AA7KD,wDA6KC","sourcesContent":["import { createReadStream, promises as fsPromises } from 'node:fs';\nimport type { Readable } from 'node:stream';\nimport { pathExists } from 'fs-extra';\nimport { Parser } from 'n3';\nimport type { AuxiliaryStrategy } from '../../http/auxiliary/AuxiliaryStrategy';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type {\n  FileIdentifierMapper,\n  FileIdentifierMapperFactory,\n  ResourceLink,\n} from '../../storage/mapping/FileIdentifierMapper';\nimport type { ResourceSet } from '../../storage/ResourceSet';\nimport { INTERNAL_QUADS } from '../../util/ContentTypes';\nimport { guardStream } from '../../util/GuardedStream';\nimport type { Guarded } from '../../util/GuardedStream';\nimport { isContainerIdentifier, joinFilePath, resolveAssetPath } from '../../util/PathUtil';\nimport { addResourceMetadata } from '../../util/ResourceUtil';\nimport { guardedStreamFrom, readableToString } from '../../util/StreamUtil';\nimport type { TemplateEngine } from '../../util/templates/TemplateEngine';\nimport type { Resource } from './ResourcesGenerator';\nimport type { TemplatedResourcesGenerator } from './TemplatedResourcesGenerator';\nimport Dict = NodeJS.Dict;\n\ninterface TemplateResourceLink extends ResourceLink {\n  isTemplate: boolean;\n}\n\n/**\n * Input arguments required for {@link BaseResourcesGenerator}\n */\nexport interface SubfolderResourcesGeneratorArgs {\n  /**\n   * Factory used to generate mapper relative to the base identifier.\n   */\n  factory: FileIdentifierMapperFactory;\n  /**\n   * Template engine for generating the resources.\n   */\n  templateEngine: TemplateEngine;\n  /**\n   * The extension of files that need to be interpreted as templates.\n   * Will be removed to generate the identifier.\n   */\n  templateExtension?: string;\n  /**\n   * The metadataStrategy\n   */\n  metadataStrategy: AuxiliaryStrategy;\n  /**\n   * The default ResourceStore\n   */\n  store: ResourceSet;\n}\n\n// Comparator for the results of the `groupLinks` call\nfunction comparator(left: { link: TemplateResourceLink }, right: { link: TemplateResourceLink }): number {\n  return left.link.identifier.path.localeCompare(right.link.identifier.path);\n}\n\n/**\n * Generates resources by making use of a template engine.\n * The template folder structure will be kept.\n * Folders will be interpreted as containers and files as documents.\n * A FileIdentifierMapper will be used to generate identifiers that correspond to the relative structure.\n *\n * Metadata resources will be yielded separately from their subject resource.\n *\n * A relative `templateFolder` is resolved relative to cwd,\n * unless it's preceded by `@css:`, e.g. `@css:foo/bar`.\n */\nexport class BaseResourcesGenerator implements TemplatedResourcesGenerator {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly factory: FileIdentifierMapperFactory;\n  private readonly templateEngine: TemplateEngine;\n  private readonly templateExtension: string;\n  private readonly metadataStrategy: AuxiliaryStrategy;\n  private readonly store: ResourceSet;\n\n  /**\n   * A mapper is needed to convert the template file paths to identifiers relative to the given base identifier.\n   *\n   * @param args - TemplatedResourcesGeneratorArgs\n   */\n  public constructor(args: SubfolderResourcesGeneratorArgs) {\n    this.factory = args.factory;\n    this.templateEngine = args.templateEngine;\n    this.templateExtension = args.templateExtension ?? '.hbs';\n    this.metadataStrategy = args.metadataStrategy;\n    this.store = args.store;\n  }\n\n  public async* generate(templateFolder: string, location: ResourceIdentifier, options: Dict<unknown>):\n  AsyncIterable<Resource> {\n    templateFolder = resolveAssetPath(templateFolder);\n\n    // Ignore folders that don't exist\n    if (!await pathExists(templateFolder)) {\n      this.logger.warn(`Ignoring non-existing template folder ${templateFolder}`);\n      return;\n    }\n\n    const mapper = await this.factory.create(location.path, templateFolder);\n    const folderLink = await this.toTemplateLink(templateFolder, mapper);\n    yield* this.processFolder(folderLink, mapper, options);\n  }\n\n  /**\n   * Generates results for all entries in the given folder, including the folder itself.\n   */\n  private async* processFolder(folderLink: TemplateResourceLink, mapper: FileIdentifierMapper, options: Dict<unknown>):\n  AsyncIterable<Resource> {\n    // Group resource links with their corresponding metadata links\n    const links = await this.groupLinks(folderLink.filePath, mapper);\n\n    // Remove root metadata if it exists\n    const metaLink = links[folderLink.identifier.path]?.meta;\n    delete links[folderLink.identifier.path];\n\n    yield* this.generateResource(folderLink, options, metaLink);\n\n    // Make sure the results are sorted\n    for (const { link, meta } of Object.values(links).sort(comparator)) {\n      if (isContainerIdentifier(link.identifier)) {\n        yield* this.processFolder(link, mapper, options);\n      } else {\n        yield* this.generateResource(link, options, meta);\n      }\n    }\n  }\n\n  /**\n   * Creates a TemplateResourceLink for the given filePath,\n   * which connects a resource URL to its template file.\n   * The identifier will be based on the file path stripped from the template extension,\n   * but the filePath parameter will still point to the original file.\n   */\n  private async toTemplateLink(filePath: string, mapper: FileIdentifierMapper): Promise<TemplateResourceLink> {\n    const stats = await fsPromises.lstat(filePath);\n\n    // Slice the template extension from the filepath for correct identifier generation\n    const isTemplate = filePath.endsWith(this.templateExtension);\n    const slicedPath = isTemplate ? filePath.slice(0, -this.templateExtension.length) : filePath;\n    const link = await mapper.mapFilePathToUrl(slicedPath, stats.isDirectory());\n    // We still need the original file path for disk reading though\n    return {\n      ...link,\n      filePath,\n      isTemplate,\n    };\n  }\n\n  /**\n   * Generates TemplateResourceLinks for each entry in the given folder\n   * and combines the results so resources and their metadata are grouped together.\n   */\n  private async groupLinks(folderPath: string, mapper: FileIdentifierMapper):\n  Promise<Record<string, { link: TemplateResourceLink; meta?: TemplateResourceLink }>> {\n    const files = await fsPromises.readdir(folderPath);\n    const links: Record<string, { link: TemplateResourceLink; meta?: TemplateResourceLink }> = {};\n    for (const name of files) {\n      const link = await this.toTemplateLink(joinFilePath(folderPath, name), mapper);\n      const { path } = link.identifier;\n      links[path] = Object.assign(links[path] || {}, link.isMetadata ? { meta: link } : { link });\n    }\n    return links;\n  }\n\n  /**\n   * Generates a Resource object for the given ResourceLink.\n   * In the case of documents the corresponding template will be used.\n   * If a ResourceLink of metadata is provided the corresponding metadata resource\n   * will be yielded as a separate resource.\n   */\n  private async* generateResource(link: TemplateResourceLink, options: Dict<unknown>, metaLink?: TemplateResourceLink):\n  AsyncIterable<Resource> {\n    let data: Guarded<Readable> | undefined;\n    const metadata = new RepresentationMetadata(link.identifier);\n\n    // Read file if it is not a container\n    if (!isContainerIdentifier(link.identifier)) {\n      data = await this.processFile(link, options);\n      metadata.contentType = link.contentType;\n    }\n\n    // Add metadata from .meta file if there is one\n    if (metaLink) {\n      const rawMetadata = await this.generateMetadata(metaLink, options);\n      if (rawMetadata.contentType) {\n        // Prevent having 2 content types\n        metadata.contentType = undefined;\n      }\n      metadata.setMetadata(rawMetadata);\n      this.logger.debug(`Adding metadata for ${metaLink.identifier.path}`);\n    }\n\n    const shouldYield = !isContainerIdentifier(link.identifier) || !await this.store.hasResource(link.identifier);\n    if (shouldYield) {\n      this.logger.debug(`Generating resource ${link.identifier.path}`);\n      yield {\n        identifier: link.identifier,\n        representation: new BasicRepresentation(data ?? [], metadata),\n      };\n    }\n\n    // Still need to yield metadata in case the actual resource is not being yielded.\n    // We also do this for containers as existing containers can't be edited in the same way.\n    if (metaLink && (!shouldYield || isContainerIdentifier(link.identifier))) {\n      const metaIdentifier = this.metadataStrategy.getAuxiliaryIdentifier(link.identifier);\n      addResourceMetadata(metadata, isContainerIdentifier(link.identifier));\n      this.logger.debug(`Generating resource ${metaIdentifier.path}`);\n      yield {\n        identifier: metaIdentifier,\n        representation: new BasicRepresentation(metadata.quads(), metaIdentifier, INTERNAL_QUADS),\n      };\n    }\n  }\n\n  /**\n   * Generates a RepresentationMetadata using the given template.\n   */\n  private async generateMetadata(metaLink: TemplateResourceLink, options: Dict<unknown>):\n  Promise<RepresentationMetadata> {\n    const metadata = new RepresentationMetadata(metaLink.identifier);\n\n    const data = await this.processFile(metaLink, options);\n    const parser = new Parser({ format: metaLink.contentType, baseIRI: metaLink.identifier.path });\n    const quads = parser.parse(await readableToString(data));\n    metadata.addQuads(quads);\n\n    return metadata;\n  }\n\n  /**\n   * Creates a read stream from the file and applies the template if necessary.\n   */\n  private async processFile(link: TemplateResourceLink, contents: Dict<unknown>): Promise<Guarded<Readable>> {\n    if (link.isTemplate) {\n      const rendered = await this.templateEngine.handleSafe({ contents, template: { templateFile: link.filePath }});\n      return guardedStreamFrom(rendered);\n    }\n    return guardStream(createReadStream(link.filePath));\n  }\n}\n"]}