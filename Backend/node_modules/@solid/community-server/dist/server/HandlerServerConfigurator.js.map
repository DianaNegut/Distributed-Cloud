{"version":3,"file":"HandlerServerConfigurator.js","sourceRoot":"","sources":["../../src/server/HandlerServerConfigurator.ts"],"names":[],"mappings":";;;AACA,gDAAkD;AAClD,wDAAmD;AACnD,yDAAoD;AAEpD,6DAA0D;AAE1D;;;;;;GAMG;AACH,MAAa,yBAA0B,SAAQ,uCAAkB;IAC5C,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAC5B,WAAW,GAAG,CAAC,KAAY,EAAQ,EAAE;QACtD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC;IACvD,CAAC,CAAC;IAEF,2BAA2B;IACV,OAAO,CAAc;IACrB,cAAc,CAAU;IAEzC,YAAmB,OAAoB,EAAE,cAAc,GAAG,KAAK;QAC7D,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;IACvC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,MAAc;QAChC,MAAM,CAAC,EAAE,CACP,SAAS;QACT,kDAAkD;QAClD,KAAK,EAAC,OAAwB,EAAE,QAAwB,EAAiB,EAAE;YACzE,IAAI,CAAC;gBACH,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,OAAO,CAAC,MAAM,gBAAgB,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;gBAC1E,MAAM,cAAc,GAAG,IAAA,2BAAW,EAAC,OAAO,CAAC,CAAC;gBAC5C,cAAc,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;gBAC7C,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,CAAC,CAAC;YACvE,CAAC;YAAC,OAAO,KAAc,EAAE,CAAC;gBACxB,MAAM,MAAM,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBAC9C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBAC1B,IAAI,QAAQ,CAAC,WAAW,EAAE,CAAC;oBACzB,QAAQ,CAAC,GAAG,EAAE,CAAC;gBACjB,CAAC;qBAAM,CAAC;oBACN,QAAQ,CAAC,SAAS,CAAC,cAAc,EAAE,2BAA2B,CAAC,CAAC;oBAChE,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACtC,CAAC;YACH,CAAC;oBAAS,CAAC;gBACT,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;oBAC1B,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;gBAChC,CAAC;YACH,CAAC;QACH,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,kBAAkB,CAAC,KAAc;QACvC,IAAI,CAAC,IAAA,mBAAO,EAAC,KAAK,CAAC,EAAE,CAAC;YACpB,OAAO,kBAAkB,KAAe,KAAK,CAAC;QAChD,CAAC;QACD,IAAI,IAAI,CAAC,cAAc,IAAI,IAAA,mBAAO,EAAC,KAAK,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;YACzD,OAAO,GAAG,KAAK,CAAC,KAAK,IAAI,CAAC;QAC5B,CAAC;QACD,OAAO,GAAG,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC;IAC7C,CAAC;CACF;AAxDD,8DAwDC","sourcesContent":["import type { IncomingMessage, Server, ServerResponse } from 'node:http';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { isError } from '../util/errors/ErrorUtil';\nimport { guardStream } from '../util/GuardedStream';\nimport type { HttpHandler } from './HttpHandler';\nimport { ServerConfigurator } from './ServerConfigurator';\n\n/**\n * A {@link ServerConfigurator} that attaches an {@link HttpHandler} to the `request` event of a {@link Server}.\n * All incoming requests will be sent to the provided handler.\n * Failsafes are added to make sure a valid response is sent in case something goes wrong.\n *\n * The `showStackTrace` parameter can be used to add stack traces to error outputs.\n */\nexport class HandlerServerConfigurator extends ServerConfigurator {\n  protected readonly logger = getLoggerFor(this);\n  protected readonly errorLogger = (error: Error): void => {\n    this.logger.error(`Request error: ${error.message}`);\n  };\n\n  /** The main HttpHandler */\n  private readonly handler: HttpHandler;\n  private readonly showStackTrace: boolean;\n\n  public constructor(handler: HttpHandler, showStackTrace = false) {\n    super();\n    this.handler = handler;\n    this.showStackTrace = showStackTrace;\n  }\n\n  public async handle(server: Server): Promise<void> {\n    server.on(\n      'request',\n      // eslint-disable-next-line ts/no-misused-promises\n      async(request: IncomingMessage, response: ServerResponse): Promise<void> => {\n        try {\n          this.logger.info(`Received ${request.method} request for ${request.url}`);\n          const guardedRequest = guardStream(request);\n          guardedRequest.on('error', this.errorLogger);\n          await this.handler.handleSafe({ request: guardedRequest, response });\n        } catch (error: unknown) {\n          const errMsg = this.createErrorMessage(error);\n          this.logger.error(errMsg);\n          if (response.headersSent) {\n            response.end();\n          } else {\n            response.setHeader('Content-Type', 'text/plain; charset=utf-8');\n            response.writeHead(500).end(errMsg);\n          }\n        } finally {\n          if (!response.headersSent) {\n            response.writeHead(404).end();\n          }\n        }\n      },\n    );\n  }\n\n  /**\n   * Creates a readable error message based on the error and the `showStackTrace` parameter.\n   */\n  private createErrorMessage(error: unknown): string {\n    if (!isError(error)) {\n      return `Unknown error: ${error as string}.\\n`;\n    }\n    if (this.showStackTrace && isError(error) && error.stack) {\n      return `${error.stack}\\n`;\n    }\n    return `${error.name}: ${error.message}\\n`;\n  }\n}\n"]}