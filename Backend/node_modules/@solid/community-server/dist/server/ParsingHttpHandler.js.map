{"version":3,"file":"ParsingHttpHandler.js","sourceRoot":"","sources":["../../src/server/ParsingHttpHandler.ts"],"names":[],"mappings":";;;AAIA,gDAAkD;AAClD,wDAA8D;AAC9D,wDAAqD;AACrD,4EAAyE;AAEzE,+CAA4C;AAwB5C;;;;GAIG;AACH,MAAa,kBAAmB,SAAQ,yBAAW;IAChC,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE5B,aAAa,CAAgB;IAC7B,YAAY,CAAe;IAC3B,cAAc,CAAiB;IAC/B,gBAAgB,CAAuB;IAExD,YAAmB,IAA4B;QAC7C,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC;QACtC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC;QAC1C,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC;IAChD,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAoB;QACzD,IAAI,MAA2B,CAAC;QAEhC,IAAI,CAAC;YACH,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QACvD,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,MAAM,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QAClD,CAAC;QAED,IAAI,MAAM,EAAE,CAAC;YACX,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;QAC7D,CAAC;IACH,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,aAAa,CAAC,OAAoB,EAAE,QAAsB;QAExE,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;QAC/D,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;QAExF,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,SAAS,CAAC,MAAM,iBAAiB,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;QACxF,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,WAAW,CAAC,KAAc,EAAE,OAAoB;QAC9D,IAAI,CAAC,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;YACjC,KAAK,GAAG,IAAI,yCAAmB,CAC7B,sCAAsC,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,EACjE,EAAE,KAAK,EAAE,KAAK,EAAE,CACjB,CAAC;QACJ,CAAC;QAED,OAAO,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,KAAK,EAAE,KAAkB,EAAE,OAAO,EAAE,CAAC,CAAC;IAC9E,CAAC;CACF;AAvDD,gDAuDC","sourcesContent":["import type { RequestParser } from '../http/input/RequestParser';\nimport type { ErrorHandler } from '../http/output/error/ErrorHandler';\nimport type { ResponseDescription } from '../http/output/response/ResponseDescription';\nimport type { ResponseWriter } from '../http/output/ResponseWriter';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { createErrorMessage } from '../util/errors/ErrorUtil';\nimport { HttpError } from '../util/errors/HttpError';\nimport { InternalServerError } from '../util/errors/InternalServerError';\nimport type { HttpHandlerInput } from './HttpHandler';\nimport { HttpHandler } from './HttpHandler';\nimport type { HttpRequest } from './HttpRequest';\nimport type { HttpResponse } from './HttpResponse';\nimport type { OperationHttpHandler } from './OperationHttpHandler';\n\nexport interface ParsingHttpHandlerArgs {\n  /**\n   * Parses the incoming requests.\n   */\n  requestParser: RequestParser;\n  /**\n   * Converts errors to a serializable format.\n   */\n  errorHandler: ErrorHandler;\n  /**\n   * Writes out the response of the operation.\n   */\n  responseWriter: ResponseWriter;\n  /**\n   * Handler to send the operation to.\n   */\n  operationHandler: OperationHttpHandler;\n}\n\n/**\n * Parses requests and sends the resulting {@link Operation} to the wrapped {@link OperationHttpHandler}.\n * Errors are caught and handled by the {@link ErrorHandler}.\n * In case the {@link OperationHttpHandler} returns a result it will be sent to the {@link ResponseWriter}.\n */\nexport class ParsingHttpHandler extends HttpHandler {\n  private readonly logger = getLoggerFor(this);\n\n  private readonly requestParser: RequestParser;\n  private readonly errorHandler: ErrorHandler;\n  private readonly responseWriter: ResponseWriter;\n  private readonly operationHandler: OperationHttpHandler;\n\n  public constructor(args: ParsingHttpHandlerArgs) {\n    super();\n    this.requestParser = args.requestParser;\n    this.errorHandler = args.errorHandler;\n    this.responseWriter = args.responseWriter;\n    this.operationHandler = args.operationHandler;\n  }\n\n  public async handle({ request, response }: HttpHandlerInput): Promise<void> {\n    let result: ResponseDescription;\n\n    try {\n      result = await this.handleRequest(request, response);\n    } catch (error: unknown) {\n      result = await this.handleError(error, request);\n    }\n\n    if (result) {\n      await this.responseWriter.handleSafe({ response, result });\n    }\n  }\n\n  /**\n   * Interprets the request and passes the generated Operation object to the stored OperationHttpHandler.\n   */\n  protected async handleRequest(request: HttpRequest, response: HttpResponse):\n  Promise<ResponseDescription> {\n    const operation = await this.requestParser.handleSafe(request);\n    const result = await this.operationHandler.handleSafe({ operation, request, response });\n\n    this.logger.verbose(`Parsed ${operation.method} operation on ${operation.target.path}`);\n    return result;\n  }\n\n  /**\n   * Handles the error output correctly based on the preferences.\n   */\n  protected async handleError(error: unknown, request: HttpRequest): Promise<ResponseDescription> {\n    if (!HttpError.isInstance(error)) {\n      error = new InternalServerError(\n        `Received unexpected non-HttpError: ${createErrorMessage(error)}`,\n        { cause: error },\n      );\n    }\n\n    return this.errorHandler.handleSafe({ error: error as HttpError, request });\n  }\n}\n"]}