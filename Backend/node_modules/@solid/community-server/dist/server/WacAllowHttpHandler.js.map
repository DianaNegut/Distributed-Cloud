{"version":3,"file":"WacAllowHttpHandler.js","sourceRoot":"","sources":["../../src/server/WacAllowHttpHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Credentials } from '../authentication/Credentials';\nimport type { CredentialsExtractor } from '../authentication/CredentialsExtractor';\nimport type { PermissionReader } from '../authorization/PermissionReader';\nimport type { AclPermissionSet } from '../authorization/permissions/AclPermissionSet';\nimport { AclMode } from '../authorization/permissions/AclPermissionSet';\nimport type { ModesExtractor } from '../authorization/permissions/ModesExtractor';\nimport { AccessMode } from '../authorization/permissions/Permissions';\nimport type { ResponseDescription } from '../http/output/response/ResponseDescription';\nimport type { RepresentationMetadata } from '../http/representation/RepresentationMetadata';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { NotModifiedHttpError } from '../util/errors/NotModifiedHttpError';\nimport { ACL, AUTH } from '../util/Vocabularies';\nimport type { OperationHttpHandlerInput } from './OperationHttpHandler';\nimport { OperationHttpHandler } from './OperationHttpHandler';\n\nconst VALID_METHODS = new Set([ 'HEAD', 'GET' ]);\nconst VALID_ACL_MODES = new Set([ AccessMode.read, AccessMode.write, AccessMode.append, AclMode.control ]);\n\nexport interface WacAllowHttpHandlerArgs {\n  credentialsExtractor: CredentialsExtractor;\n  modesExtractor: ModesExtractor;\n  permissionReader: PermissionReader;\n  operationHandler: OperationHttpHandler;\n}\n\n/**\n * Adds all the available permissions to the response metadata,\n * which can be used to generate the correct WAC-Allow header.\n *\n * This class does many things similar to the {@link AuthorizingHttpHandler},\n * so in general it is a good idea to make sure all these classes cache their results.\n */\nexport class WacAllowHttpHandler extends OperationHttpHandler {\n  private readonly logger = getLoggerFor(this);\n\n  private readonly credentialsExtractor: CredentialsExtractor;\n  private readonly modesExtractor: ModesExtractor;\n  private readonly permissionReader: PermissionReader;\n  private readonly operationHandler: OperationHttpHandler;\n\n  public constructor(args: WacAllowHttpHandlerArgs) {\n    super();\n    this.credentialsExtractor = args.credentialsExtractor;\n    this.modesExtractor = args.modesExtractor;\n    this.permissionReader = args.permissionReader;\n    this.operationHandler = args.operationHandler;\n  }\n\n  public async handle(input: OperationHttpHandlerInput): Promise<ResponseDescription> {\n    const { request, operation } = input;\n    let response: ResponseDescription | NotModifiedHttpError;\n    try {\n      response = await this.operationHandler.handleSafe(input);\n    } catch (error: unknown) {\n      // WAC-Allow headers need to be added to 304 responses\n      // as the value can differ even if the representation is the same.\n      if (NotModifiedHttpError.isInstance(error)) {\n        response = error;\n      } else {\n        throw error;\n      }\n    }\n    const { metadata } = response;\n\n    // WAC-Allow is only needed for HEAD/GET requests\n    if (!VALID_METHODS.has(operation.method) || !metadata) {\n      return response;\n    }\n\n    this.logger.debug('Determining available permissions.');\n    const credentials: Credentials = await this.credentialsExtractor.handleSafe(request);\n    const requestedModes = await this.modesExtractor.handleSafe(operation);\n    const availablePermissions = await this.permissionReader.handleSafe({ credentials, requestedModes });\n\n    const permissionSet = availablePermissions.get(operation.target);\n    if (permissionSet) {\n      const user: AclPermissionSet = permissionSet;\n      let everyone: AclPermissionSet;\n      if (credentials.agent?.webId) {\n        // Need to determine public permissions\n        this.logger.debug('Determining public permissions');\n        // Note that this call can potentially create a new lock on a resource that is already locked,\n        // so a locker that allows multiple read locks on the same resource is required.\n        const permissionMap = await this.permissionReader.handleSafe({ credentials: {}, requestedModes });\n        everyone = permissionMap.get(operation.target) ?? {};\n      } else {\n        // User is not authenticated so public permissions are the same as agent permissions\n        this.logger.debug('User is not authenticated so has public permissions');\n        everyone = user;\n      }\n\n      this.logger.debug('Adding WAC-Allow metadata');\n      this.addWacAllowMetadata(metadata, everyone, user);\n    }\n\n    if (NotModifiedHttpError.isInstance(response)) {\n      throw response;\n    }\n\n    return response;\n  }\n\n  /**\n   * Converts the found permissions to triples and puts them in the metadata.\n   */\n  private addWacAllowMetadata(metadata: RepresentationMetadata, everyone: AclPermissionSet, user: AclPermissionSet):\n  void {\n    const modes = new Set<AccessMode>([ ...Object.keys(user), ...Object.keys(everyone) ] as AccessMode[]);\n    for (const mode of modes) {\n      if (VALID_ACL_MODES.has(mode)) {\n        const capitalizedMode = mode.charAt(0).toUpperCase() + mode.slice(1) as 'Read' | 'Write' | 'Append' | 'Control';\n        if (everyone[mode]) {\n          metadata.add(AUTH.terms.publicMode, ACL.terms[capitalizedMode]);\n        }\n        if (user[mode]) {\n          metadata.add(AUTH.terms.userMode, ACL.terms[capitalizedMode]);\n        }\n      }\n    }\n  }\n}\n"]}