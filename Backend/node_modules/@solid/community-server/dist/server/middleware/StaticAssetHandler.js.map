{"version":3,"file":"StaticAssetHandler.js","sourceRoot":"","sources":["../../../src/server/middleware/StaticAssetHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { createReadStream } from 'node:fs';\nimport escapeStringRegexp from 'escape-string-regexp';\nimport * as mime from 'mime-types';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { APPLICATION_OCTET_STREAM } from '../../util/ContentTypes';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport type { SystemError } from '../../util/errors/SystemError';\nimport { ensureTrailingSlash, joinFilePath, resolveAssetPath, trimLeadingSlashes } from '../../util/PathUtil';\nimport { pipeSafely } from '../../util/StreamUtil';\nimport type { HttpHandlerInput } from '../HttpHandler';\nimport { HttpHandler } from '../HttpHandler';\nimport type { HttpRequest } from '../HttpRequest';\n\n/**\n * Used to link file paths with relative URLs.\n * By using a separate class instead of a key/value map it is easier to replace values in Components.js.\n */\nexport class StaticAssetEntry {\n  public constructor(\n    public readonly relativeUrl: string,\n    public readonly filePath: string,\n  ) {}\n}\n\n/**\n * Handler that serves static resources on specific paths.\n * Relative file paths are assumed to be relative to the current working directory.\n * Relative file paths can be preceded by `@css:`, e.g. `@css:foo/bar`,\n * in case they need to be relative to the module root.\n * File paths ending in a slash assume the target is a folder and map all of its contents.\n */\nexport class StaticAssetHandler extends HttpHandler {\n  private readonly mappings: Record<string, string>;\n  private readonly pathMatcher: RegExp;\n  private readonly expires: number;\n  private readonly logger = getLoggerFor(this);\n\n  /**\n   * Creates a handler for the provided static resources.\n   *\n   * @param assets - A list of {@link StaticAssetEntry}.\n   * @param baseUrl - The base URL of the server.\n   * @param options - Specific options.\n   * @param options.expires - Cache expiration time in seconds.\n   */\n  public constructor(assets: StaticAssetEntry[], baseUrl: string, options: { expires?: number } = {}) {\n    super();\n    this.mappings = {};\n    const rootPath = ensureTrailingSlash(new URL(baseUrl).pathname);\n\n    for (const { relativeUrl, filePath } of assets) {\n      this.mappings[trimLeadingSlashes(relativeUrl)] = resolveAssetPath(filePath);\n    }\n    this.pathMatcher = this.createPathMatcher(rootPath);\n    this.expires = Number.isInteger(options.expires) ? Math.max(0, options.expires!) : 0;\n  }\n\n  /**\n   * Creates a regular expression that matches the URL paths.\n   */\n  private createPathMatcher(rootPath: string): RegExp {\n    // Sort longest paths first to ensure the longest match has priority\n    const paths = Object.keys(this.mappings)\n      .sort((pathA, pathB): number => pathB.length - pathA.length);\n\n    // Collect regular expressions for files and folders separately.\n    // The arrays need initial values to prevent matching everything, as they will if these are empty.\n    const files = [ '.^' ];\n    const folders = [ '.^' ];\n    for (const path of paths) {\n      const filePath = this.mappings[path];\n      if (filePath.endsWith('/') && !path.endsWith('/')) {\n        throw new InternalServerError(\n          `Server is misconfigured: StaticAssetHandler can not ` +\n          `have a file path ending on a slash if the URL does not, but received ${path} and ${filePath}`,\n        );\n      }\n      (filePath.endsWith('/') ? folders : files).push(escapeStringRegexp(path));\n    }\n\n    // Either match an exact document or a file within a folder (stripping the query string)\n    return new RegExp(`^${rootPath}(?:(${files.join('|')})|(${folders.join('|')})([^?]+))(?:\\\\?.*)?$`, 'u');\n  }\n\n  /**\n   * Obtains the file path corresponding to the asset URL\n   */\n  private getFilePath({ url }: HttpRequest): string {\n    // Verify if the URL matches any of the paths\n    const match = this.pathMatcher.exec(url ?? '');\n    if (!match || match[0].includes('/..')) {\n      throw new NotImplementedHttpError(`No static resource configured at ${url}`);\n    }\n\n    // The mapping is either a known document, or a file within a folder\n    const [ , document, folder, file ] = match;\n\n    return typeof document === 'string' ?\n      this.mappings[document] :\n      joinFilePath(this.mappings[folder], decodeURIComponent(file));\n  }\n\n  public async canHandle({ request }: HttpHandlerInput): Promise<void> {\n    if (request.method !== 'GET' && request.method !== 'HEAD') {\n      throw new NotImplementedHttpError('Only GET and HEAD requests are supported');\n    }\n    this.getFilePath(request);\n  }\n\n  public async handle({ request, response }: HttpHandlerInput): Promise<void> {\n    // Determine the asset to serve\n    const filePath = this.getFilePath(request);\n    this.logger.debug(`Serving ${request.url} via static asset ${filePath}`);\n\n    // Resolve when asset loading succeeds\n    const asset = createReadStream(filePath);\n    return new Promise((resolve, reject): void => {\n      // Write a 200 response when the asset becomes readable\n      asset.once('readable', (): void => {\n        const contentType = mime.lookup(filePath) || APPLICATION_OCTET_STREAM;\n        response.writeHead(200, {\n          // eslint-disable-next-line ts/naming-convention\n          'content-type': contentType,\n          ...this.getCacheHeaders(),\n        });\n\n        // With HEAD, only write the headers\n        if (request.method === 'HEAD') {\n          response.end();\n          asset.destroy();\n        // With GET, pipe the entire response\n        } else {\n          pipeSafely(asset, response);\n        }\n        resolve();\n      });\n\n      // Pass the error when something goes wrong\n      asset.once('error', (error): void => {\n        const { code } = error as SystemError;\n        // When the file if not found or a folder, signal a 404\n        if (code === 'ENOENT' || code === 'EISDIR') {\n          this.logger.debug(`Static asset ${filePath} not found`);\n          reject(new NotFoundHttpError(`Cannot find ${request.url}`));\n        // In other cases, we might already have started writing, so just hang up\n        } else {\n          this.logger.warn(`Error reading asset ${filePath}: ${error.message}`);\n          response.end();\n          asset.destroy();\n          resolve();\n        }\n      });\n    });\n  }\n\n  private getCacheHeaders(): Record<string, string> {\n    return this.expires <= 0 ?\n        {} :\n        {\n          // eslint-disable-next-line ts/naming-convention\n          'cache-control': `max-age=${this.expires}`,\n          expires: new Date(Date.now() + this.expires * 1000).toUTCString(),\n        };\n  }\n}\n"]}