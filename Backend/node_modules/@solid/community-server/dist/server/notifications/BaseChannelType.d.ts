import type { Store } from 'n3';
import type { NamedNode, Term } from '@rdfjs/types';
import type { Credentials } from '../../authentication/Credentials';
import type { AccessMap } from '../../authorization/permissions/Permissions';
import type { InteractionRoute } from '../../identity/interaction/routing/InteractionRoute';
import type { NotificationChannel } from './NotificationChannel';
import type { NotificationChannelType, SubscriptionService } from './NotificationChannelType';
/**
 * The default notification features that are available on all channel types.
 */
export declare const DEFAULT_NOTIFICATION_FEATURES: string[];
/**
 * The SHACL shape for the minimum requirements on a notification channel subscription request.
 */
export declare const DEFAULT_SUBSCRIPTION_SHACL: {
    readonly '@context': readonly ["https://w3c.github.io/shacl/shacl-jsonld-context/shacl.context.ld.json"];
    readonly '@type': "sh:NodeShape";
    readonly targetSubjectsOf: "http://www.w3.org/ns/solid/notifications#topic";
    readonly closed: true;
    readonly property: readonly [{
        readonly path: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
        readonly minCount: 1;
        readonly maxCount: 1;
        readonly nodeKind: "sh:IRI";
    }, {
        readonly path: "http://www.w3.org/ns/solid/notifications#topic";
        readonly minCount: 1;
        readonly maxCount: 1;
        readonly nodeKind: "sh:IRI";
    }, ...unknown[]];
};
/**
 * A {@link NotificationChannelType} that handles the base case of parsing and serializing a notification channel.
 * Note that the `extractModes` call always requires Read permissions on the target resource.
 *
 * Uses SHACL to validate the incoming data in `initChannel`.
 * Classes extending this can pass extra SHACL properties in the constructor to extend the validation check.
 *
 * The `completeChannel` implementation is an empty function.
 */
export declare abstract class BaseChannelType implements NotificationChannelType {
    protected readonly type: NamedNode;
    protected readonly path: string;
    protected readonly shacl: unknown;
    protected shaclQuads?: Store;
    protected readonly features: NamedNode[];
    /**
     * @param type - The URI of the notification channel type.
     *               This will be added to the SHACL shape to validate incoming subscription data.
     * @param route - The route corresponding to the URL of the subscription service of this channel type.
     *                Channel identifiers will be generated by appending a value to this URL.
     * @param features - The features that should be enabled for this channel type.
     *                   Values are expected to be full URIs, but the `notify:` prefix can also be used.
     * @param additionalShaclProperties - Any additional properties that need to be added to the default SHACL shape.
     */
    protected constructor(type: NamedNode, route: InteractionRoute, features?: string[], additionalShaclProperties?: unknown[]);
    getDescription(): SubscriptionService;
    /**
     * Initiates the channel by first calling {@link validateSubscription} followed by {@link quadsToChannel}.
     * Subclasses can override either function safely to impact the result of the function.
     */
    initChannel(data: Store, credentials: Credentials): Promise<NotificationChannel>;
    /**
     * Returns an N3.js {@link Store} containing quads corresponding to the stored SHACL representation.
     * Caches this result so the conversion from JSON-LD to quads only has to happen once.
     */
    protected getShaclQuads(): Promise<Store>;
    /**
     * Validates whether the given data conforms to the stored SHACL shape.
     * Will throw an {@link UnprocessableEntityHttpError} if validation fails.
     * Along with the SHACL check, this also makes sure there is only one matching entry in the dataset.
     *
     * @param data - The data to validate.
     *
     * @returns The focus node that corresponds to the subject of the found notification channel description.
     */
    protected validateSubscription(data: Store): Promise<Term>;
    /**
     * Converts a set of quads to a {@link NotificationChannel}.
     * Assumes the data is valid, so this should be called after {@link validateSubscription}.
     *
     * The generated identifier will be a URL made by combining the base URL of the channel type with a unique identifier.
     *
     * The values of the default features will be added to the resulting channel,
     * subclasses with additional features that need to be added are responsible for parsing those quads.
     *
     * @param data - Data to convert.
     * @param subject - The identifier of the notification channel description in the dataset.
     *
     * @returns The generated {@link NotificationChannel}.
     */
    protected quadsToChannel(data: Store, subject: Term): Promise<NotificationChannel>;
    /**
     * Converts the given channel to a JSON-LD description.
     * All fields found in the channel, except `lastEmit`, will be part of the result subject,
     * so subclasses should remove any fields that should not be exposed.
     */
    toJsonLd(channel: NotificationChannel): Promise<Record<string, unknown>>;
    extractModes(channel: NotificationChannel): Promise<AccessMap>;
    completeChannel(channel: NotificationChannel): Promise<void>;
}
