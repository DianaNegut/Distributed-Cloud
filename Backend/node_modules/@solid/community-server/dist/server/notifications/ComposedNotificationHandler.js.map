{"version":3,"file":"ComposedNotificationHandler.js","sourceRoot":"","sources":["../../../src/server/notifications/ComposedNotificationHandler.ts"],"names":[],"mappings":";;;AAIA,+DAA4D;AAU5D;;;;;GAKG;AACH,MAAa,2BAA4B,SAAQ,yCAAmB;IACjD,SAAS,CAAwB;IACjC,UAAU,CAAyB;IACnC,OAAO,CAAsB;IAC7B,WAAW,CAAc;IAE1C,YAAmB,IAAqC;QACtD,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC;QAChC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;QAClC,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAC5B,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;IACtC,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAA+B;QACpD,MAAM,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACxC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAA+B;QACjD,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAExD,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC;QAChC,sEAAsE;QACtE,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,YAAY,CAAC,KAAK;YACjD,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC;YAChE,OAAO;QACT,CAAC;QAED,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,YAAY,EAAE,CAAC,CAAC;QAClG,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,cAAc,EAAE,CAAC,CAAC;IAC5E,CAAC;CACF;AA/BD,kEA+BC","sourcesContent":["import type { ETagHandler } from '../../storage/conditions/ETagHandler';\nimport type { NotificationGenerator } from './generate/NotificationGenerator';\nimport type { NotificationEmitter } from './NotificationEmitter';\nimport type { NotificationHandlerInput } from './NotificationHandler';\nimport { NotificationHandler } from './NotificationHandler';\nimport type { NotificationSerializer } from './serialize/NotificationSerializer';\n\nexport interface ComposedNotificationHandlerArgs {\n  generator: NotificationGenerator;\n  serializer: NotificationSerializer;\n  emitter: NotificationEmitter;\n  eTagHandler: ETagHandler;\n}\n\n/**\n * Generates, serializes and emits a {@link Notification} using a {@link NotificationGenerator},\n * {@link NotificationSerializer} and {@link NotificationEmitter}.\n *\n * Will not emit an event when it has the same state as the notification channel.\n */\nexport class ComposedNotificationHandler extends NotificationHandler {\n  private readonly generator: NotificationGenerator;\n  private readonly serializer: NotificationSerializer;\n  private readonly emitter: NotificationEmitter;\n  private readonly eTagHandler: ETagHandler;\n\n  public constructor(args: ComposedNotificationHandlerArgs) {\n    super();\n    this.generator = args.generator;\n    this.serializer = args.serializer;\n    this.emitter = args.emitter;\n    this.eTagHandler = args.eTagHandler;\n  }\n\n  public async canHandle(input: NotificationHandlerInput): Promise<void> {\n    await this.generator.canHandle(input);\n  }\n\n  public async handle(input: NotificationHandlerInput): Promise<void> {\n    const notification = await this.generator.handle(input);\n\n    const { state } = input.channel;\n    // In case the state matches there is no need to send the notification\n    if (typeof state === 'string' && notification.state &&\n      this.eTagHandler.sameResourceState(state, notification.state)) {\n      return;\n    }\n\n    const representation = await this.serializer.handleSafe({ channel: input.channel, notification });\n    await this.emitter.handleSafe({ channel: input.channel, representation });\n  }\n}\n"]}