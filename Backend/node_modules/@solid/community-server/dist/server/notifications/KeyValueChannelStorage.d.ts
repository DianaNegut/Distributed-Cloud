import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';
import type { KeyValueStorage } from '../../storage/keyvalue/KeyValueStorage';
import type { ReadWriteLocker } from '../../util/locking/ReadWriteLocker';
import type { NotificationChannel } from './NotificationChannel';
import type { NotificationChannelStorage } from './NotificationChannelStorage';
type StorageValue = string | string[] | NotificationChannel;
/**
 * Stores all the {@link NotificationChannel} in a {@link KeyValueStorage}.
 * Encodes IDs/topics before storing them in the KeyValueStorage.
 *
 * Uses a {@link ReadWriteLocker} to prevent internal race conditions.
 */
export declare class KeyValueChannelStorage implements NotificationChannelStorage {
    protected logger: import("../..").Logger;
    private readonly storage;
    private readonly locker;
    constructor(storage: KeyValueStorage<string, StorageValue>, locker: ReadWriteLocker);
    get(id: string): Promise<NotificationChannel | undefined>;
    getAll(topic: ResourceIdentifier): Promise<string[]>;
    add(channel: NotificationChannel): Promise<void>;
    update(channel: NotificationChannel): Promise<void>;
    delete(id: string): Promise<boolean>;
    /**
     * Utility function for deleting a specific {@link NotificationChannel} object.
     * Does not create a lock on the channel ID so should be wrapped in such a lock.
     */
    private deleteChannel;
    private isChannel;
    private getLockKey;
}
export {};
