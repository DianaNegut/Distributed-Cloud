import type { CredentialsExtractor } from '../../authentication/CredentialsExtractor';
import type { Authorizer } from '../../authorization/Authorizer';
import type { PermissionReader } from '../../authorization/PermissionReader';
import type { ResponseDescription } from '../../http/output/response/ResponseDescription';
import type { RepresentationConverter } from '../../storage/conversion/RepresentationConverter';
import type { OperationHttpHandlerInput } from '../OperationHttpHandler';
import { OperationHttpHandler } from '../OperationHttpHandler';
import type { NotificationChannelStorage } from './NotificationChannelStorage';
import type { NotificationChannelType } from './NotificationChannelType';
export interface NotificationSubscriberArgs {
    /**
     * The {@link NotificationChannelType} with all the necessary information.
     */
    channelType: NotificationChannelType;
    /**
     * {@link RepresentationConverter} used to convert input data into RDF.
     */
    converter: RepresentationConverter;
    /**
     * Used to extract the credentials from the request.
     */
    credentialsExtractor: CredentialsExtractor;
    /**
     * Used to determine which permissions the found credentials have.
     */
    permissionReader: PermissionReader;
    /**
     * Used to determine if the request has the necessary permissions.
     */
    authorizer: Authorizer;
    /**
     * Storage used to store the channels.
     */
    storage: NotificationChannelStorage;
    /**
     * Overrides the expiration feature of channels, by making sure they always expire after the `maxDuration` value.
     * If the expiration of the channel is shorter than `maxDuration`, the original value will be kept.
     * Value is set in minutes. 0 is infinite.
     * Defaults to 20160 minutes, which is 2 weeks.
     */
    maxDuration?: number;
}
/**
 * Handles notification subscriptions by creating a notification channel.
 *
 * Uses the information from the provided {@link NotificationChannelType} to validate the input
 * and verify the request has the required permissions available.
 * If successful the generated channel will be stored in a {@link NotificationChannelStorage}.
 */
export declare class NotificationSubscriber extends OperationHttpHandler {
    protected logger: import("../..").Logger;
    private readonly channelType;
    private readonly converter;
    private readonly credentialsExtractor;
    private readonly permissionReader;
    private readonly authorizer;
    private readonly storage;
    private readonly maxDuration;
    constructor(args: NotificationSubscriberArgs);
    handle({ operation, request }: OperationHttpHandlerInput): Promise<ResponseDescription>;
    private authorize;
}
