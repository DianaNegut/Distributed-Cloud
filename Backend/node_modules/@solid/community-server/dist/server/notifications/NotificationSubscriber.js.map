{"version":3,"file":"NotificationSubscriber.js","sourceRoot":"","sources":["../../../src/server/notifications/NotificationSubscriber.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Credentials } from '../../authentication/Credentials';\nimport type { CredentialsExtractor } from '../../authentication/CredentialsExtractor';\nimport type { Authorizer } from '../../authorization/Authorizer';\nimport type { PermissionReader } from '../../authorization/PermissionReader';\nimport { OkResponseDescription } from '../../http/output/response/OkResponseDescription';\nimport type { ResponseDescription } from '../../http/output/response/ResponseDescription';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport type { RepresentationConverter } from '../../storage/conversion/RepresentationConverter';\nimport { APPLICATION_LD_JSON, INTERNAL_QUADS } from '../../util/ContentTypes';\nimport { createErrorMessage } from '../../util/errors/ErrorUtil';\nimport { UnprocessableEntityHttpError } from '../../util/errors/UnprocessableEntityHttpError';\nimport { endOfStream, readableToQuads } from '../../util/StreamUtil';\nimport type { OperationHttpHandlerInput } from '../OperationHttpHandler';\nimport { OperationHttpHandler } from '../OperationHttpHandler';\nimport type { NotificationChannel } from './NotificationChannel';\nimport type { NotificationChannelStorage } from './NotificationChannelStorage';\nimport type { NotificationChannelType } from './NotificationChannelType';\n\nexport interface NotificationSubscriberArgs {\n  /**\n   * The {@link NotificationChannelType} with all the necessary information.\n   */\n  channelType: NotificationChannelType;\n  /**\n   * {@link RepresentationConverter} used to convert input data into RDF.\n   */\n  converter: RepresentationConverter;\n  /**\n   * Used to extract the credentials from the request.\n   */\n  credentialsExtractor: CredentialsExtractor;\n  /**\n   * Used to determine which permissions the found credentials have.\n   */\n  permissionReader: PermissionReader;\n  /**\n   * Used to determine if the request has the necessary permissions.\n   */\n  authorizer: Authorizer;\n  /**\n   * Storage used to store the channels.\n   */\n  storage: NotificationChannelStorage;\n  /**\n   * Overrides the expiration feature of channels, by making sure they always expire after the `maxDuration` value.\n   * If the expiration of the channel is shorter than `maxDuration`, the original value will be kept.\n   * Value is set in minutes. 0 is infinite.\n   * Defaults to 20160 minutes, which is 2 weeks.\n   */\n  maxDuration?: number;\n}\n\n/**\n * Handles notification subscriptions by creating a notification channel.\n *\n * Uses the information from the provided {@link NotificationChannelType} to validate the input\n * and verify the request has the required permissions available.\n * If successful the generated channel will be stored in a {@link NotificationChannelStorage}.\n */\nexport class NotificationSubscriber extends OperationHttpHandler {\n  protected logger = getLoggerFor(this);\n\n  private readonly channelType: NotificationChannelType;\n  private readonly converter: RepresentationConverter;\n  private readonly credentialsExtractor: CredentialsExtractor;\n  private readonly permissionReader: PermissionReader;\n  private readonly authorizer: Authorizer;\n  private readonly storage: NotificationChannelStorage;\n  private readonly maxDuration: number;\n\n  public constructor(args: NotificationSubscriberArgs) {\n    super();\n    this.channelType = args.channelType;\n    this.converter = args.converter;\n    this.credentialsExtractor = args.credentialsExtractor;\n    this.permissionReader = args.permissionReader;\n    this.authorizer = args.authorizer;\n    this.storage = args.storage;\n    this.maxDuration = (args.maxDuration ?? 20160) * 60 * 1000;\n  }\n\n  public async handle({ operation, request }: OperationHttpHandlerInput): Promise<ResponseDescription> {\n    if (operation.method === 'GET' || operation.method === 'HEAD') {\n      const description = JSON.stringify(this.channelType.getDescription(), null, 2);\n      const representation = new BasicRepresentation(description, operation.target, APPLICATION_LD_JSON);\n      return new OkResponseDescription(\n        representation.metadata,\n        operation.method === 'GET' ? representation.data : undefined,\n      );\n    }\n\n    const credentials = await this.credentialsExtractor.handleSafe(request);\n    this.logger.debug(`Extracted credentials: ${JSON.stringify(credentials)}`);\n\n    let channel: NotificationChannel;\n    try {\n      const quadStream = await this.converter.handleSafe({\n        identifier: operation.target,\n        representation: operation.body,\n        preferences: { type: { [INTERNAL_QUADS]: 1 }},\n      });\n      channel = await this.channelType.initChannel(await readableToQuads(quadStream.data), credentials);\n    } catch (error: unknown) {\n      throw new UnprocessableEntityHttpError(\n        `Unable to process notification channel: ${createErrorMessage(error)}`,\n        { cause: error },\n      );\n    }\n\n    if (this.maxDuration) {\n      const duration = (channel.endAt ?? Number.POSITIVE_INFINITY) - Date.now();\n      if (duration > this.maxDuration) {\n        channel.endAt = Date.now() + this.maxDuration;\n      }\n    }\n\n    // Verify if the client is allowed to subscribe\n    await this.authorize(credentials, channel);\n\n    // Store the channel once it has been authorized\n    await this.storage.add(channel);\n\n    // Generate the response JSON-LD\n    const jsonld = await this.channelType.toJsonLd(channel);\n    const response = new BasicRepresentation(JSON.stringify(jsonld), APPLICATION_LD_JSON);\n\n    // Complete the channel once the response has been sent out\n    endOfStream(response.data)\n      .then(async(): Promise<void> => this.channelType.completeChannel(channel))\n      .catch((error): void => {\n        this.logger.error(`There was an issue completing notification channel ${channel.id}: ${\n          createErrorMessage(error)}`);\n      });\n\n    return new OkResponseDescription(response.metadata, response.data);\n  }\n\n  private async authorize(credentials: Credentials, channel: NotificationChannel): Promise<void> {\n    const requestedModes = await this.channelType.extractModes(channel);\n    this.logger.debug(`Retrieved required modes: ${[ ...requestedModes.entrySets() ].join(',')}`);\n\n    const availablePermissions = await this.permissionReader.handleSafe({ credentials, requestedModes });\n    this.logger.debug(`Available permissions are ${[ ...availablePermissions.entries() ].join(',')}`);\n\n    await this.authorizer.handleSafe({ credentials, requestedModes, availablePermissions });\n    this.logger.debug(`Authorization succeeded, creating notification channel`);\n  }\n}\n"]}