{"version":3,"file":"StreamingHttp2023Emitter.js","sourceRoot":"","sources":["../../../../src/server/notifications/StreamingHttpChannel2023/StreamingHttp2023Emitter.ts"],"names":[],"mappings":";;;AAAA,sDAAwD;AAExD,sEAAmE;AACnE,yDAA4D;AAS5D;;;;GAIG;AACH,MAAa,wBAAyB,SAAQ,2BAAuC;IAIhE;IAHA,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE/C,YACmB,SAA2B;QAE5C,KAAK,EAAE,CAAC;QAFS,cAAS,GAAT,SAAS,CAAkB;IAG9C,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,OAAO,EAAE,cAAc,EAA6B;QACxE,yDAAyD;QACzD,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAClD,IAAI,OAAO,EAAE,CAAC;YACZ,iEAAiE;YACjE,MAAM,KAAK,GAAG,MAAM,IAAA,6BAAgB,EAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YAC1D,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;gBAC7B,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACtB,CAAC;QACH,CAAC;aAAM,CAAC;YACN,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;QAChC,CAAC;IACH,CAAC;CACF;AAtBD,4DAsBC","sourcesContent":["import { getLoggerFor } from '../../../logging/LogUtil';\nimport type { Representation } from '../../../http/representation/Representation';\nimport { AsyncHandler } from '../../../util/handlers/AsyncHandler';\nimport { readableToString } from '../../../util/StreamUtil';\nimport type { NotificationChannel } from '../NotificationChannel';\nimport type { StreamingHttpMap } from './StreamingHttpMap';\n\nexport interface StreamingHttpEmitterInput {\n  channel: NotificationChannel;\n  representation: Representation;\n}\n\n/**\n * Emits notifications on StreamingHTTPChannel2023 streams.\n * Uses the response streams found in the provided map.\n * The key should be the identifier of the topic resource.\n */\nexport class StreamingHttp2023Emitter extends AsyncHandler<StreamingHttpEmitterInput> {\n  protected readonly logger = getLoggerFor(this);\n\n  public constructor(\n    private readonly streamMap: StreamingHttpMap,\n  ) {\n    super();\n  }\n\n  public async handle({ channel, representation }: StreamingHttpEmitterInput): Promise<void> {\n    // Called as a NotificationEmitter: emit the notification\n    const streams = this.streamMap.get(channel.topic);\n    if (streams) {\n      // Ensure that the whole notification gets sent in a single chunk\n      const chunk = await readableToString(representation.data);\n      for (const stream of streams) {\n        stream.write(chunk);\n      }\n    } else {\n      representation.data.destroy();\n    }\n  }\n}\n"]}