{"version":3,"file":"StreamingHttpRequestHandler.js","sourceRoot":"","sources":["../../../../src/server/notifications/StreamingHttpChannel2023/StreamingHttpRequestHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { PassThrough } from 'node:stream';\nimport type { Credentials } from '../../../authentication/Credentials';\nimport type { CredentialsExtractor } from '../../../authentication/CredentialsExtractor';\nimport type { Authorizer } from '../../../authorization/Authorizer';\nimport type { PermissionReader } from '../../../authorization/PermissionReader';\nimport { AccessMode } from '../../../authorization/permissions/Permissions';\nimport { OkResponseDescription } from '../../../http/output/response/OkResponseDescription';\nimport type { ResponseDescription } from '../../../http/output/response/ResponseDescription';\nimport { BasicRepresentation } from '../../../http/representation/BasicRepresentation';\nimport type { InteractionRoute } from '../../../identity/interaction/routing/InteractionRoute';\nimport { getLoggerFor } from '../../../logging/LogUtil';\nimport type { OperationHttpHandlerInput } from '../../OperationHttpHandler';\nimport { OperationHttpHandler } from '../../OperationHttpHandler';\nimport { guardStream } from '../../../util/GuardedStream';\nimport { IdentifierSetMultiMap } from '../../../util/map/IdentifierMap';\nimport { createErrorMessage } from '../../../util/errors/ErrorUtil';\nimport type { NotificationGenerator } from '../generate/NotificationGenerator';\nimport type { NotificationSerializer } from '../serialize/NotificationSerializer';\nimport { readableToString } from '../../../util/StreamUtil';\nimport type { StreamingHttpMap } from './StreamingHttpMap';\nimport { generateChannel } from './StreamingHttp2023Util';\n\n/**\n * Handles request to Streaming HTTP receiveFrom endopints.\n * All allowed requests are stored in the {@link StreamingHttpMap}\n */\nexport class StreamingHttpRequestHandler extends OperationHttpHandler {\n  protected logger = getLoggerFor(this);\n\n  public constructor(\n    private readonly streamMap: StreamingHttpMap,\n    private readonly route: InteractionRoute,\n    private readonly generator: NotificationGenerator,\n    private readonly serializer: NotificationSerializer,\n    private readonly credentialsExtractor: CredentialsExtractor,\n    private readonly permissionReader: PermissionReader,\n    private readonly authorizer: Authorizer,\n  ) {\n    super();\n  }\n\n  public async handle({ operation, request }: OperationHttpHandlerInput): Promise<ResponseDescription> {\n    const encodedUrl = operation.target.path.replace(this.route.getPath(), '');\n    const topic = decodeURIComponent(encodedUrl);\n\n    // Verify if the client is allowed to connect\n    const credentials = await this.credentialsExtractor.handleSafe(request);\n    await this.authorize(credentials, topic);\n\n    const stream = guardStream(new PassThrough());\n    this.streamMap.add(topic, stream);\n    stream.on('error', (): boolean => this.streamMap.deleteEntry(topic, stream));\n    stream.on('close', (): boolean => this.streamMap.deleteEntry(topic, stream));\n\n    const channel = generateChannel({ path: topic });\n    // Send initial notification\n    try {\n      const notification = await this.generator.handle({ channel, topic: { path: topic }});\n      const representation = await this.serializer.handleSafe({ channel, notification });\n      // Ensure that the whole notification gets sent in a single chunk\n      const chunk = await readableToString(representation.data);\n      stream.write(chunk);\n    } catch (error: unknown) {\n      this.logger.error(`Problem emitting initial notification: ${createErrorMessage(error)}`);\n    }\n    // Pre-established channels use Turtle\n    const representation = new BasicRepresentation(topic, operation.target, channel.accept);\n    return new OkResponseDescription(\n      representation.metadata,\n      stream,\n    );\n  }\n\n  private async authorize(credentials: Credentials, topic: string): Promise<void> {\n    const requestedModes = new IdentifierSetMultiMap<AccessMode>([[{ path: topic }, AccessMode.read ]]);\n    this.logger.debug(`Retrieved required modes: ${[ ...requestedModes.entrySets() ].join(',')}`);\n\n    const availablePermissions = await this.permissionReader.handleSafe({ credentials, requestedModes });\n    this.logger.debug(`Available permissions are ${[ ...availablePermissions.entries() ].join(',')}`);\n\n    await this.authorizer.handleSafe({ credentials, requestedModes, availablePermissions });\n    this.logger.debug(`Authorization succeeded, creating notification channel`);\n  }\n}\n"]}