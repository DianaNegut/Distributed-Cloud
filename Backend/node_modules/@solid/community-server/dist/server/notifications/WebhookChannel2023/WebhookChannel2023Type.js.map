{"version":3,"file":"WebhookChannel2023Type.js","sourceRoot":"","sources":["../../../../src/server/notifications/WebhookChannel2023/WebhookChannel2023Type.ts"],"names":[],"mappings":";;;AAuBA,oDAEC;AAvBD,sDAAwD;AACxD,8DAAoE;AACpE,6DAAoD;AACpD,wDAAqD;AAkBrD,SAAgB,oBAAoB,CAAC,OAA4B;IAC/D,OAAO,OAAO,CAAC,IAAI,KAAK,qBAAM,CAAC,kBAAkB,CAAC;AACpD,CAAC;AAED;;;;;;;GAOG;AACH,MAAa,sBAAuB,SAAQ,iCAAe;IACtC,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE9B,YAAY,CAAe;IAC3B,KAAK,CAAS;IAE/B;;;;;OAKG;IACH,YACE,KAAuB,EACvB,UAA4B,EAC5B,YAA0B,EAC1B,QAAmB;QAEnB,KAAK,CAAC,qBAAM,CAAC,KAAK,CAAC,kBAAkB,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC,EAAE,IAAI,EAAE,qBAAM,CAAC,MAAM,EAAE,QAAQ,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC7G,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,OAAO,EAAE,CAAC;IACpC,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,IAAW;QAClC,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QACtD,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACzD,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,qBAAM,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAEtE,OAAO;YACL,GAAG,OAAO;YACV,IAAI,EAAE,qBAAM,CAAC,kBAAkB;YAC/B,MAAM,EAAE,MAAM,CAAC,KAAK;SACrB,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,QAAQ,CAAC,OAA4B;QAChD,MAAM,IAAI,GAAG,MAAM,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAE3C,kCAAkC;QAClC,sFAAsF;QACtF,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC;QAEzB,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,eAAe,CAAC,OAA4B;QACvD,IAAI,CAAC;YACH,+CAA+C;YAC/C,MAAM,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC;QAClD,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,sCAAsC,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QACvF,CAAC;IACH,CAAC;CACF;AArDD,wDAqDC","sourcesContent":["import type { Store } from 'n3';\nimport type { InteractionRoute } from '../../../identity/interaction/routing/InteractionRoute';\nimport { getLoggerFor } from '../../../logging/LogUtil';\nimport { createErrorMessage } from '../../../util/errors/ErrorUtil';\nimport { NOTIFY } from '../../../util/Vocabularies';\nimport { BaseChannelType } from '../BaseChannelType';\nimport type { NotificationChannel } from '../NotificationChannel';\nimport type { StateHandler } from '../StateHandler';\n\n/**\n * A {@link NotificationChannel} containing the necessary fields for a WebhookChannel2023 channel.\n */\nexport interface WebhookChannel2023 extends NotificationChannel {\n  /**\n   * The \"WebhookChannel2023\" type.\n   */\n  type: typeof NOTIFY.WebhookChannel2023;\n  /**\n   * Where the notifications have to be sent.\n   */\n  sendTo: string;\n}\n\nexport function isWebhook2023Channel(channel: NotificationChannel): channel is WebhookChannel2023 {\n  return channel.type === NOTIFY.WebhookChannel2023;\n}\n\n/**\n * The notification channel type WebhookChannel2023 as described in\n * https://solid.github.io/notifications/webhook-channel-2023\n *\n * Requires read permissions on a resource to be able to receive notifications.\n *\n * Also handles the `state` feature if present.\n */\nexport class WebhookChannel2023Type extends BaseChannelType {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly stateHandler: StateHandler;\n  private readonly webId: string;\n\n  /**\n   * @param route - The route corresponding to the URL of the subscription service of this channel type.\n   * @param webIdRoute - The route to the WebID that needs to be used when generating DPoP tokens for notifications.\n   * @param stateHandler - The {@link StateHandler} that will be called after a successful subscription.\n   * @param features - The features that need to be enabled for this channel type.\n   */\n  public constructor(\n    route: InteractionRoute,\n    webIdRoute: InteractionRoute,\n    stateHandler: StateHandler,\n    features?: string[],\n  ) {\n    super(NOTIFY.terms.WebhookChannel2023, route, features, [{ path: NOTIFY.sendTo, minCount: 1, maxCount: 1 }]);\n    this.stateHandler = stateHandler;\n    this.webId = webIdRoute.getPath();\n  }\n\n  public async initChannel(data: Store): Promise<WebhookChannel2023> {\n    const subject = await this.validateSubscription(data);\n    const channel = await this.quadsToChannel(data, subject);\n    const sendTo = data.getObjects(subject, NOTIFY.terms.sendTo, null)[0];\n\n    return {\n      ...channel,\n      type: NOTIFY.WebhookChannel2023,\n      sendTo: sendTo.value,\n    };\n  }\n\n  public async toJsonLd(channel: NotificationChannel): Promise<Record<string, unknown>> {\n    const json = await super.toJsonLd(channel);\n\n    // Add the stored WebID as sender.\n    // We don't store it in the channel object itself as we always know what it is anyway.\n    json.sender = this.webId;\n\n    return json;\n  }\n\n  public async completeChannel(channel: NotificationChannel): Promise<void> {\n    try {\n      // Send the state notification, if there is one\n      await this.stateHandler.handleSafe({ channel });\n    } catch (error: unknown) {\n      this.logger.error(`Error emitting state notification: ${createErrorMessage(error)}`);\n    }\n  }\n}\n"]}