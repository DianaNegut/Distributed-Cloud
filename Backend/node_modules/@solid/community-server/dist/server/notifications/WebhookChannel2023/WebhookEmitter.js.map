{"version":3,"file":"WebhookEmitter.js","sourceRoot":"","sources":["../../../../src/server/notifications/WebhookChannel2023/WebhookEmitter.ts"],"names":[],"mappings":"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","sourcesContent":["import fetch from 'cross-fetch';\nimport { calculateJwkThumbprint, importJWK, SignJWT } from 'jose';\nimport { v4 } from 'uuid';\nimport type { JwkGenerator } from '../../../identity/configuration/JwkGenerator';\nimport type { InteractionRoute } from '../../../identity/interaction/routing/InteractionRoute';\nimport { getLoggerFor } from '../../../logging/LogUtil';\nimport { NotImplementedHttpError } from '../../../util/errors/NotImplementedHttpError';\nimport { trimTrailingSlashes } from '../../../util/PathUtil';\nimport { readableToString } from '../../../util/StreamUtil';\nimport type { NotificationEmitterInput } from '../NotificationEmitter';\nimport { NotificationEmitter } from '../NotificationEmitter';\nimport type { WebhookChannel2023 } from './WebhookChannel2023Type';\nimport { isWebhook2023Channel } from './WebhookChannel2023Type';\n\n/**\n * Emits a notification representation using the WebhookChannel2023 specification.\n *\n * At the time of writing it is not specified how exactly a notification sender should make its requests verifiable,\n * so for now we use a token similar to those from Solid-OIDC, signed by the server itself.\n *\n * Generates a DPoP token and proof, and adds those to the HTTP request that is sent to the target.\n *\n * The `expiration` input parameter is how long the generated token should be valid in minutes.\n * Default is 20.\n */\nexport class WebhookEmitter extends NotificationEmitter {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly issuer: string;\n  private readonly webId: string;\n  private readonly jwkGenerator: JwkGenerator;\n  private readonly expiration: number;\n\n  public constructor(baseUrl: string, webIdRoute: InteractionRoute, jwkGenerator: JwkGenerator, expiration = 20) {\n    super();\n    this.issuer = trimTrailingSlashes(baseUrl);\n    this.webId = webIdRoute.getPath();\n    this.jwkGenerator = jwkGenerator;\n    this.expiration = expiration * 60 * 1000;\n  }\n\n  public async canHandle({ channel }: NotificationEmitterInput): Promise<void> {\n    if (!isWebhook2023Channel(channel)) {\n      throw new NotImplementedHttpError(`${channel.id} is not a WebhookChannel2023 channel.`);\n    }\n  }\n\n  public async handle({ channel, representation }: NotificationEmitterInput): Promise<void> {\n    // Cast was checked in `canHandle`\n    const webhookChannel = channel as WebhookChannel2023;\n    this.logger.debug(`Emitting Webhook notification with target ${webhookChannel.sendTo}`);\n\n    const privateKey = await this.jwkGenerator.getPrivateKey();\n    const publicKey = await this.jwkGenerator.getPublicKey();\n\n    const privateKeyObject = await importJWK(privateKey);\n\n    // Make sure both header and proof have the same timestamp\n    const time = Date.now();\n\n    // Currently the spec does not define how the notification sender should identify.\n    // The format used here has been chosen to be similar\n    // to how ID tokens are described in the Solid-OIDC specification for consistency.\n    const dpopToken = await new SignJWT({\n      webid: this.webId,\n      azp: this.webId,\n      sub: this.webId,\n      cnf: {\n        jkt: await calculateJwkThumbprint(publicKey, 'sha256'),\n      },\n    }).setProtectedHeader({ alg: privateKey.alg })\n      .setIssuedAt(time)\n      .setExpirationTime(time + this.expiration)\n      .setAudience([ this.webId, 'solid' ])\n      .setIssuer(this.issuer)\n      .setJti(v4())\n      .sign(privateKeyObject);\n\n    // https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop#section-4.2\n    const dpopProof = await new SignJWT({\n      htu: webhookChannel.sendTo,\n      htm: 'POST',\n    }).setProtectedHeader({ alg: privateKey.alg, jwk: publicKey, typ: 'dpop+jwt' })\n      .setIssuedAt(time)\n      .setJti(v4())\n      .sign(privateKeyObject);\n\n    const response = await fetch(webhookChannel.sendTo, {\n      method: 'POST',\n      headers: {\n        // eslint-disable-next-line ts/naming-convention\n        'content-type': representation.metadata.contentType!,\n        authorization: `DPoP ${dpopToken}`,\n        dpop: dpopProof,\n      },\n      body: await readableToString(representation.data),\n    });\n    if (response.status >= 400) {\n      this.logger.error(`There was an issue emitting a Webhook notification with target ${webhookChannel.sendTo}: ${\n        await response.text()}`);\n    }\n  }\n}\n"]}