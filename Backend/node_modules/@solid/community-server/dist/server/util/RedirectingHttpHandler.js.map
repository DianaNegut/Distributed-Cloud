{"version":3,"file":"RedirectingHttpHandler.js","sourceRoot":"","sources":["../../../src/server/util/RedirectingHttpHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import type { TargetExtractor } from '../../http/input/identifier/TargetExtractor';\nimport { RedirectResponseDescription } from '../../http/output/response/RedirectResponseDescription';\nimport type { ResponseWriter } from '../../http/output/ResponseWriter';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { FoundHttpError } from '../../util/errors/FoundHttpError';\nimport { MovedPermanentlyHttpError } from '../../util/errors/MovedPermanentlyHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { PermanentRedirectHttpError } from '../../util/errors/PermanentRedirectHttpError';\nimport type { RedirectHttpError } from '../../util/errors/RedirectHttpError';\nimport { SeeOtherHttpError } from '../../util/errors/SeeOtherHttpError';\nimport { TemporaryRedirectHttpError } from '../../util/errors/TemporaryRedirectHttpError';\nimport { getRelativeUrl, joinUrl } from '../../util/PathUtil';\nimport type { HttpHandlerInput } from '../HttpHandler';\nimport { HttpHandler } from '../HttpHandler';\nimport type { HttpRequest } from '../HttpRequest';\n\n/* eslint-disable ts/naming-convention */\nconst redirectErrorFactories: Record<301 | 302 | 303 | 307 | 308, (location: string) => RedirectHttpError> = {\n  301: (location: string): RedirectHttpError => new MovedPermanentlyHttpError(location),\n  302: (location: string): RedirectHttpError => new FoundHttpError(location),\n  303: (location: string): RedirectHttpError => new SeeOtherHttpError(location),\n  307: (location: string): RedirectHttpError => new TemporaryRedirectHttpError(location),\n  308: (location: string): RedirectHttpError => new PermanentRedirectHttpError(location),\n};\n/* eslint-enable ts/naming-convention */\n\n/**\n * Handler that redirects paths matching given patterns\n * to their corresponding URL, substituting selected groups.\n */\nexport class RedirectingHttpHandler extends HttpHandler {\n  private readonly logger = getLoggerFor(this);\n  private readonly redirects: {\n    regex: RegExp;\n    redirectPattern: string;\n  }[];\n\n  /**\n   * Creates a handler for the provided redirects.\n   *\n   * @param redirects - A mapping between URL patterns.\n   * @param baseUrl - Base URL of the server.\n   * @param targetExtractor - To extract the target from the request.\n   * @param responseWriter - To write the redirect to the response.\n   * @param statusCode - Desired 30x redirection code (defaults to 308).\n   */\n  public constructor(\n    redirects: Record<string, string>,\n    private readonly baseUrl: string,\n    private readonly targetExtractor: TargetExtractor,\n    private readonly responseWriter: ResponseWriter,\n    private readonly statusCode: 301 | 302 | 303 | 307 | 308 = 308,\n  ) {\n    super();\n\n    // Create an array of (regexp, redirect) pairs\n    this.redirects = Object.keys(redirects).map(\n      (pattern): { regex: RegExp; redirectPattern: string } => ({\n        regex: new RegExp(pattern, 'u'),\n        redirectPattern: redirects[pattern],\n      }),\n    );\n  }\n\n  public async canHandle({ request }: HttpHandlerInput): Promise<void> {\n    // Try to find redirect for target URL\n    await this.findRedirect(request);\n  }\n\n  public async handle({ request, response }: HttpHandlerInput): Promise<void> {\n    // Try to find redirect for target URL\n    const redirect = await this.findRedirect(request);\n\n    // Send redirect response\n    this.logger.info(`Redirecting ${request.url} to ${redirect}`);\n    const result = new RedirectResponseDescription(redirectErrorFactories[this.statusCode](redirect));\n    await this.responseWriter.handleSafe({ response, result });\n  }\n\n  private async findRedirect(request: HttpRequest): Promise<string> {\n    // Retrieve target relative to base URL\n    const target = await getRelativeUrl(this.baseUrl, request, this.targetExtractor);\n\n    // Get groups and redirect of first matching pattern\n    let result;\n    for (const { regex, redirectPattern } of this.redirects) {\n      const match = regex.exec(target);\n      if (match) {\n        result = { match, redirectPattern };\n        break;\n      }\n    }\n\n    // Only return if a redirect is configured for the requested URL\n    if (!result) {\n      throw new NotImplementedHttpError(`No redirect configured for ${target}`);\n    }\n\n    // Build redirect URL from regexp result\n    const { match, redirectPattern } = result;\n    let redirect = redirectPattern;\n    for (const [ i, element ] of match.entries()) {\n      redirect = redirect.replace(`$${i}`, element);\n    }\n\n    // Don't redirect if target is already correct\n    if (redirect === target) {\n      throw new NotImplementedHttpError('Target is already correct.');\n    }\n\n    return /^(?:[a-z]+:)?\\/\\//iu.test(redirect) ? redirect : joinUrl(this.baseUrl, redirect);\n  }\n}\n"]}