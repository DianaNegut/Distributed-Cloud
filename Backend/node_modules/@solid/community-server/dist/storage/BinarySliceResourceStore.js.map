{"version":3,"file":"BinarySliceResourceStore.js","sourceRoot":"","sources":["../../src/storage/BinarySliceResourceStore.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Representation } from '../http/representation/Representation';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport { InternalServerError } from '../util/errors/InternalServerError';\nimport { RangeNotSatisfiedHttpError } from '../util/errors/RangeNotSatisfiedHttpError';\nimport { guardStream } from '../util/GuardedStream';\nimport { termToInt } from '../util/QuadUtil';\nimport { SliceStream } from '../util/SliceStream';\nimport { toLiteral } from '../util/TermUtil';\nimport { POSIX, SOLID_HTTP, XSD } from '../util/Vocabularies';\nimport type { Conditions } from './conditions/Conditions';\nimport { PassthroughStore } from './PassthroughStore';\nimport type { ResourceStore } from './ResourceStore';\n\n/**\n * Resource store that slices the data stream if there are range preferences.\n * Only works for `bytes` range preferences on binary data streams.\n * Does not support multipart range requests.\n *\n * If the slice happens, unit/start/end values will be written to the metadata to indicate such.\n * The values are dependent on the preferences we got as an input,\n * as we don't know the actual size of the data stream.\n *\n * The `defaultSliceSize` parameter can be used to set how large a slice should be if the end of a range is not defined.\n * Setting this to 0, which is the default, will cause the end of the stream to be used as the end of the slice.\n */\nexport class BinarySliceResourceStore<T extends ResourceStore = ResourceStore> extends PassthroughStore<T> {\n  protected readonly logger = getLoggerFor(this);\n  private readonly defaultSliceSize: number;\n\n  public constructor(source: T, defaultSliceSize = 0) {\n    super(source);\n    this.defaultSliceSize = defaultSliceSize;\n  }\n\n  public async getRepresentation(\n    identifier: ResourceIdentifier,\n    preferences: RepresentationPreferences,\n    conditions?: Conditions,\n  ): Promise<Representation> {\n    const result = await this.source.getRepresentation(identifier, preferences, conditions);\n\n    if (!preferences.range || preferences.range.unit !== 'bytes' || preferences.range.parts.length === 0) {\n      return result;\n    }\n    if (result.metadata.has(SOLID_HTTP.unit)) {\n      this.logger.debug('Not slicing stream that has already been sliced.');\n      return result;\n    }\n\n    if (!result.binary) {\n      throw new InternalServerError('Trying to slice a non-binary stream.');\n    }\n    if (preferences.range.parts.length > 1) {\n      throw new RangeNotSatisfiedHttpError('Multipart range requests are not supported.');\n    }\n\n    let [{ start, end }] = preferences.range.parts;\n    const size = termToInt(result.metadata.get(POSIX.terms.size));\n\n    // Set the default end size if not set already\n    if (this.defaultSliceSize > 0 && typeof end !== 'number' && typeof size === 'number' && start >= 0) {\n      end = Math.min(size, start + this.defaultSliceSize) - 1;\n    }\n\n    result.metadata.set(SOLID_HTTP.terms.unit, preferences.range.unit);\n    result.metadata.set(SOLID_HTTP.terms.start, toLiteral(start, XSD.terms.integer));\n    if (typeof end === 'number') {\n      result.metadata.set(SOLID_HTTP.terms.end, toLiteral(end, XSD.terms.integer));\n    }\n\n    try {\n      // The reason we don't determine the object mode based on the object mode of the parent stream\n      // is that `guardedStreamFrom` does not create object streams when inputting streams/buffers.\n      // Something to potentially update in the future.\n      result.data = guardStream(new SliceStream(result.data, { start, end, size, objectMode: false }));\n    } catch (error: unknown) {\n      // Creating the slice stream can throw an error if some of the parameters are unacceptable.\n      // Need to make sure the stream is closed in that case.\n      result.data.destroy();\n      throw error;\n    }\n    return result;\n  }\n}\n"]}