{"version":3,"file":"MonitoringStore.js","sourceRoot":"","sources":["../../src/storage/MonitoringStore.ts"],"names":[],"mappings":";;;AAKA,6EAA8E;AAC9E,uDAAoD;AAIpD,sDAAsD;AACtD,MAAM,eAAe,GAAG,CAAE,iBAAE,CAAC,KAAK,CAAC,GAAG,EAAE,iBAAE,CAAC,KAAK,CAAC,MAAM,EAAE,iBAAE,CAAC,KAAK,CAAC,MAAM,EAAE,iBAAE,CAAC,KAAK,CAAC,MAAM,EAAE,iBAAE,CAAC,KAAK,CAAC,MAAM,CAAE,CAAC;AAE7G;;;GAGG;AACH,MAAa,eACX,SAAQ,qCAAmB;IACV,MAAM,CAAI;IAE3B,YAAmB,MAAS;QAC1B,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,UAA8B;QACrD,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IAC7C,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAC5B,UAA8B,EAC9B,WAAsC,EACtC,UAAuB;QAEvB,OAAO,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAC5E,CAAC;IAEM,KAAK,CAAC,WAAW,CACtB,SAA6B,EAC7B,cAA8B,EAC9B,UAAuB;QAEvB,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,SAAS,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC,CAAC;IAChG,CAAC;IAEM,KAAK,CAAC,cAAc,CACzB,UAA8B,EAC9B,UAAuB;QAEvB,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC;IACpF,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAC5B,UAA8B,EAC9B,cAA8B,EAC9B,UAAuB;QAEvB,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC,CAAC;IACvG,CAAC;IAEM,KAAK,CAAC,cAAc,CACzB,UAA8B,EAC9B,KAAY,EACZ,UAAuB;QAEvB,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,UAAU,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC;IAC3F,CAAC;IAEO,WAAW,CAAC,OAAkB;QACpC,KAAK,MAAM,CAAE,UAAU,EAAE,QAAQ,CAAE,IAAI,OAAO,EAAE,CAAC;YAC/C,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,uBAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YACvD,IAAI,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACnC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,UAAU,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;gBACrD,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;YAClD,CAAC;QACH,CAAC;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,eAAe,CAAC,IAAW;QACjC,OAAO,OAAO,CAAC,IAAI,IAAI,eAAe,CAAC,IAAI,CAAC,CAAC,KAAK,EAAW,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACvF,CAAC;CACF;AAnED,0CAmEC","sourcesContent":["import type { Term } from '@rdfjs/types';\nimport type { Patch } from '../http/representation/Patch';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { BaseActivityEmitter } from '../server/notifications/ActivityEmitter';\nimport { AS, SOLID_AS } from '../util/Vocabularies';\nimport type { Conditions } from './conditions/Conditions';\nimport type { ChangeMap, ResourceStore } from './ResourceStore';\n\n// The ActivityStream terms for which we emit an event\nconst knownActivities = [ AS.terms.Add, AS.terms.Create, AS.terms.Delete, AS.terms.Remove, AS.terms.Update ];\n\n/**\n * Store that notifies listeners of changes to its source\n * by emitting a `changed` event.\n */\nexport class MonitoringStore<T extends ResourceStore = ResourceStore>\n  extends BaseActivityEmitter implements ResourceStore {\n  private readonly source: T;\n\n  public constructor(source: T) {\n    super();\n    this.source = source;\n  }\n\n  public async hasResource(identifier: ResourceIdentifier): Promise<boolean> {\n    return this.source.hasResource(identifier);\n  }\n\n  public async getRepresentation(\n    identifier: ResourceIdentifier,\n    preferences: RepresentationPreferences,\n    conditions?: Conditions,\n  ): Promise<Representation> {\n    return this.source.getRepresentation(identifier, preferences, conditions);\n  }\n\n  public async addResource(\n    container: ResourceIdentifier,\n    representation: Representation,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return this.emitChanged(await this.source.addResource(container, representation, conditions));\n  }\n\n  public async deleteResource(\n    identifier: ResourceIdentifier,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return this.emitChanged(await this.source.deleteResource(identifier, conditions));\n  }\n\n  public async setRepresentation(\n    identifier: ResourceIdentifier,\n    representation: Representation,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return this.emitChanged(await this.source.setRepresentation(identifier, representation, conditions));\n  }\n\n  public async modifyResource(\n    identifier: ResourceIdentifier,\n    patch: Patch,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return this.emitChanged(await this.source.modifyResource(identifier, patch, conditions));\n  }\n\n  private emitChanged(changes: ChangeMap): ChangeMap {\n    for (const [ identifier, metadata ] of changes) {\n      const activity = metadata.get(SOLID_AS.terms.activity);\n      if (this.isKnownActivity(activity)) {\n        this.emit('changed', identifier, activity, metadata);\n        this.emit(activity.value, identifier, metadata);\n      }\n    }\n\n    return changes;\n  }\n\n  private isKnownActivity(term?: Term): term is typeof knownActivities[number] {\n    return Boolean(term && knownActivities.some((entry): boolean => entry.equals(term)));\n  }\n}\n"]}