{"version":3,"file":"RoutingResourceStore.js","sourceRoot":"","sources":["../../src/storage/RoutingResourceStore.ts"],"names":[],"mappings":";;;AAIA,wEAAqE;AACrE,oFAAiF;AAKjF;;;;GAIG;AACH,MAAa,oBAAoB;IACd,IAAI,CAAa;IAElC,YAAmB,IAAgB;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;IAEM,KAAK,CAAC,WAAW,CAAC,UAA8B;QAErD,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;IACnE,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAC5B,UAA8B,EAC9B,WAAsC,EACtC,UAAuB;QAEvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,iBAAiB,CAAC,UAAU,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAClG,CAAC;IAEM,KAAK,CAAC,WAAW,CACtB,SAA6B,EAC7B,cAA8B,EAC9B,UAAuB;QAEvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC,CAAC,WAAW,CAAC,SAAS,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;IAC7G,CAAC;IAEM,KAAK,CAAC,iBAAiB,CAC5B,UAA8B,EAC9B,cAA8B,EAC9B,UAAuB;QAEvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC,CAAC,iBAAiB,CAAC,UAAU,EAAE,cAAc,EAAE,UAAU,CAAC,CAAC;IACrH,CAAC;IAEM,KAAK,CAAC,cAAc,CACzB,UAA8B,EAC9B,UAAuB;QAEvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,cAAc,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;IAClF,CAAC;IAEM,KAAK,CAAC,cAAc,CACzB,UAA8B,EAC9B,KAAY,EACZ,UAAuB;QAEvB,OAAO,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,cAAc,CAAC,UAAU,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;IACzF,CAAC;IAEO,KAAK,CAAC,QAAQ,CAAC,UAA8B,EAAE,cAA+B;QACpF,IAAI,cAAc,EAAE,CAAC;YACnB,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,UAAU,EAAE,cAAc,EAAE,CAAC,CAAC;QAC9D,CAAC;QAED,gFAAgF;QAChF,IAAI,CAAC;YACH,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,UAAU,EAAE,CAAC,CAAC;QACpD,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,iDAAuB,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;gBAC9C,MAAM,IAAI,qCAAiB,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;YACpD,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;CACF;AAlED,oDAkEC","sourcesContent":["import type { Patch } from '../http/representation/Patch';\nimport type { Representation } from '../http/representation/Representation';\nimport type { RepresentationPreferences } from '../http/representation/RepresentationPreferences';\nimport type { ResourceIdentifier } from '../http/representation/ResourceIdentifier';\nimport { NotFoundHttpError } from '../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../util/errors/NotImplementedHttpError';\nimport type { Conditions } from './conditions/Conditions';\nimport type { ChangeMap, ResourceStore } from './ResourceStore';\nimport type { RouterRule } from './routing/RouterRule';\n\n/**\n * Store that routes the incoming request to a specific store based on the stored ResourceRouter.\n * In case no store was found for one of the functions that take no data (GET/PATCH/DELETE),\n * a 404 will be thrown. In the other cases the error of the router will be thrown (which would probably be 400).\n */\nexport class RoutingResourceStore implements ResourceStore {\n  private readonly rule: RouterRule;\n\n  public constructor(rule: RouterRule) {\n    this.rule = rule;\n  }\n\n  public async hasResource(identifier: ResourceIdentifier):\n  Promise<boolean> {\n    return (await this.getStore(identifier)).hasResource(identifier);\n  }\n\n  public async getRepresentation(\n    identifier: ResourceIdentifier,\n    preferences: RepresentationPreferences,\n    conditions?: Conditions,\n  ): Promise<Representation> {\n    return (await this.getStore(identifier)).getRepresentation(identifier, preferences, conditions);\n  }\n\n  public async addResource(\n    container: ResourceIdentifier,\n    representation: Representation,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return (await this.getStore(container, representation)).addResource(container, representation, conditions);\n  }\n\n  public async setRepresentation(\n    identifier: ResourceIdentifier,\n    representation: Representation,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return (await this.getStore(identifier, representation)).setRepresentation(identifier, representation, conditions);\n  }\n\n  public async deleteResource(\n    identifier: ResourceIdentifier,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return (await this.getStore(identifier)).deleteResource(identifier, conditions);\n  }\n\n  public async modifyResource(\n    identifier: ResourceIdentifier,\n    patch: Patch,\n    conditions?: Conditions,\n  ): Promise<ChangeMap> {\n    return (await this.getStore(identifier)).modifyResource(identifier, patch, conditions);\n  }\n\n  private async getStore(identifier: ResourceIdentifier, representation?: Representation): Promise<ResourceStore> {\n    if (representation) {\n      return this.rule.handleSafe({ identifier, representation });\n    }\n\n    // In case there is no incoming data we want to return 404 if no store was found\n    try {\n      return await this.rule.handleSafe({ identifier });\n    } catch (error: unknown) {\n      if (NotImplementedHttpError.isInstance(error)) {\n        throw new NotFoundHttpError('', { cause: error });\n      }\n      throw error;\n    }\n  }\n}\n"]}