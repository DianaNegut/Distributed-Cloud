{"version":3,"file":"InMemoryDataAccessor.js","sourceRoot":"","sources":["../../../src/storage/accessors/InMemoryDataAccessor.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Readable } from 'node:stream';\nimport arrayifyStream from 'arrayify-stream';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { SingleThreaded } from '../../init/cluster/SingleThreaded';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport type { Guarded } from '../../util/GuardedStream';\nimport type { IdentifierStrategy } from '../../util/identifiers/IdentifierStrategy';\nimport { guardedStreamFrom } from '../../util/StreamUtil';\nimport { POSIX } from '../../util/Vocabularies';\nimport { isInternalContentType } from '../conversion/ConversionUtil';\nimport type { DataAccessor } from './DataAccessor';\n\ninterface DataEntry {\n  data: unknown[];\n  metadata: RepresentationMetadata;\n}\ninterface ContainerEntry {\n  entries: Record<string, CacheEntry>;\n  metadata: RepresentationMetadata;\n}\ntype CacheEntry = DataEntry | ContainerEntry;\n\nexport class InMemoryDataAccessor implements DataAccessor, SingleThreaded {\n  private readonly identifierStrategy: IdentifierStrategy;\n  // A dummy container where every entry corresponds to a root container\n  private readonly store: { entries: Record<string, ContainerEntry> };\n\n  public constructor(identifierStrategy: IdentifierStrategy) {\n    this.identifierStrategy = identifierStrategy;\n\n    this.store = { entries: {}};\n  }\n\n  public async canHandle(): Promise<void> {\n    // All data is supported since streams never get read, only copied\n  }\n\n  public async getData(identifier: ResourceIdentifier): Promise<Guarded<Readable>> {\n    const entry = this.getEntry(identifier);\n    if (!this.isDataEntry(entry)) {\n      throw new NotFoundHttpError();\n    }\n    return guardedStreamFrom(entry.data);\n  }\n\n  public async getMetadata(identifier: ResourceIdentifier): Promise<RepresentationMetadata> {\n    const entry = this.getEntry(identifier);\n    return new RepresentationMetadata(entry.metadata);\n  }\n\n  public async* getChildren(identifier: ResourceIdentifier): AsyncIterableIterator<RepresentationMetadata> {\n    const entry = this.getEntry(identifier);\n    if (!this.isDataEntry(entry)) {\n      const childNames = Object.keys(entry.entries);\n      yield* childNames.map((name): RepresentationMetadata => new RepresentationMetadata({ path: name }));\n    }\n  }\n\n  public async writeDocument(identifier: ResourceIdentifier, data: Guarded<Readable>, metadata: RepresentationMetadata):\n  Promise<void> {\n    const parent = this.getParentEntry(identifier);\n    // Drain original stream and create copy\n    const dataArray = await arrayifyStream(data);\n\n    // Only add the size for binary streams, which are all streams that do not have an internal type.\n    if (metadata.contentType && !isInternalContentType(metadata.contentType)) {\n      const size = dataArray.reduce<number>((total, chunk: Buffer): number => total + chunk.length, 0);\n      metadata.set(POSIX.terms.size, `${size}`);\n    }\n\n    parent.entries[identifier.path] = {\n      data: dataArray,\n      metadata,\n    };\n  }\n\n  public async writeContainer(identifier: ResourceIdentifier, metadata: RepresentationMetadata): Promise<void> {\n    try {\n      // Overwrite existing metadata but keep children if container already exists\n      const entry = this.getEntry(identifier);\n      entry.metadata = metadata;\n    } catch (error: unknown) {\n      // Create new entry if it didn't exist yet\n      if (NotFoundHttpError.isInstance(error)) {\n        const parent = this.getParentEntry(identifier);\n        parent.entries[identifier.path] = {\n          entries: {},\n          metadata,\n        };\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  public async writeMetadata(identifier: ResourceIdentifier, metadata: RepresentationMetadata): Promise<void> {\n    const entry = this.getEntry(identifier);\n    entry.metadata = metadata;\n  }\n\n  public async deleteResource(identifier: ResourceIdentifier): Promise<void> {\n    const parent = this.getParentEntry(identifier);\n    if (!parent.entries[identifier.path]) {\n      throw new NotFoundHttpError();\n    }\n    delete parent.entries[identifier.path];\n  }\n\n  private isDataEntry(entry: CacheEntry): entry is DataEntry {\n    return Boolean((entry as DataEntry).data);\n  }\n\n  /**\n   * Generates an array of identifiers corresponding to the nested containers until the given identifier is reached.\n   * This does not verify if these identifiers actually exist.\n   */\n  private getHierarchy(identifier: ResourceIdentifier): ResourceIdentifier[] {\n    if (this.identifierStrategy.isRootContainer(identifier)) {\n      return [ identifier ];\n    }\n    const hierarchy = this.getHierarchy(this.identifierStrategy.getParentContainer(identifier));\n    hierarchy.push(identifier);\n    return hierarchy;\n  }\n\n  /**\n   * Returns the ContainerEntry corresponding to the parent container of the given identifier.\n   * Will throw 404 if the parent does not exist.\n   */\n  private getParentEntry(identifier: ResourceIdentifier): ContainerEntry {\n    // Casting is fine here as the parent should never be used as a real container\n    let parent: CacheEntry = this.store as ContainerEntry;\n    if (this.identifierStrategy.isRootContainer(identifier)) {\n      return parent;\n    }\n\n    const hierarchy = this.getHierarchy(this.identifierStrategy.getParentContainer(identifier));\n    for (const entry of hierarchy) {\n      parent = parent.entries[entry.path];\n      if (!parent) {\n        throw new NotFoundHttpError();\n      }\n      if (this.isDataEntry(parent)) {\n        throw new InternalServerError('Invalid path.');\n      }\n    }\n\n    return parent;\n  }\n\n  /**\n   * Returns the CacheEntry corresponding the given identifier.\n   * Will throw 404 if the resource does not exist.\n   */\n  private getEntry(identifier: ResourceIdentifier): CacheEntry {\n    const parent = this.getParentEntry(identifier);\n    const entry = parent.entries[identifier.path];\n    if (!entry) {\n      throw new NotFoundHttpError();\n    }\n    return entry;\n  }\n}\n"]}