{"version":3,"file":"BasicETagHandler.js","sourceRoot":"","sources":["../../../src/storage/conditions/BasicETagHandler.ts"],"names":[],"mappings":";;;AACA,0DAA6C;AAG7C;;;GAGG;AACH,MAAa,gBAAgB;IACpB,OAAO,CAAC,QAAgC;QAC7C,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,iBAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACjD,MAAM,EAAE,WAAW,EAAE,GAAG,QAAQ,CAAC;QACjC,IAAI,QAAQ,IAAI,WAAW,EAAE,CAAC;YAC5B,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACtC,OAAO,IAAI,IAAI,CAAC,OAAO,EAAE,IAAI,WAAW,GAAG,CAAC;QAC9C,CAAC;IACH,CAAC;IAEM,WAAW,CAAC,QAAgC,EAAE,IAAY,EAAE,MAAe;QAChF,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,iBAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACjD,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QACtC,MAAM,EAAE,WAAW,EAAE,GAAG,QAAQ,CAAC;QAEjC,+BAA+B;QAC/B,MAAM,CAAE,aAAa,EAAE,eAAe,CAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAExE,OAAO,aAAa,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,CAAC,MAAM,IAAI,eAAe,KAAK,WAAW,CAAC,CAAC;IAC/F,CAAC;IAEM,iBAAiB,CAAC,KAAa,EAAE,KAAa;QACnD,oDAAoD;QACpD,gEAAgE;QAChE,OAAO,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACrD,CAAC;CACF;AA7BD,4CA6BC","sourcesContent":["import type { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport { DC } from '../../util/Vocabularies';\nimport type { ETagHandler } from './ETagHandler';\n\n/**\n * Standard implementation of {@link ETagHandler}.\n * ETags are constructed by combining the last modified date with the content type of the representation.\n */\nexport class BasicETagHandler implements ETagHandler {\n  public getETag(metadata: RepresentationMetadata): string | undefined {\n    const modified = metadata.get(DC.terms.modified);\n    const { contentType } = metadata;\n    if (modified && contentType) {\n      const date = new Date(modified.value);\n      return `\"${date.getTime()}-${contentType}\"`;\n    }\n  }\n\n  public matchesETag(metadata: RepresentationMetadata, eTag: string, strict: boolean): boolean {\n    const modified = metadata.get(DC.terms.modified);\n    if (!modified) {\n      return false;\n    }\n    const date = new Date(modified.value);\n    const { contentType } = metadata;\n\n    // Slicing of the double quotes\n    const [ eTagTimestamp, eTagContentType ] = eTag.slice(1, -1).split('-');\n\n    return eTagTimestamp === `${date.getTime()}` && (!strict || eTagContentType === contentType);\n  }\n\n  public sameResourceState(eTag1: string, eTag2: string): boolean {\n    // Since we base the ETag on the last modified date,\n    // we know the ETags match as long as the date part is the same.\n    return eTag1.split('-')[0] === eTag2.split('-')[0];\n  }\n}\n"]}