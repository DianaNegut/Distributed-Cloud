{"version":3,"file":"ConstantConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/ConstantConverter.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Stats } from 'node:fs';\nimport { createReadStream } from 'node:fs';\nimport { stat } from 'fs-extra';\nimport { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { createErrorMessage } from '../../util/errors/ErrorUtil';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { isContainerIdentifier } from '../../util/PathUtil';\nimport { toLiteral } from '../../util/TermUtil';\nimport { POSIX, XSD } from '../../util/Vocabularies';\nimport { cleanPreferences, getTypeWeight, matchesMediaType } from './ConversionUtil';\nimport { RepresentationConverter } from './RepresentationConverter';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\n\n/**\n * Extra options for the ConstantConverter.\n */\nexport interface ConstantConverterOptions {\n  /**\n   * Whether this should trigger on containers.\n   */\n  container?: boolean;\n  /**\n   * Whether this should trigger on documents.\n   */\n  document?: boolean;\n  /**\n   * The minimum requested quality/preference before this should trigger.\n   */\n  minQuality?: number;\n  /**\n   * Media ranges for which the conversion should happen.\n   */\n  enabledMediaRanges?: string[];\n  /**\n   * Media ranges for which the conversion should not happen.\n   */\n  disabledMediaRanges?: string[];\n}\n\n/**\n * A {@link RepresentationConverter} that ensures\n * a representation for a certain content type is available.\n *\n * Representations of the same content type are served as is;\n * others are replaced by a constant document.\n *\n * This can for example be used to serve an index.html file,\n * which could then interactively load another representation.\n *\n * Options default to the most permissive values when not defined.\n */\nexport class ConstantConverter extends RepresentationConverter {\n  private readonly logger = getLoggerFor(this);\n\n  private readonly filePath: string;\n  private readonly contentType: string;\n  private readonly options: Required<ConstantConverterOptions>;\n\n  /**\n   * Creates a new constant converter.\n   *\n   * @param filePath - The path to the constant representation.\n   * @param contentType - The content type of the constant representation.\n   * @param options - Extra options for the converter.\n   */\n  public constructor(filePath: string, contentType: string, options: ConstantConverterOptions = {}) {\n    super();\n    this.filePath = filePath;\n    this.contentType = contentType;\n    this.options = {\n      container: options.container ?? true,\n      document: options.document ?? true,\n      minQuality: options.minQuality ?? 0,\n      enabledMediaRanges: options.enabledMediaRanges ?? [ '*/*' ],\n      disabledMediaRanges: options.disabledMediaRanges ?? [],\n    };\n  }\n\n  public async canHandle({ identifier, preferences, representation }: RepresentationConverterArgs): Promise<void> {\n    // Do not replace the representation if there is no preference for our content type\n    if (!preferences.type) {\n      throw new NotImplementedHttpError('No content type preferences specified');\n    }\n\n    // Do not replace the representation of unsupported resource types\n    const isContainer = isContainerIdentifier(identifier);\n    if (isContainer && !this.options.container) {\n      throw new NotImplementedHttpError('Containers are not supported');\n    }\n    if (!isContainer && !this.options.document) {\n      throw new NotImplementedHttpError('Documents are not supported');\n    }\n\n    // Do not replace the representation if the preference weight is too low\n    // eslint-disable-next-line ts/naming-convention\n    const quality = getTypeWeight(this.contentType, cleanPreferences({ ...preferences.type, '*/*': 0 }));\n    if (quality === 0) {\n      throw new NotImplementedHttpError(`No preference for ${this.contentType}`);\n    } else if (quality < this.options.minQuality) {\n      throw new NotImplementedHttpError(`Preference is lower than the specified minimum quality`);\n    }\n\n    const sourceContentType = representation.metadata.contentType ?? '';\n    // Do not replace the representation if it already has our content type\n    if (matchesMediaType(sourceContentType, this.contentType)) {\n      throw new NotImplementedHttpError(`Representation is already ${this.contentType}`);\n    }\n\n    // Only replace the representation if it matches the media range settings\n    if (!isContainer &&\n      !this.options.enabledMediaRanges.some((type): boolean => matchesMediaType(sourceContentType, type))) {\n      throw new NotImplementedHttpError(`${sourceContentType} is not one of the enabled media types.`);\n    }\n    if (!isContainer &&\n      this.options.disabledMediaRanges.some((type): boolean => matchesMediaType(sourceContentType, type))) {\n      throw new NotImplementedHttpError(`${sourceContentType} is one of the disabled media types.`);\n    }\n  }\n\n  public async handle({ representation }: RepresentationConverterArgs): Promise<Representation> {\n    // Ignore the original representation\n    representation.data.destroy();\n\n    // Get the stats to have the correct size metadata\n    let stats: Stats;\n    try {\n      stats = await stat(this.filePath);\n    } catch (error: unknown) {\n      this.logger.error(`Unable to access ${this.filePath}: ${createErrorMessage(error)}`);\n      // Not giving out details in error as it contains internal server information\n      throw new InternalServerError(`Unable to access file used for constant conversion.`);\n    }\n\n    // Create a new representation from the constant file\n    const data = createReadStream(this.filePath, 'utf8');\n    representation.metadata.set(POSIX.terms.size, toLiteral(stats.size, XSD.terms.integer));\n    return new BasicRepresentation(data, representation.metadata, this.contentType);\n  }\n}\n"]}