{"version":3,"file":"ConversionUtil.js","sourceRoot":"","sources":["../../../src/storage/conversion/ConversionUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import TTLCache from '@isaacs/ttlcache';\nimport fetch from 'cross-fetch';\nimport { readJsonSync } from 'fs-extra';\nimport type { IJsonLdContext } from 'jsonld-context-parser';\nimport { FetchDocumentLoader } from 'jsonld-context-parser';\nimport type { ValuePreference, ValuePreferences } from '../../http/representation/RepresentationPreferences';\nimport { INTERNAL_ALL } from '../../util/ContentTypes';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { resolveAssetPath } from '../../util/PathUtil';\n\n/**\n * First, checks whether a context is stored locally before letting the super class do a fetch.\n * This can be used when converting JSON-LD with Comunica-related libraries, such as `rdf-parse`.\n *\n * To use this, add this document loader to the options of the call\n * using the `KeysRdfParseJsonLd.documentLoader.name` key.\n * All extra keys get passed in the Comunica ActionContext\n * and this is the key that is used to define the document loader.\n * See https://github.com/rubensworks/rdf-parse.js/blob/master/lib/RdfParser.ts\n * and https://github.com/comunica/comunica/blob/master/packages/actor-rdf-parse-jsonld/lib/ActorRdfParseJsonLd.ts\n *\n * The loader has an internal cache that stores fetched documents for 30 minutes by default.\n * This is to prevent spamming a context URL in case there are many requests.\n * This cache can be disabled by setting the `ttl` to 0.\n */\nexport class ContextDocumentLoader extends FetchDocumentLoader {\n  private readonly contexts: Record<string, IJsonLdContext>;\n  private readonly cache?: TTLCache<string, IJsonLdContext>;\n\n  public constructor(contexts: Record<string, string>, ttl = 30 * 60 * 1000) {\n    super(fetch);\n    this.contexts = {};\n    for (const [ key, path ] of Object.entries(contexts)) {\n      this.contexts[key] = readJsonSync(resolveAssetPath(path)) as IJsonLdContext;\n    }\n    if (ttl > 0) {\n      this.cache = new TTLCache({ ttl, updateAgeOnGet: true });\n    }\n  }\n\n  public async load(url: string): Promise<IJsonLdContext> {\n    if (url in this.contexts) {\n      return this.contexts[url];\n    }\n    const cached = this.cache?.get(url);\n    if (cached) {\n      return cached;\n    }\n    const result = await super.load(url);\n\n    if (this.cache) {\n      this.cache.set(url, result);\n    }\n\n    return result;\n  }\n}\n\n/**\n * Cleans incoming preferences to prevent unwanted behaviour.\n * Makes sure internal types have weight 0, unless specifically requested in the preferences,\n * and interprets empty preferences as accepting everything.\n *\n * @param preferences - Preferences that need to be updated.\n *\n * @returns A copy of the preferences with the necessary updates.\n */\nexport function cleanPreferences(preferences: ValuePreferences = {}): ValuePreferences {\n  // No preference means anything is acceptable\n  const preferred = { ...preferences };\n  if (Object.keys(preferences).length === 0) {\n    preferred['*/*'] = 1;\n  }\n  // Prevent accidental use of internal types\n  if (!(INTERNAL_ALL in preferred)) {\n    preferred[INTERNAL_ALL] = 0;\n  }\n  return preferred;\n}\n\n/**\n * Tries to match the given type to the given preferences.\n * In case there are multiple matches the most specific one will be chosen as per RFC 7231.\n *\n * @param type - Type for which the matching weight is needed.\n * @param preferred - Preferences to match the type to.\n *\n * @returns The corresponding weight from the preferences or 0 if there is no match.\n */\nexport function getTypeWeight(type: string, preferred: ValuePreferences): number {\n  const match = /^([^/]+)\\/([^\\s;]+)/u.exec(type);\n  if (!match) {\n    throw new InternalServerError(`Unexpected media type: ${type}.`);\n  }\n  const [ , main, sub ] = match;\n  // RFC 7231\n  //    Media ranges can be overridden by more specific media ranges or\n  //    specific media types.  If more than one media range applies to a\n  //    given type, the most specific reference has precedence.\n  return preferred[type] ??\n    preferred[`${main}/${sub}`] ??\n    preferred[`${main}/*`] ??\n    preferred['*/*'] ??\n    0;\n}\n\n/**\n * Measures the weights for all the given types when matched against the given preferences.\n * Results will be sorted by weight.\n * Weights of 0 indicate that no match is possible.\n *\n * @param types - Types for which we want to calculate the weights.\n * @param preferred - Preferences to match the types against.\n *\n * @returns An array with a {@link ValuePreference} object for every input type, sorted by calculated weight.\n */\nexport function getWeightedPreferences(types: ValuePreferences, preferred: ValuePreferences): ValuePreference[] {\n  const weightedSupported = Object.entries(types)\n    .map(([ value, quality ]): ValuePreference => ({ value, weight: quality * getTypeWeight(value, preferred) }));\n  return weightedSupported\n    .sort(({ weight: weightA }, { weight: weightB }): number => weightB - weightA);\n}\n\n/**\n * Finds the type from the given types that has the best match with the given preferences,\n * based on the calculated weight.\n *\n * @param types - Types for which we want to find the best match.\n * @param preferred - Preferences to match the types against.\n *\n * @returns A {@link ValuePreference} containing the best match and the corresponding weight.\n * Undefined if there is no match.\n */\nexport function getBestPreference(types: ValuePreferences, preferred: ValuePreferences): ValuePreference | undefined {\n  // Could also return the first entry of `getWeightedPreferences` but this is more efficient\n  let best: ValuePreference = { value: '', weight: 0 };\n  for (const [ value, quality ] of Object.entries(types)) {\n    if (best.weight >= quality) {\n      continue;\n    }\n    const weight = quality * getTypeWeight(value, preferred);\n    if (weight > best.weight) {\n      best = { value, weight };\n    }\n  }\n\n  if (best.weight > 0) {\n    return best;\n  }\n}\n\n/**\n * For a media type converter that can generate the given types,\n * this function tries to find the type that best matches the given preferences.\n *\n * This function combines several other conversion utility functions\n * to determine what output a converter should generate:\n * it cleans the preferences with {@link cleanPreferences} to support empty preferences\n * and to prevent the accidental generation of internal types,\n * after which the best match gets found based on the weights.\n *\n * @param types - Media types that can be converted to.\n * @param preferred - Preferences for output type.\n *\n * @returns The best match. Undefined if there is no match.\n */\nexport function getConversionTarget(types: ValuePreferences, preferred: ValuePreferences = {}): string | undefined {\n  const cleaned = cleanPreferences(preferred);\n\n  return getBestPreference(types, cleaned)?.value;\n}\n\n/**\n * Checks if the given type matches the given preferences.\n *\n * @param type - Type to match.\n * @param preferred - Preferences to match against.\n */\nexport function matchesMediaPreferences(type: string, preferred?: ValuePreferences): boolean {\n  return getTypeWeight(type, cleanPreferences(preferred)) > 0;\n}\n\n/**\n * Checks whether the given two media types/ranges match each other.\n * Takes wildcards into account.\n *\n * @param mediaA - Media type to match.\n * @param mediaB - Media type to match.\n *\n * @returns True if the media type patterns can match each other.\n */\nexport function matchesMediaType(mediaA: string, mediaB: string): boolean {\n  if (mediaA === mediaB) {\n    return true;\n  }\n\n  const [ typeA, subTypeA ] = mediaA.split('/');\n  const [ typeB, subTypeB ] = mediaB.split('/');\n  if (typeA === '*' || typeB === '*') {\n    return true;\n  }\n  if (typeA !== typeB) {\n    return false;\n  }\n  if (subTypeA === '*' || subTypeB === '*') {\n    return true;\n  }\n  return subTypeA === subTypeB;\n}\n\n/**\n * Checks if the given content type is an internal content type such as internal/quads.\n * Response will be `false` if the input type is undefined.\n *\n * Do not use this for media ranges.\n *\n * @param contentType - Type to check.\n */\nexport function isInternalContentType(contentType?: string): boolean {\n  return typeof contentType !== 'undefined' && matchesMediaType(contentType, INTERNAL_ALL);\n}\n\n/**\n * Serializes a preferences object to a string for display purposes.\n *\n * @param preferences - Preferences to serialize\n */\nexport function preferencesToString(preferences: ValuePreferences): string {\n  return Object.entries(preferences)\n    .map(([ type, weight ]): string => `${type}:${weight}`)\n    .join(',');\n}\n"]}