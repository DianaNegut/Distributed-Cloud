{"version":3,"file":"ErrorToJsonConverter.js","sourceRoot":"","sources":["../../../src/storage/conversion/ErrorToJsonConverter.ts"],"names":[],"mappings":";;;AAAA,uFAAoF;AAEpF,0DAA2E;AAC3E,2DAAsD;AACtD,2DAAwD;AACxD,mEAAoE;AACpE,qEAAkE;AAClE,sDAAsD;AACtD,yFAAsF;AAGtF;;GAEG;AACH,MAAa,oBAAqB,SAAQ,mEAAgC;IACxE;QACE,KAAK,CAAC,6BAAc,EAAE,+BAAgB,CAAC,CAAC;IAC1C,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,cAAc,EAA+B;QACjE,MAAM,KAAK,GAAG,MAAM,IAAA,0BAAa,EAAC,cAAc,CAAC,IAAI,CAAc,CAAC;QAEpE,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAEvC,kCAAkC;QAClC,OAAO,IAAI,yCAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,cAAc,CAAC,QAAQ,EAAE,+BAAgB,CAAC,CAAC;IACpG,CAAC;IAEO,WAAW,CAAC,KAAc;QAChC,IAAI,CAAC,IAAA,mBAAO,EAAC,KAAK,CAAC,EAAE,CAAC;YACpB,2EAA2E;YAC3E,IAAI,CAAC;gBACH,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;YAC3C,CAAC;YAAC,MAAM,CAAC;gBACP,OAAO,EAAE,CAAC;YACZ,CAAC;QACH,CAAC;QAED,MAAM,MAAM,GAA4B;YACtC,IAAI,EAAE,KAAK,CAAC,IAAI;YAChB,OAAO,EAAE,KAAK,CAAC,OAAO;SACvB,CAAC;QAEF,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;YAChB,MAAM,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;QAC7B,CAAC;QAED,IAAI,CAAC,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;YACjC,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,MAAM,CAAC,UAAU,GAAG,KAAK,CAAC,UAAU,CAAC;QACrC,MAAM,CAAC,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC;QACnC,MAAM,CAAC,OAAO,GAAG,IAAA,iCAAiB,EAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAEnD,mDAAmD;QACnD,IAAI,+BAAc,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC;YACrC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,eAAe,CAAC,CAAC;QAC/C,CAAC;QAED,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;YAChB,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAC/C,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AApDD,oDAoDC","sourcesContent":["import { BasicRepresentation } from '../../http/representation/BasicRepresentation';\nimport type { Representation } from '../../http/representation/Representation';\nimport { APPLICATION_JSON, INTERNAL_ERROR } from '../../util/ContentTypes';\nimport { isError } from '../../util/errors/ErrorUtil';\nimport { HttpError } from '../../util/errors/HttpError';\nimport { extractErrorTerms } from '../../util/errors/HttpErrorUtil';\nimport { OAuthHttpError } from '../../util/errors/OAuthHttpError';\nimport { getSingleItem } from '../../util/StreamUtil';\nimport { BaseTypedRepresentationConverter } from './BaseTypedRepresentationConverter';\nimport type { RepresentationConverterArgs } from './RepresentationConverter';\n\n/**\n * Converts an Error object to JSON by copying its fields.\n */\nexport class ErrorToJsonConverter extends BaseTypedRepresentationConverter {\n  public constructor() {\n    super(INTERNAL_ERROR, APPLICATION_JSON);\n  }\n\n  public async handle({ representation }: RepresentationConverterArgs): Promise<Representation> {\n    const error = await getSingleItem(representation.data) as HttpError;\n\n    const result = this.errorToJson(error);\n\n    // Update the content-type to JSON\n    return new BasicRepresentation(JSON.stringify(result), representation.metadata, APPLICATION_JSON);\n  }\n\n  private errorToJson(error: unknown): unknown {\n    if (!isError(error)) {\n      // Try to see if we can make valid JSON, empty object if there is an error.\n      try {\n        return JSON.parse(JSON.stringify(error));\n      } catch {\n        return {};\n      }\n    }\n\n    const result: Record<string, unknown> = {\n      name: error.name,\n      message: error.message,\n    };\n\n    if (error.stack) {\n      result.stack = error.stack;\n    }\n\n    if (!HttpError.isInstance(error)) {\n      return result;\n    }\n\n    result.statusCode = error.statusCode;\n    result.errorCode = error.errorCode;\n    result.details = extractErrorTerms(error.metadata);\n\n    // OAuth errors responses require additional fields\n    if (OAuthHttpError.isInstance(error)) {\n      Object.assign(result, error.mandatoryFields);\n    }\n\n    if (error.cause) {\n      result.cause = this.errorToJson(error.cause);\n    }\n\n    return result;\n  }\n}\n"]}