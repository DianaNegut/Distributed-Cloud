{"version":3,"file":"IndexedStorage.js","sourceRoot":"","sources":["../../../src/storage/keyvalue/IndexedStorage.ts"],"names":[],"mappings":";;;AAAA;;GAEG;AACU,QAAA,YAAY,GAAG,IAAI,CAAC","sourcesContent":["/**\n * The key that needs to be present in all output results of {@link IndexedStorage}.\n */\nexport const INDEX_ID_KEY = 'id';\n\n/**\n * Used to define the value of a key in a type entry of a {@link IndexedStorage}.\n * Valid values are `\"string\"`, `\"boolean\"`, `\"number\"` and `\"id:TYPE\"`,\n * with TYPE being one of the types in the definition.\n * In the latter case this means that key points to an identifier of the specified type.\n * A `[]` can be appended to the type to indicate the value is an array.\n * A `?` can be appended to the type to indicate this key is optional.\n */\nexport type ValueTypeDescription<TType = string> =\n  `${('string' | 'boolean' | 'number' | (TType extends string ? `${typeof INDEX_ID_KEY}:${TType}` : never))}${\n  '[]' | ''}${'?' | ''}`;\n\n/**\n * Converts a {@link ValueTypeDescription} to the type it should be interpreted as.\n */\nexport type ValueType<T extends ValueTypeDescription> =\n  (T extends `${infer E extends ValueTypeDescription}[]${string}` ? ValueType<E>[] :\n    T extends `boolean${string}` ? boolean : T extends `number${string}` ? number : string) |\n    (T extends `${string}?` ? undefined : never);\n\n/**\n * Used to filter on optional keys in a {@link IndexedStorage} definition.\n */\nexport type OptionalKey<T> = {[K in keyof T ]: T[K] extends `${string}?` ? K : never }[keyof T];\n\n/**\n * Converts a key/value object type description with {@link ValueTypeDescription} values\n * to the corresponding JS type.\n * E.g., { key: 'boolean?' } becomes { key?: boolean }.\n */\nexport type IndexObject<TDesc extends Record<string, ValueTypeDescription>> = {\n  -readonly [K in Exclude<keyof TDesc, OptionalKey<TDesc>>]: ValueType<TDesc[K]>;\n} & {\n  -readonly [K in keyof TDesc]?: ValueType<TDesc[K]>;\n};\n\n/**\n * Converts a {@link IndexedStorage} definition of a specific type\n * to the typing an object would have that is returned as an output on function calls.\n * Makes sure the required `id` parameter is always present.\n */\nexport type TypeObject<TDesc extends Record<string, ValueTypeDescription>> =\n  IndexObject<TDesc> & { [INDEX_ID_KEY]: string };\n\n/**\n * Input expected for `create()` call in {@link IndexedStorage}.\n * This is the same as {@link TypeObject} but without the index key.\n */\nexport type CreateTypeObject<T extends Record<string, ValueTypeDescription>> = Omit<TypeObject<T>, typeof INDEX_ID_KEY>;\n\n/**\n * Key of an object that is also a string.\n */\nexport type StringKey<T> = keyof T & string;\n\n/**\n * The description of a single type in an {@link IndexedStorage}.\n */\nexport type IndexTypeDescription<TType = never> = Record<string, ValueTypeDescription<TType>>;\n\n/**\n * The full description of all the types of an {@link IndexedStorage}.\n */\nexport type IndexTypeCollection<T> = Record<string, IndexTypeDescription<keyof T>>;\n\n// This is necessary to prevent infinite recursion in types\ntype Prev = [never, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...0[]];\n\n/**\n *  Object that represents a valid query starting from a specific type on an {@link IndexedStorage}.\n *  The keys of the object need to be one or more keys from the starting type,\n *  with the values being corresponding valid values of an object of that type.\n *  If the value definition of a key is one that contains the identifier of a different type,\n *  the value in the query can also be a nested object that has the same IndexedQuery requirements for that type.\n *  This can be done recursively.\n *\n *  E.g., if the storage has the following definition:\n *```ts\n *  {\n *    account: {},\n *    pod: { baseUrl: 'string', account: 'id:account' },\n *    pod: { owner: 'string', pod: 'id:pod' },\n *  }\n *```\n * A valid query on the `pod` type could be `{ pod: '123456' }`,\n * but also `{ pod: { baseUrl: 'http://example.com/pod/', account: { id: '789' }}}`.\n */\nexport type IndexedQuery<T extends IndexTypeCollection<T>, TType extends keyof T, TDepth extends number = 10> =\n  [TDepth] extends [never] ? never :\n      {[K in keyof T[TType] | typeof INDEX_ID_KEY]?:\n        ValueType<T[TType][K]> |\n        (T[TType][K] extends `${typeof INDEX_ID_KEY}:${infer U}` ? IndexedQuery<T, U, Prev[TDepth]> : never)\n      };\n\n/**\n * A storage solution that allows for more complex queries than a key/value storage\n * and allows setting indexes on specific keys.\n */\nexport interface IndexedStorage<T extends IndexTypeCollection<T>> {\n  /**\n   * Informs the storage of the definition of a specific type.\n   * A definition is a key/value object with the values being a valid {@link ValueTypeDescription}.\n   * Generally, this call needs to happen for every type of this storage,\n   * and before any calls are made to interact with the data.\n   *\n   * @param type - The type to define.\n   * @param description - A description of the values stored in objects of that type.\n   */\n  defineType: <TType extends StringKey<T>>(type: TType, description: T[TType]) => Promise<void>;\n\n  /**\n   * Creates an index on a key of the given type, to allow for better queries involving those keys.\n   * Similar to {@link IndexedStorage.defineType} these calls need to happen first.\n   *\n   * @param type - The type to create an index on.\n   * @param key - The key of that type to create an index on.\n   */\n  createIndex: <TType extends StringKey<T>>(type: TType, key: StringKey<T[TType]>) => Promise<void>;\n\n  /**\n   * Creates an object of the given type.\n   * The storage will generate an identifier for the newly created object.\n   *\n   * @param type - The type to create.\n   * @param value - The value to set for the created object.\n   *\n   * @returns A representation of the newly created object, including its new identifier.\n   */\n  create: <TType extends StringKey<T>>(type: TType, value: CreateTypeObject<T[TType]>) => Promise<TypeObject<T[TType]>>;\n\n  /**\n   * Returns `true` if the object of the given type with the given identifier exists.\n   *\n   * @param type - The type of object to get.\n   * @param id - The identifier of that object.\n   *\n   * @returns Whether this object exists.\n   */\n  has: <TType extends StringKey<T>>(type: TType, id: string) => Promise<boolean>;\n\n  /**\n   * Returns the object of the given type with the given identifier.\n   *\n   * @param type - The type of object to get.\n   * @param id - The identifier of that object.\n   *\n   * @returns A representation of the object, or `undefined` if there is no object of that type with that identifier.\n   */\n  get: <TType extends StringKey<T>>(type: TType, id: string) => Promise<TypeObject<T[TType]> | undefined>;\n\n  /**\n   * Finds all objects matching a specific {@link IndexedQuery}.\n   *\n   * @param type - The type of objects to find.\n   * @param query - The query to execute.\n   *\n   * @returns A list of objects matching the query.\n   */\n  find: <TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>) => Promise<(TypeObject<T[TType]>)[]>;\n\n  /**\n   * Similar to {@link IndexedStorage.find}, but only returns the identifiers of the found objects.\n   *\n   * @param type - The type of objects to find.\n   * @param query - The query to execute.\n   *\n   * @returns A list of identifiers of the matching objects.\n   */\n  findIds: <TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>) => Promise<string[]>;\n\n  /**\n   * Sets the value of a specific object.\n   * The identifier in the object is used to identify the object.\n   *\n   * @param type - The type of the object to set.\n   * @param value - The new value for the object.\n   */\n  set: <TType extends StringKey<T>>(type: TType, value: TypeObject<T[TType]>) => Promise<void>;\n\n  /**\n   * Sets the value of one specific field in an object.\n   *\n   * @param type - The type of the object to update.\n   * @param id - The identifier of the object to update.\n   * @param key - The key to update.\n   * @param value - The new value for the given key.\n   */\n  setField: <TType extends StringKey<T>, TKey extends StringKey<T[TType]>>(\n    type: TType, id: string, key: TKey, value: ValueType<T[TType][TKey]>) => Promise<void>;\n\n  /**\n   * Deletes the given object.\n   * This will also delete all objects that reference that object if the corresponding key is not optional.\n   *\n   * @param type - The type of the object to delete.\n   * @param id - The identifier of the object.\n   */\n  delete: <TType extends StringKey<T>>(type: TType, id: string) => Promise<void>;\n\n  /**\n   * Returns an iterator over all objects of the given type.\n   *\n   * @param type - The type to iterate over.\n   */\n  entries: <TType extends StringKey<T>>(type: TType) => AsyncIterableIterator<TypeObject<T[TType]>>;\n}\n"]}