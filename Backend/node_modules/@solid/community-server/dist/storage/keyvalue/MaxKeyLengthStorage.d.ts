import type { KeyValueStorage } from './KeyValueStorage';
type Entry<T> = {
    key: string;
    payload: T;
};
/**
 * A {@link KeyValueStorage} that hashes keys in case they would be longer than the set limit.
 * Hashed keys are prefixed with a certain value to prevent issues with incoming keys that are already hashed.
 * The default max length is 150 and the default prefix is `$hash$`.
 *
 * This class mostly exists to prevent issues when writing storage entries to disk.
 * Keys that are too long would cause issues with the file name limit.
 * For this reason, only the part after the last `/` in a key is hashed, to preserve the expected file structure.
 */
export declare class MaxKeyLengthStorage<T> implements KeyValueStorage<string, T> {
    protected readonly logger: import("../..").Logger;
    protected readonly source: KeyValueStorage<string, Entry<T>>;
    protected readonly maxKeyLength: number;
    protected readonly hashPrefix: string;
    constructor(source: KeyValueStorage<string, Entry<T>>, maxKeyLength?: number, hashPrefix?: string);
    has(key: string): Promise<boolean>;
    get(key: string): Promise<T | undefined>;
    set(key: string, value: T): Promise<this>;
    delete(key: string): Promise<boolean>;
    entries(): AsyncIterableIterator<[string, T]>;
    protected wrapPayload(key: string, payload: T): Entry<T>;
    /**
     * Similar to `getKey` but checks to make sure the key does not already contain the prefix.
     * Only necessary for `set` calls.
     */
    protected getKeyWithCheck(key: string): string;
    /**
     * Hashes the last part of the key if it is too long.
     * Otherwise, just returns the key.
     */
    protected getKey(key: string, parts?: string[]): string;
}
export {};
