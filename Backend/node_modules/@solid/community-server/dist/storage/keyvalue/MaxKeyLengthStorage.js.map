{"version":3,"file":"MaxKeyLengthStorage.js","sourceRoot":"","sources":["../../../src/storage/keyvalue/MaxKeyLengthStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { createHash } from 'node:crypto';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport type { KeyValueStorage } from './KeyValueStorage';\n\ntype Entry<T> = {\n  key: string;\n  payload: T;\n};\n\n/**\n * A {@link KeyValueStorage} that hashes keys in case they would be longer than the set limit.\n * Hashed keys are prefixed with a certain value to prevent issues with incoming keys that are already hashed.\n * The default max length is 150 and the default prefix is `$hash$`.\n *\n * This class mostly exists to prevent issues when writing storage entries to disk.\n * Keys that are too long would cause issues with the file name limit.\n * For this reason, only the part after the last `/` in a key is hashed, to preserve the expected file structure.\n */\nexport class MaxKeyLengthStorage<T> implements KeyValueStorage<string, T> {\n  protected readonly logger = getLoggerFor(this);\n\n  protected readonly source: KeyValueStorage<string, Entry<T>>;\n  protected readonly maxKeyLength: number;\n  protected readonly hashPrefix: string;\n\n  public constructor(source: KeyValueStorage<string, Entry<T>>, maxKeyLength = 150, hashPrefix = '$hash$') {\n    this.source = source;\n    this.maxKeyLength = maxKeyLength;\n    this.hashPrefix = hashPrefix;\n  }\n\n  public async has(key: string): Promise<boolean> {\n    return this.source.has(this.getKey(key));\n  }\n\n  public async get(key: string): Promise<T | undefined> {\n    return (await this.source.get(this.getKey(key)))?.payload;\n  }\n\n  public async set(key: string, value: T): Promise<this> {\n    await this.source.set(this.getKeyWithCheck(key), this.wrapPayload(key, value));\n    return this;\n  }\n\n  public async delete(key: string): Promise<boolean> {\n    return this.source.delete(this.getKey(key));\n  }\n\n  public async* entries(): AsyncIterableIterator<[string, T]> {\n    for await (const [ , val ] of this.source.entries()) {\n      yield [ val.key, val.payload ];\n    }\n  }\n\n  protected wrapPayload(key: string, payload: T): Entry<T> {\n    return { key, payload };\n  }\n\n  /**\n   * Similar to `getKey` but checks to make sure the key does not already contain the prefix.\n   * Only necessary for `set` calls.\n   */\n  protected getKeyWithCheck(key: string): string {\n    const parts = key.split('/');\n\n    // Prevent non-hashed keys with the prefix to prevent false hits\n    if (parts.at(-1)?.startsWith(this.hashPrefix)) {\n      throw new NotImplementedHttpError(`Unable to store keys starting with ${this.hashPrefix}`);\n    }\n\n    return this.getKey(key, parts);\n  }\n\n  /**\n   * Hashes the last part of the key if it is too long.\n   * Otherwise, just returns the key.\n   */\n  protected getKey(key: string, parts?: string[]): string {\n    if (key.length <= this.maxKeyLength) {\n      return key;\n    }\n\n    // Hash the key if it is too long\n    parts = parts ?? key.split('/');\n    const last = parts.length - 1;\n    parts[last] = `${this.hashPrefix}${createHash('sha256').update(parts[last]).digest('hex')}`;\n    const newKey = parts.join('/');\n    this.logger.debug(`Hashing key ${key} to ${newKey}`);\n    return newKey;\n  }\n}\n"]}