{"version":3,"file":"PassthroughKeyValueStorage.js","sourceRoot":"","sources":["../../../src/storage/keyvalue/PassthroughKeyValueStorage.ts"],"names":[],"mappings":";;;AAEA;;;;GAIG;AACH,MAAsB,0BAA0B;IAC3B,MAAM,CAAgC;IAEzD,YAAsB,MAAqC;QACzD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,GAAW;QAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChC,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,GAAW;QAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChC,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,GAAW,EAAE,KAAW;QACvC,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChC,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QACnC,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,GAAW;QAC7B,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAEM,KAAK,CAAA,CAAE,OAAO;QACnB,IAAI,KAAK,EAAE,MAAM,CAAE,IAAI,EAAE,KAAK,CAAE,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;YAC1D,MAAM,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YACrC,MAAM,CAAE,GAAG,EAAE,KAAK,CAAE,CAAC;QACvB,CAAC;IACH,CAAC;CAmBF;AApDD,gEAoDC","sourcesContent":["import type { KeyValueStorage } from './KeyValueStorage';\n\n/**\n * Abstract class to create a {@link KeyValueStorage} by wrapping around another one.\n *\n * Exposes abstract functions to modify the key before passing it to the the source storage.\n */\nexport abstract class PassthroughKeyValueStorage<TVal> implements KeyValueStorage<string, TVal> {\n  protected readonly source: KeyValueStorage<string, TVal>;\n\n  protected constructor(source: KeyValueStorage<string, TVal>) {\n    this.source = source;\n  }\n\n  public async get(key: string): Promise<TVal | undefined> {\n    const path = this.toNewKey(key);\n    return this.source.get(path);\n  }\n\n  public async has(key: string): Promise<boolean> {\n    const path = this.toNewKey(key);\n    return this.source.has(path);\n  }\n\n  public async set(key: string, value: TVal): Promise<this> {\n    const path = this.toNewKey(key);\n    await this.source.set(path, value);\n    return this;\n  }\n\n  public async delete(key: string): Promise<boolean> {\n    const path = this.toNewKey(key);\n    return this.source.delete(path);\n  }\n\n  public async* entries(): AsyncIterableIterator<[string, TVal]> {\n    for await (const [ path, value ] of this.source.entries()) {\n      const key = this.toOriginalKey(path);\n      yield [ key, value ];\n    }\n  }\n\n  /**\n   * This function will be called on the input key and used as a new key when calling the source.\n   *\n   * @param key - Original input key.\n   *\n   * @returns A new key to use with the source storage.\n   */\n  protected abstract toNewKey(key: string): string;\n\n  /**\n   * This function is used when calling `entries()` to revert the key generated by `toNewKey()`.\n   *\n   * @param key - A key generated by `toNewKey()`\n   *\n   * @returns The original key.\n   */\n  protected abstract toOriginalKey(key: string): string;\n}\n"]}