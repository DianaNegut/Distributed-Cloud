{"version":3,"file":"WrappedIndexedStorage.js","sourceRoot":"","sources":["../../../src/storage/keyvalue/WrappedIndexedStorage.ts"],"names":[],"mappings":"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","sourcesContent":["import { v4 } from 'uuid';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { InternalServerError } from '../../util/errors/InternalServerError';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport { NotImplementedHttpError } from '../../util/errors/NotImplementedHttpError';\nimport { INDEX_ID_KEY } from './IndexedStorage';\nimport type {\n  CreateTypeObject,\n  IndexedQuery,\n  IndexedStorage,\n  IndexTypeCollection,\n  StringKey,\n  TypeObject,\n  ValueType,\n} from './IndexedStorage';\nimport type { KeyValueStorage } from './KeyValueStorage';\n\n/**\n * Key used to link to child objects in a {@link WrappedIndexedStorage}.\n */\nexport type VirtualKey<TChild> = TChild extends string ? `**${TChild}**` : never;\n\n/**\n * Object stored in the wrapped {@link KeyValueStorage} in a {@link WrappedIndexedStorage}.\n */\nexport type VirtualObject = {\n  [key: VirtualKey<string>]: Record<string, VirtualObject>;\n  [key: string]: unknown;\n  [INDEX_ID_KEY]: string;\n};\n\n/**\n * A parent/child relation description in a {@link WrappedIndexedStorage}.\n */\nexport type IndexRelation<TTypes> = {\n  parent: { key: VirtualKey<string>; type: StringKey<TTypes> };\n  child: { key: string; type: StringKey<TTypes> };\n};\n\n/**\n * An {@link IndexedStorage} that makes use of 2 {@link KeyValueStorage}s to implement the interface.\n * Due to being limited by key/value storages, there are some restrictions on the allowed type definitions:\n *\n *   * There needs to be exactly 1 type with no references to other types.\n *   * All other types need to have exactly 1 reference to another type.\n *   * Types can't reference each other to create a cycle of references.\n *\n * All of the above to create a tree-like structure of references.\n * Such a tree is then stored in one of the storages.\n * The other storage is used to store all indexes that are used to find the correct tree object when solving queries.\n */\nexport class WrappedIndexedStorage<T extends IndexTypeCollection<T>> implements IndexedStorage<T> {\n  protected readonly logger = getLoggerFor(this);\n\n  private readonly valueStorage: KeyValueStorage<string, VirtualObject>;\n  private readonly indexStorage: KeyValueStorage<string, string[]>;\n\n  /**\n   * For every type, the keys on which an index tracks the values and which root object they are contained in.\n   * All types for which a `defineType` call was made will have a key in this object.\n   * For all types that are not the root, there will always be an index on their ID value.\n   */\n  private readonly indexes: {[K in StringKey<T>]?: Set<StringKey<T[K]>> };\n\n  /**\n   * Keeps track of type validation.\n   * If true the defined types create a valid structure that can be used.\n   */\n  private validDefinition = false;\n\n  /**\n   * The variable in which the root type is stored.\n   * A separate getter is used to always return the value\n   * so the potential `undefined` does not have to be taken into account.\n   */\n  private rootTypeVar: StringKey<T> | undefined;\n\n  /**\n   * All parent/child relations between all types in the storage,\n   * including the keys in both types that are used to reference each other.\n   */\n  private readonly relations: IndexRelation<T>[];\n\n  public constructor(\n    valueStorage: KeyValueStorage<string, VirtualObject>,\n    indexStorage: KeyValueStorage<string, string[]>,\n  ) {\n    this.valueStorage = valueStorage;\n    this.indexStorage = indexStorage;\n    this.indexes = {};\n    this.relations = [];\n  }\n\n  public async defineType<TType extends StringKey<T>>(type: TType, description: T[TType]): Promise<void> {\n    if (this.rootTypeVar) {\n      this.logger.error(`Trying to define new type \"${type}\" after types were already validated.`);\n      throw new InternalServerError(`Trying to define new type \"${type}\" after types were already validated.`);\n    }\n\n    this.validDefinition = false;\n    let hasParentKey = false;\n    for (const [ key, desc ] of Object.entries(description)) {\n      if (desc.startsWith(`${INDEX_ID_KEY}:`)) {\n        if (hasParentKey) {\n          this.logger.error(`Type definition of ${type} has multiple references, only 1 is allowed.`);\n          throw new InternalServerError(`Type definition of ${type} has multiple references, only 1 is allowed.`);\n        }\n        if (desc.endsWith('[]')) {\n          this.logger.error(`Type definition of ${type} has array references, which is not allowed.`);\n          throw new InternalServerError(`Type definition of ${type} has array references, which is not allowed.`);\n        }\n        if (desc.endsWith('?')) {\n          this.logger.error(`Type definition of ${type} has optional references, which is not allowed.`);\n          throw new InternalServerError(`Type definition of ${type} has optional references, which is not allowed.`);\n        }\n        hasParentKey = true;\n        this.relations.push({\n          parent: { type: desc.slice(INDEX_ID_KEY.length + 1), key: `**${type}**` },\n          child: { type, key },\n        });\n      }\n    }\n    this.indexes[type] = new Set([ INDEX_ID_KEY ]);\n  }\n\n  public async createIndex<TType extends StringKey<T>>(type: TType, key: StringKey<T[TType]>): Promise<void> {\n    // An index on the key targeting the parent is the same as having an index on the identifier of that parent.\n    // Such an index gets created automatically when the type is defined so this can now be ignored.\n    if (key === this.getParentRelation(type)?.child.key) {\n      return;\n    }\n    const typeIndexes = this.indexes[type];\n    if (!typeIndexes) {\n      this.logger.error(`Trying to create index on key ${key} of undefined type ${type}`);\n      throw new InternalServerError(`Trying to create index on key ${key} of undefined type ${type}`);\n    }\n    typeIndexes.add(key);\n  }\n\n  public async has<TType extends StringKey<T>>(type: TType, id: string): Promise<boolean> {\n    this.validateDefinition(type);\n    if (type === this.rootType) {\n      return this.valueStorage.has(id);\n    }\n    const result = await this.find(type, { [INDEX_ID_KEY]: id } as IndexedQuery<T, TType>);\n    return result.length > 0;\n  }\n\n  public async get<TType extends StringKey<T>>(type: TType, id: string): Promise<TypeObject<T[TType]> | undefined> {\n    this.validateDefinition(type);\n    const result = await this.find(type, { [INDEX_ID_KEY]: id } as IndexedQuery<T, TType>);\n    if (result.length === 0) {\n      return;\n    }\n    return result[0];\n  }\n\n  public async create<TType extends StringKey<T>>(type: TType, value: CreateTypeObject<T[TType]>):\n  Promise<TypeObject<T[TType]>> {\n    this.validateDefinition(type);\n    const id = v4();\n    const newObj = { ...value, [INDEX_ID_KEY]: id } as unknown as VirtualObject;\n    // Add the virtual keys\n    for (const relation of this.getChildRelations(type)) {\n      newObj[relation.parent.key] = {};\n    }\n\n    const relation = this.getParentRelation(type);\n\n    // No parent relation implies that this is the root type\n    if (!relation) {\n      await this.valueStorage.set(id, newObj);\n      await this.updateTypeIndex(type, id, undefined, newObj);\n      return this.toTypeObject(type, newObj);\n    }\n\n    // We know this will be a string due to the typing requirements and how the relations object is built\n    const parentId = newObj[relation.child.key] as string;\n    const root = await this.getRoot(relation.parent.type, parentId);\n    if (!root) {\n      throw new NotFoundHttpError(`Unknown object of type ${relation.parent.type} with ID ${parentId}`);\n    }\n    const parentObj = relation.parent.type === this.rootType ?\n      root :\n      this.getContainingRecord(root, relation.parent.type, parentId)[parentId];\n    // Parent relation key could be undefined if the index structure changed\n    if (!parentObj[relation.parent.key]) {\n      parentObj[relation.parent.key] = {};\n    }\n    parentObj[relation.parent.key][id] = newObj;\n\n    await this.valueStorage.set(root[INDEX_ID_KEY], root);\n    await this.updateTypeIndex(type, root[INDEX_ID_KEY], undefined, newObj);\n\n    return this.toTypeObject(type, newObj);\n  }\n\n  public async set<TType extends StringKey<T>>(type: TType, value: TypeObject<T[TType]>): Promise<void> {\n    this.validateDefinition(type);\n    return this.updateValue(type, value, true);\n  }\n\n  public async setField<TType extends StringKey<T>, TKey extends StringKey<T[TType]>>(\n    type: TType,\n    id: string,\n    key: TKey,\n    value: ValueType<T[TType][TKey]>,\n  ): Promise<void> {\n    this.validateDefinition(type);\n    return this.updateValue(\n      type,\n      { [INDEX_ID_KEY]: id, [key]: value } as Partial<TypeObject<T[TType]>> & { [INDEX_ID_KEY]: string },\n      false,\n    );\n  }\n\n  public async delete<TType extends StringKey<T>>(type: TType, id: string): Promise<void> {\n    this.validateDefinition(type);\n    const root = await this.getRoot(type, id);\n    if (!root) {\n      return;\n    }\n\n    let oldObj: VirtualObject;\n    if (type === this.rootType) {\n      oldObj = root;\n      await this.valueStorage.delete(id);\n    } else {\n      const objs = this.getContainingRecord(root, type, id);\n      oldObj = objs[id];\n      delete objs[id];\n      await this.valueStorage.set(root[INDEX_ID_KEY], root);\n    }\n\n    // Updating index of removed type and all children as those are also gone\n    await this.updateDeepTypeIndex(type, root[INDEX_ID_KEY], oldObj);\n  }\n\n  public async findIds<TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>): Promise<string[]> {\n    this.validateDefinition(type);\n    if (type === this.rootType) {\n      // Root IDs are the only ones we can get more efficiently.\n      // For all other types we have to find the full objects anyway.\n      const indexedRoots = await this.findIndexedRoots(type, query);\n      if (!Array.isArray(indexedRoots)) {\n        this.logger.error(`Attempting to execute query without index: ${JSON.stringify(query)}`);\n        throw new InternalServerError(`Attempting to execute query without index: ${JSON.stringify(query)}`);\n      }\n      return indexedRoots;\n    }\n    return (await this.solveQuery(type, query)).map((result): string => result.id);\n  }\n\n  public async find<TType extends StringKey<T>>(type: TType, query: IndexedQuery<T, TType>):\n  Promise<(TypeObject<T[TType]>)[]> {\n    this.validateDefinition(type);\n    return (await this.solveQuery(type, query)).map((result): TypeObject<T[TType]> => this.toTypeObject(type, result));\n  }\n\n  public async* entries<TType extends StringKey<T>>(type: TType): AsyncIterableIterator<TypeObject<T[TType]>> {\n    this.validateDefinition(type);\n    const path = this.getPathToType(type);\n    for await (const [ , root ] of this.valueStorage.entries()) {\n      const children = this.getChildObjects(root, path);\n      yield* children.map((child): TypeObject<T[TType]> => this.toTypeObject(type, child));\n    }\n  }\n\n  // --------------------------------- OUTPUT HELPERS ---------------------------------\n\n  /**\n   * Converts a {@link VirtualObject} into a {@link TypeObject}.\n   * To be used when outputting results.\n   */\n  protected toTypeObject<TType extends StringKey<T>>(type: TType, obj: VirtualObject): TypeObject<T[TType]> {\n    const result = { ...obj };\n    for (const relation of this.getChildRelations(type)) {\n      delete result[relation.parent.key];\n    }\n    return result as unknown as TypeObject<T[TType]>;\n  }\n\n  // --------------------------------- ROOT HELPERS ---------------------------------\n\n  /**\n   * The root type for this storage.\n   * Use this instead of rootTypeVar to prevent having to check for `undefined`.\n   * This value will always be defined if the type definitions have been validated.\n   */\n  protected get rootType(): string {\n    return this.rootTypeVar!;\n  }\n\n  /**\n   * Finds the root object that contains the requested type/id combination.\n   */\n  protected async getRoot<TType extends StringKey<T>>(type: TType, id: string): Promise<VirtualObject | undefined> {\n    let rootId: string;\n    if (type === this.rootType) {\n      rootId = id;\n    } else {\n      // We know there always is an index on the identifier key\n      const indexKey = this.getIndexKey(type, INDEX_ID_KEY, id);\n      const indexResult = await this.indexStorage.get(indexKey);\n      if (!indexResult || indexResult.length !== 1) {\n        return;\n      }\n      rootId = indexResult[0];\n    }\n    return this.valueStorage.get(rootId);\n  }\n\n  // --------------------------------- PATH HELPERS ---------------------------------\n\n  /**\n   * Returns the sequence of virtual keys that need to be accessed to reach the given type, starting from the root.\n   */\n  protected getPathToType(type: string): VirtualKey<string>[] {\n    const result: VirtualKey<string>[] = [];\n    let relation = this.getParentRelation(type);\n    while (relation) {\n      result.unshift(relation.parent.key);\n      relation = this.getParentRelation(relation.parent.type);\n    }\n    return result;\n  }\n\n  /**\n   * Finds all records that can be found in the given object by following the given path of virtual keys.\n   */\n  protected getPathRecords(obj: VirtualObject, path: VirtualKey<string>[]): Record<string, VirtualObject>[] {\n    const record = obj[path[0]];\n    if (!record) {\n      // Can occur if virtual keys are missing due to the index structure changing\n      return [];\n    }\n    if (path.length === 1) {\n      return [ record ];\n    }\n    const subPath = path.slice(1);\n    return Object.values(record)\n      .flatMap((child): Record<string, VirtualObject>[] => this.getPathRecords(child, subPath));\n  }\n\n  /**\n   * Finds all objects in the provided object that can be found by following the provided path of virtual keys.\n   */\n  protected getChildObjects(obj: VirtualObject, path: VirtualKey<string>[]): VirtualObject[] {\n    if (path.length === 0) {\n      return [ obj ];\n    }\n    return this.getPathRecords(obj, path).flatMap((record): VirtualObject[] => Object.values(record));\n  }\n\n  /**\n   * Finds the record in the given object that contains the given type/id combination.\n   * This function assumes it was already verified through an index that this object contains the given combination.\n   */\n  protected getContainingRecord<TType extends StringKey<T>>(rootObj: VirtualObject, type: TType, id: string):\n  Record<string, VirtualObject> {\n    const path = this.getPathToType(type);\n    const records = this.getPathRecords(rootObj, path);\n    const match = records.find((record): boolean => Boolean(record[id]));\n    if (!match) {\n      this.logger.error(`Could not find ${type} ${id} in ${this.rootType} ${rootObj.id}`);\n      throw new InternalServerError(`Could not find ${type} ${id} in ${this.rootType} ${rootObj.id}`);\n    }\n    return match;\n  }\n\n  // --------------------------------- UPDATE VALUE HELPERS ---------------------------------\n\n  /**\n   * Replaces an object of the given type.\n   * The identifier in the value is used to determine which object.\n   */\n  protected updateValue<TType extends StringKey<T>>(type: TType, value: TypeObject<T[TType]>, replace: true):\n  Promise<void>;\n\n  /**\n   * Replaces part of an object of the given type with the given partial value.\n   * The identifier in the value is used to determine which object.\n   */\n  protected updateValue<TType extends StringKey<T>>(type: TType,\n    partial: Partial<TypeObject<T[TType]>> & { [INDEX_ID_KEY]: string }, replace: false): Promise<void>;\n\n  protected async updateValue<TType extends StringKey<T>>(\n    type: TType,\n    partial: Partial<TypeObject<T[TType]>> & { [INDEX_ID_KEY]: string },\n    replace: boolean,\n  ): Promise<void> {\n    const id = partial[INDEX_ID_KEY];\n    let root = await this.getRoot(type, id);\n    if (!root) {\n      throw new NotFoundHttpError(`Unknown object of type ${type} with ID ${id}`);\n    }\n\n    let oldObj: VirtualObject;\n    let newObj: VirtualObject;\n    const relation = this.getParentRelation(type);\n    if (relation) {\n      const objs = this.getContainingRecord(root, type, id);\n      if (partial[relation.child.key] && objs[id][relation.child.key] !== partial[relation.child.key]) {\n        this.logger.error(\n          `Trying to modify reference key ${objs[id][relation.child.key] as string} on \"${type}\" ${id}`,\n        );\n        throw new NotImplementedHttpError('Changing reference keys of existing objects is not supported.');\n      }\n      oldObj = objs[id];\n      newObj = (replace ? { ...partial } : { ...oldObj, ...partial }) as VirtualObject;\n      objs[id] = newObj;\n    } else {\n      oldObj = root;\n      newObj = (replace ? { ...partial } : { ...oldObj, ...partial }) as VirtualObject;\n      root = newObj;\n    }\n\n    // Copy over the child relations\n    for (const childRelation of this.getChildRelations(type)) {\n      newObj[childRelation.parent.key] = oldObj[childRelation.parent.key];\n    }\n    await this.valueStorage.set(root[INDEX_ID_KEY], root);\n    await this.updateTypeIndex(type, root[INDEX_ID_KEY], oldObj, newObj);\n  }\n\n  // --------------------------------- TYPE HELPERS ---------------------------------\n\n  /**\n   * Returns all relations where the given type is the parent.\n   */\n  protected getChildRelations<TType extends StringKey<T>>(type: TType): IndexRelation<T>[] {\n    return this.relations.filter((relation): boolean => relation.parent.type === type);\n  }\n\n  /**\n   * Returns the relation where the given type is the child.\n   * Will return `undefined` for the root type as that one doesn't have a parent.\n   */\n  protected getParentRelation<TType extends StringKey<T>>(type: TType): IndexRelation<T> | undefined {\n    return this.relations.find((relation): boolean => relation.child.type === type);\n  }\n\n  /**\n   * Makes sure the defined types fulfill all the requirements necessary for types on this storage.\n   * Will throw an error if this is not the case.\n   * This should be called before doing any data interactions.\n   * Stores success in a variable so future calls are instantaneous.\n   */\n  protected validateDefinition(type: string): void {\n    // We can't know if all types are already defined.\n    // This prevents issues even if the other types together are valid.\n    if (!this.indexes[type]) {\n      const msg = `Type \"${type}\" was not defined. The defineType functions needs to be called before accessing data.`;\n      this.logger.error(msg);\n      throw new InternalServerError(msg);\n    }\n\n    if (this.validDefinition) {\n      return;\n    }\n\n    const rootTypes = new Set<StringKey<T>>();\n    // `this.indexes` will contain a key for each type as we always have an index on the identifier of a type\n    for (let indexType of Object.keys(this.indexes)) {\n      const foundTypes = new Set<string>([ indexType ]);\n      // Find path to root from this type, thereby ensuring that there is no cycle.\n      let relation = this.getParentRelation(indexType);\n      while (relation) {\n        indexType = relation.parent.type;\n        if (foundTypes.has(indexType)) {\n          const msg = `The following types cyclically reference each other: ${[ ...foundTypes ].join(', ')}`;\n          this.logger.error(msg);\n          throw new InternalServerError(msg);\n        }\n        foundTypes.add(indexType);\n        relation = this.getParentRelation(indexType);\n      }\n      rootTypes.add(indexType);\n    }\n\n    if (rootTypes.size > 1) {\n      const msg = `Only one type definition with no references is allowed. Found ${[ ...rootTypes ].join(', ')}`;\n      this.logger.error(msg);\n      throw new InternalServerError(msg);\n    }\n\n    this.rootTypeVar = [ ...rootTypes.values() ][0];\n\n    // Remove the root index as we don't need it, and it can cause confusion when resolving queries\n    this.indexes[this.rootTypeVar]?.delete(INDEX_ID_KEY);\n\n    this.validDefinition = true;\n  }\n\n  // --------------------------------- QUERY HELPERS ---------------------------------\n\n  /**\n   * Finds the IDs of all root objects that contain objects of the given type matching the given query\n   * by making use of the indexes applicable to the keys in the query.\n   * This function only looks at the keys in the query with primitive values,\n   * object values in the query referencing parent objects are not considered.\n   * Similarly, only indexes are used, keys without index are also ignored.\n   *\n   * If an array of root IDs is provided as input,\n   * the result will be an intersection of this array and the found identifiers.\n   *\n   * If the result is an empty array, it means that there is no valid identifier matching the query,\n   * while an `undefined` result means there is no index matching any of the query keys,\n   * so a result can't be determined.\n   */\n  protected async findIndexedRoots<TType extends StringKey<T>>(\n    type: TType,\n    match: IndexedQuery<T, TType>,\n    rootIds?: string[],\n  ): Promise<string[] | undefined> {\n    if (type === this.rootType && match[INDEX_ID_KEY]) {\n      // If the input is the root type with a known ID in the query,\n      // and we have already established that it is not this ID,\n      // there is no result.\n      if (rootIds && !rootIds.includes(match[INDEX_ID_KEY] as string)) {\n        return [];\n      }\n      rootIds = [ match[INDEX_ID_KEY] as string ];\n    }\n\n    const indexIds: string[] = [];\n    for (const [ key, value ] of Object.entries(match)) {\n      if (this.indexes[type]?.has(key) && typeof value !== 'undefined') {\n        // We know value is a string (or boolean/number) since we can't have indexes on fields referencing other objects\n        indexIds.push(this.getIndexKey(type, key, value as string));\n      }\n    }\n\n    if (indexIds.length === 0) {\n      return rootIds;\n    }\n\n    // Use all indexes found to find matching IDs\n    const indexResults = await Promise.all(indexIds.map(async(id): Promise<string[]> =>\n      await this.indexStorage.get(id) ?? []));\n    if (Array.isArray(rootIds)) {\n      indexResults.push(rootIds);\n    }\n\n    let indexedRoots: string[] = indexResults[0];\n    for (const ids of indexResults.slice(1)) {\n      indexedRoots = indexedRoots.filter((id): boolean => ids.includes(id));\n    }\n    return indexedRoots;\n  }\n\n  /**\n   * Finds all objects of the given type matching the query.\n   * The `rootIds` array can be used to restrict the IDs of root objects to look at,\n   * which is relevant for the recursive calls the function does.\n   *\n   * Will throw an error if there is no index that can be used to solve the query.\n   */\n  protected async solveQuery<TType extends StringKey<T>>(\n    type: TType,\n    query: IndexedQuery<T, TType>,\n    rootIds?: string[],\n  ): Promise<VirtualObject[]> {\n    this.logger.debug(`Executing \"${type}\" query ${JSON.stringify(query)}. Already found roots ${rootIds?.join(',')}.`);\n\n    const indexedRoots = await this.findIndexedRoots(type, query, rootIds);\n\n    // All objects of this type that we find through recursive calls\n    let objs: VirtualObject[];\n\n    // Either find all objects of the type from the found rootIds if the query is a leaf,\n    // or recursively query the parent object if it is not.\n    const relation = this.getParentRelation(type);\n    if (!relation || !query[relation.child.key]) {\n      // This is a leaf node of the query\n      if (!Array.isArray(indexedRoots)) {\n        this.logger.error(`Attempting to execute query without index: ${JSON.stringify(query)}`);\n        throw new InternalServerError(`Attempting to execute query without index: ${JSON.stringify(query)}`);\n      }\n      const pathFromRoot = this.getPathToType(type);\n      // All objects of this type for all root objects we have\n      const roots = (await Promise.all(indexedRoots.map(async(id): Promise<VirtualObject | undefined> => {\n        const root = await this.valueStorage.get(id);\n        if (!root) {\n          // Not throwing an error to sort of make server still work if an index is wrong.\n          this.logger.error(\n            `Data inconsistency: index contains ${this.rootType} with ID ${id}, but this object does not exist.`,\n          );\n        }\n        return root;\n      }))).filter((root): boolean => typeof root !== 'undefined') as VirtualObject[];\n      objs = roots.flatMap((root): VirtualObject[] => this.getChildObjects(root, pathFromRoot));\n    } else {\n      const subQuery = (typeof query[relation.child.key] === 'string' ?\n          { [INDEX_ID_KEY]: query[relation.child.key] } :\n        query[relation.child.key]) as IndexedQuery<T, typeof relation.parent.type>;\n      // All objects by recursively calling this function on the parent object and extracting all children of this type\n      objs = (await this.solveQuery(relation.parent.type, subQuery, indexedRoots))\n        // Parent key field can be undefined if the index structure changed\n        .flatMap((parentObj): VirtualObject[] => Object.values(parentObj[relation.parent.key] ?? {}));\n    }\n\n    // For all keys that were not handled recursively: make sure that it matches the found objects\n    const remainingKeys = Object.keys(query).filter(\n      (key): boolean => key !== relation?.child.key || typeof query[key] === 'string',\n    );\n    for (const key of remainingKeys) {\n      objs = objs.filter((obj): boolean => obj[key] === query[key]);\n    }\n    return objs;\n  }\n\n  // --------------------------------- INDEX HELPERS ---------------------------------\n\n  /**\n   * Generate the key used to store the index in the index storage.\n   */\n  protected getIndexKey(type: string, key: string, value: string | number): string {\n    return `${encodeURIComponent(type)}/${key === INDEX_ID_KEY ? '' : `${key}/`}${encodeURIComponent(`${value}`)}`;\n  }\n\n  /**\n   * Update all indexes for an object of the given type, and all its children.\n   */\n  protected async updateDeepTypeIndex<TType extends StringKey<T>>(\n    type: TType,\n    rootId: string,\n    oldObj: VirtualObject,\n    newObj?: VirtualObject,\n  ): Promise<void> {\n    const promises: Promise<void>[] = [];\n    promises.push(this.updateTypeIndex(type, rootId, oldObj, newObj));\n\n    for (const { parent, child } of this.getChildRelations(type)) {\n      // `oldRecord` can be undefined if the index structure changed\n      const oldRecord: Record<string, VirtualObject> = oldObj[parent.key] ?? {};\n      const newRecord: Record<string, VirtualObject> = newObj?.[parent.key] ?? {};\n      const uniqueKeys = new Set([ ...Object.keys(oldRecord), ...Object.keys(newRecord) ]);\n      for (const key of uniqueKeys) {\n        promises.push(this.updateDeepTypeIndex(child.type, rootId, oldRecord[key], newRecord[key]));\n      }\n    }\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * Updates all indexes for an object of the given type.\n   */\n  protected async updateTypeIndex<TType extends StringKey<T>>(\n    type: TType,\n    rootId: string,\n    oldObj?: VirtualObject,\n    newObj?: VirtualObject,\n  ): Promise<void> {\n    const added: { key: string; value: string }[] = [];\n    const removed: { key: string; value: string }[] = [];\n\n    for (const key of this.indexes[type]!) {\n      const oldValue = oldObj?.[key];\n      const newValue = newObj?.[key];\n      if (oldValue !== newValue) {\n        if (typeof oldValue !== 'undefined') {\n          removed.push({ key, value: oldValue as string });\n        }\n        if (typeof newValue !== 'undefined') {\n          added.push({ key, value: newValue as string });\n        }\n      }\n    }\n\n    await Promise.all([\n      ...added.map(async({ key, value }): Promise<unknown> => this.updateKeyIndex(type, key, value, rootId, true)),\n      ...removed.map(async({ key, value }): Promise<unknown> => this.updateKeyIndex(type, key, value, rootId, false)),\n    ]);\n  }\n\n  /**\n   * Updates the index for a specific key of an object of the given type.\n   */\n  protected async updateKeyIndex(type: string, key: string, value: string, rootId: string, add: boolean):\n  Promise<void> {\n    const indexKey = this.getIndexKey(type, key, value);\n    const indexValues = await this.indexStorage.get(indexKey) ?? [];\n    this.logger.debug(\n      `Updating index ${indexKey} by ${add ? 'adding' : 'removing'} ${rootId} from ${indexValues.join(',')}`,\n    );\n\n    if (add) {\n      if (!indexValues.includes(rootId)) {\n        indexValues.push(rootId);\n      }\n      await this.indexStorage.set(indexKey, indexValues);\n    } else {\n      const updatedValues = indexValues.filter((val): boolean => val !== rootId);\n      await (updatedValues.length === 0 ?\n        this.indexStorage.delete(indexKey) :\n        this.indexStorage.set(indexKey, updatedValues));\n    }\n  }\n}\n"]}