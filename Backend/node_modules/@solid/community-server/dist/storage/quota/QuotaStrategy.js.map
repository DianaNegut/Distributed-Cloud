{"version":3,"file":"QuotaStrategy.js","sourceRoot":"","sources":["../../../src/storage/quota/QuotaStrategy.ts"],"names":[],"mappings":";;;AAAA,oFAAoF;AACpF,yCAAyC;AACzC,6CAA0C;AAG1C,yEAAsE;AAEtE,4DAAuD;AAIvD;;;;;;GAMG;AACH,MAAsB,aAAa;IACjB,QAAQ,CAAwB;IAChC,KAAK,CAAO;IAE5B,YAAsB,QAA+B,EAAE,KAAW;QAChE,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAED;;;;;;;;;OASG;IACI,KAAK,CAAC,iBAAiB,CAAC,UAA8B;QAC3D,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAE3D,gDAAgD;QAChD,IAAI,SAAS,CAAC,MAAM,KAAK,MAAM,CAAC,gBAAgB,EAAE,CAAC;YACjD,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,+EAA+E;QAC/E,oEAAoE;QACpE,SAAS,CAAC,MAAM,IAAI,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC;QAErE,OAAO;YACL,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM;YAC5C,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI;SACtB,CAAC;IACJ,CAAC;IAYD;;;;;;OAMG;IACI,KAAK,CAAC,YAAY,CAAC,QAAgC;QACxD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAC5D,OAAO,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;IAC5E,CAAC;IAED;;;;;;;;OAQG;IACI,KAAK,CAAC,gBAAgB,CAAC,UAA8B;QAC1D,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,4CAA4C;QAC5C,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QAE1B,OAAO,IAAA,2BAAW,EAAC,IAAI,yBAAW,CAAC;YACjC,KAAK,CAAC,SAAS,CAAO,KAAc,EAAE,GAAW,EAAE,IAAgB;gBACjE,KAAK,IAAI,MAAM,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBAClD,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;gBAChE,IAAI,cAAc,CAAC,MAAM,GAAG,KAAK,EAAE,CAAC;oBAClC,IAAI,CAAC,OAAO,CAAC,IAAI,mCAAgB,CAC/B,qBAAqB,KAAK,GAAG,cAAc,CAAC,MAAM,IAAI,cAAc,CAAC,IAAI,eAAe,CACzF,CAAC,CAAC;gBACL,CAAC;gBAED,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACjB,IAAI,EAAE,CAAC;YACT,CAAC;SACF,CAAC,CAAC,CAAC;IACN,CAAC;CACF;AAzFD,sCAyFC","sourcesContent":["// These two eslint lines are needed to store 'this' in a variable so it can be used\n// in the PassThrough of createQuotaGuard\nimport { PassThrough } from 'node:stream';\nimport type { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { PayloadHttpError } from '../../util/errors/PayloadHttpError';\nimport type { Guarded } from '../../util/GuardedStream';\nimport { guardStream } from '../../util/GuardedStream';\nimport type { Size } from '../size-reporter/Size';\nimport type { SizeReporter } from '../size-reporter/SizeReporter';\n\n/**\n * A QuotaStrategy is used when we want to set a limit to the amount of data that can be\n * stored on the server.\n * This can range from a limit for the whole server to a limit on a per pod basis.\n * The way the size of a resource is calculated is implemented by the implementing classes.\n * This can be bytes, quads, file count, ...\n */\nexport abstract class QuotaStrategy {\n  public readonly reporter: SizeReporter<unknown>;\n  public readonly limit: Size;\n\n  protected constructor(reporter: SizeReporter<unknown>, limit: Size) {\n    this.reporter = reporter;\n    this.limit = limit;\n  }\n\n  /**\n   * Get the available space when writing data to the given identifier.\n   * If the given resource already exists it will deduct the already taken up\n   * space by that resource since it is going to be overwritten and thus counts\n   * as available space.\n   *\n   * @param identifier - the identifier of the resource of which you want the available space\n   *\n   * @returns the available space and the unit of the space as a Size object\n   */\n  public async getAvailableSpace(identifier: ResourceIdentifier): Promise<Size> {\n    const totalUsed = await this.getTotalSpaceUsed(identifier);\n\n    // Ignore identifiers where quota does not apply\n    if (totalUsed.amount === Number.MAX_SAFE_INTEGER) {\n      return totalUsed;\n    }\n\n    // When a file is overwritten the space the file takes up right now should also\n    // be counted as available space as it will disappear/be overwritten\n    totalUsed.amount -= (await this.reporter.getSize(identifier)).amount;\n\n    return {\n      amount: this.limit.amount - totalUsed.amount,\n      unit: this.limit.unit,\n    };\n  }\n\n  /**\n   * Get the currently used/occupied space.\n   *\n   * @param identifier - the identifier that should be used to calculate the total\n   *\n   * @returns a Size object containing the requested value.\n   * If quota is not relevant for this identifier, Size.amount should be Number.MAX_SAFE_INTEGER\n   */\n  protected abstract getTotalSpaceUsed(identifier: ResourceIdentifier): Promise<Size>;\n\n  /**\n   * Get an estimated size of the resource\n   *\n   * @param metadata - the metadata that might include the size\n   *\n   * @returns a Size object containing the estimated size and unit of the resource\n   */\n  public async estimateSize(metadata: RepresentationMetadata): Promise<Size | undefined> {\n    const estimate = await this.reporter.estimateSize(metadata);\n    return estimate ? { unit: this.limit.unit, amount: estimate } : undefined;\n  }\n\n  /**\n   * Get a Passthrough stream that will keep track of the available space.\n   * If the quota is exceeded the stream will emit an error and destroy itself.\n   * Like other Passthrough instances this will simply pass on the chunks, when the quota isn't exceeded.\n   *\n   * @param identifier - the identifier of the resource in question\n   *\n   * @returns a Passthrough instance that errors when quota is exceeded\n   */\n  public async createQuotaGuard(identifier: ResourceIdentifier): Promise<Guarded<PassThrough>> {\n    let total = 0;\n    // eslint-disable-next-line ts/no-this-alias\n    const that = this;\n    const { reporter } = this;\n\n    return guardStream(new PassThrough({\n      async transform(this, chunk: unknown, enc: string, done: () => void): Promise<void> {\n        total += await reporter.calculateChunkSize(chunk);\n        const availableSpace = await that.getAvailableSpace(identifier);\n        if (availableSpace.amount < total) {\n          this.destroy(new PayloadHttpError(\n            `Quota exceeded by ${total - availableSpace.amount} ${availableSpace.unit} during write`,\n          ));\n        }\n\n        this.push(chunk);\n        done();\n      },\n    }));\n  }\n}\n"]}