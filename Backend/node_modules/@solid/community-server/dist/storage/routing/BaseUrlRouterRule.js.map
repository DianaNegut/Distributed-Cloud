{"version":3,"file":"BaseUrlRouterRule.js","sourceRoot":"","sources":["../../../src/storage/routing/BaseUrlRouterRule.ts"],"names":[],"mappings":";;;AACA,2EAAwE;AAGxE,6CAA0C;AAE1C;;;;;;;;;GASG;AACH,MAAa,iBAAkB,SAAQ,uBAAU;IAC9B,SAAS,CAAiB;IAC1B,MAAM,CAAyC;IAEhE,YAAmB,MAA8C,EAAE,SAAyB;QAC1F,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,EAAE,UAAU,EAAsC;QACpE,IAAI,CAAC;YACH,OAAO,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;QAC1C,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;gBACnB,OAAO,IAAI,CAAC,SAAS,CAAC;YACxB,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,SAAS,CAAC,UAA8B;QACpD,IAAI,KAAK,EAAE,MAAM,CAAE,GAAG,EAAE,KAAK,CAAE,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE,CAAC;YACzD,IAAI,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,CAAC;gBACpC,OAAO,KAAK,CAAC;YACf,CAAC;QACH,CAAC;QACD,MAAM,IAAI,qCAAiB,EAAE,CAAC;IAChC,CAAC;CACF;AAhCD,8CAgCC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { NotFoundHttpError } from '../../util/errors/NotFoundHttpError';\nimport type { KeyValueStorage } from '../keyvalue/KeyValueStorage';\nimport type { ResourceStore } from '../ResourceStore';\nimport { RouterRule } from './RouterRule';\n\n/**\n * Routes requests based on their base url.\n * Checks if any of the stored base URLs match the request identifier.\n * If there are no matches the base store will be returned if one was configured.\n *\n * Part of the dynamic pod creation.\n * Uses the identifiers that were added to the routing storage.\n *\n * @see {@link TemplatedPodGenerator}, {@link ConfigPodInitializer}, {@link ConfigPodManager}\n */\nexport class BaseUrlRouterRule extends RouterRule {\n  private readonly baseStore?: ResourceStore;\n  private readonly stores: KeyValueStorage<string, ResourceStore>;\n\n  public constructor(stores: KeyValueStorage<string, ResourceStore>, baseStore?: ResourceStore) {\n    super();\n    this.baseStore = baseStore;\n    this.stores = stores;\n  }\n\n  public async handle({ identifier }: { identifier: ResourceIdentifier }): Promise<ResourceStore> {\n    try {\n      return await this.findStore(identifier);\n    } catch (error: unknown) {\n      if (this.baseStore) {\n        return this.baseStore;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Finds the store whose base url key is contained in the given identifier.\n   */\n  private async findStore(identifier: ResourceIdentifier): Promise<ResourceStore> {\n    for await (const [ key, store ] of this.stores.entries()) {\n      if (identifier.path.startsWith(key)) {\n        return store;\n      }\n    }\n    throw new NotFoundHttpError();\n  }\n}\n"]}