{"version":3,"file":"Header.js","sourceRoot":"","sources":["../../src/util/Header.ts"],"names":[],"mappings":";AAAA,iHAAiH;;;AAgDjH;;;GAGG;AACH,MAAa,WAAW;IACI;IAAsB;IAAhD,YAA0B,KAAa,EAAS,aAAqC,EAAE;QAA7D,UAAK,GAAL,KAAK,CAAQ;QAAS,eAAU,GAAV,UAAU,CAA6B;IAAG,CAAC;IAE3F;;;;OAIG;IACI,mBAAmB;QACxB,MAAM,gBAAgB,GAAG,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC;aACrD,IAAI,CAAC,CAAC,MAAM,EAAE,MAAM,EAAU,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;aACpE,GAAG,CAAC,CAAC,CAAE,GAAG,EAAE,KAAK,CAAE,EAAU,EAAE,CAAC,GAAG,GAAG,IAAI,KAAK,EAAE,CAAC,CAAC;QACtD,OAAO,CAAE,IAAI,CAAC,KAAK,EAAE,GAAG,gBAAgB,CAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC;CACF;AAdD,kCAcC;AAYD,mDAAmD;AACnD,EAAE;AACF,2DAA2D;AAC3D,EAAE;AACF,2BAA2B;AAC3B,oCAAoC;AACpC,wCAAwC;AACxC,sEAAsE;AACtE,0CAA0C;AAC1C,8FAA8F;AAC9F,EAAE;AACF,mCAAmC;AACnC,oCAAoC;AACpC,oCAAoC;AACpC,EAAE;AACF,qBAAqB;AACrB,qBAAqB;AACrB,mDAAmD;AACnD,EAAE;AACF,2DAA2D;AAC3D,mEAAmE;AACnE,2BAA2B;AAC3B,wDAAwD;AACxD,EAAE;AACF,kBAAkB;AAClB,EAAE;AACF,uDAAuD;AACvD,2BAA2B;AAC3B,EAAE;AACF,yDAAyD;AACzD,mCAAmC;AACnC,EAAE;AACF,mEAAmE;AACnE,0DAA0D;AAC1D,2BAA2B;AAC3B,2DAA2D;AAC3D,iEAAiE;AACjE,iCAAiC;AACjC,gDAAgD;AAChD,EAAE;AAEF,iBAAiB;AACJ,QAAA,KAAK,GAAG,qBAAqB,CAAC;AAC9B,QAAA,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,aAAK,CAAC,MAAM,IAAI,EAAE,GAAG,CAAC,CAAC;AAC9C,QAAA,kBAAkB,GAAG,IAAI,MAAM,CAAC,IAAI,aAAK,CAAC,MAAM,KAAK,aAAK,CAAC,MAAM,IAAI,EAAE,GAAG,CAAC,CAAC;AAC5E,QAAA,aAAa,GACxB,4FAA4F,CAAC;AAClF,QAAA,MAAM,GAAG,2CAA2C,CAAC","sourcesContent":["// The interfaces here are split off from HttpErrorUtil.ts to prevent a dependency loop in RepresentationMetadata\n\n/**\n * General interface for all Accept* headers.\n */\nexport interface AcceptHeader {\n  /** Requested range. Can be a specific value or `*`, matching all. */\n  range: string;\n  /** Weight of the preference [0, 1]. */\n  weight: number;\n}\n\n/**\n * Contents of an HTTP Accept header.\n * Range is type/subtype. Both can be `*`.\n */\nexport interface Accept extends AcceptHeader {\n  parameters: {\n    /** Media type parameters. These are the parameters that came before the q value. */\n    mediaType: Record<string, string>;\n    /**\n     * Extension parameters. These are the parameters that came after the q value.\n     * Value will be an empty string if there was none.\n     */\n    extension: Record<string, string>;\n  };\n}\n\n/**\n * Contents of an HTTP Accept-Charset header.\n */\nexport interface AcceptCharset extends AcceptHeader { }\n\n/**\n * Contents of an HTTP Accept-Encoding header.\n */\nexport interface AcceptEncoding extends AcceptHeader { }\n\n/**\n * Contents of an HTTP Accept-Language header.\n */\nexport interface AcceptLanguage extends AcceptHeader { }\n\n/**\n * Contents of an HTTP Accept-Datetime header.\n */\nexport interface AcceptDatetime extends AcceptHeader { }\n\n/**\n * Contents of an HTTP Content-Type Header.\n * Optional parameters Record is included.\n */\nexport class ContentType {\n  public constructor(public value: string, public parameters: Record<string, string> = {}) {}\n\n  /**\n   * Serialize this ContentType object to a ContentType header appropriate value string.\n   *\n   * @returns The value string, including parameters, if present.\n   */\n  public toHeaderValueString(): string {\n    const parameterStrings = Object.entries(this.parameters)\n      .sort((entry1, entry2): number => entry1[0].localeCompare(entry2[0]))\n      .map(([ key, value ]): string => `${key}=${value}`);\n    return [ this.value, ...parameterStrings ].join('; ');\n  }\n}\n\nexport interface LinkEntryParameters extends Record<string, string> {\n  /** Required rel properties of Link entry */\n  rel: string;\n}\n\nexport interface LinkEntry {\n  target: string;\n  parameters: LinkEntryParameters;\n}\n\n// BNF based on https://tools.ietf.org/html/rfc7231\n//\n// media-type = type \"/\" subtype *( OWS \";\" OWS parameter )\n//\n// media-range    = ( \"*/*\"\n//                / ( type \"/\" \"*\" )\n//                / ( type \"/\" subtype )\n//                ) *( OWS \";\" OWS parameter ) ; media type parameters\n// accept-params  = weight *( accept-ext )\n// accept-ext     = OWS \";\" OWS token [ \"=\" ( token / quoted-string ) ] ; extension parameters\n//\n// weight = OWS \";\" OWS \"q=\" qvalue\n// qvalue = ( \"0\" [ \".\" 0*3DIGIT ] )\n//        / ( \"1\" [ \".\" 0*3(\"0\") ] )\n//\n// type       = token\n// subtype    = token\n// parameter  = token \"=\" ( token / quoted-string )\n//\n// quoted-string  = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n// qdtext         = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n// obs-text       = %x80-FF\n// quoted-pair    = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n//\n// charset = token\n//\n// codings          = content-coding / \"identity\" / \"*\"\n// content-coding   = token\n//\n// language-range   = (1*8ALPHA *(\"-\" 1*8alphanum)) / \"*\"\n// alphanum         = ALPHA / DIGIT\n//\n// Delimiters are chosen from the set of US-ASCII visual characters\n// not allowed in a token (DQUOTE and \"(),/:;<=>?@[\\]{}\").\n// token          = 1*tchar\n// tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n//                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n//                / DIGIT / ALPHA\n//                ; any VCHAR, except delimiters\n//\n\n// REUSED REGEXES\nexport const TCHAR = /[-\\w!#$%&'*+.^`|~]/u;\nexport const TOKEN = new RegExp(`^${TCHAR.source}+$`, 'u');\nexport const SIMPLE_MEDIA_RANGE = new RegExp(`^${TCHAR.source}+/${TCHAR.source}+$`, 'u');\nexport const QUOTED_STRING =\n  /^\"(?:[\\t !\\u0023-\\u005B\\u005D-\\u007E\\u0080-\\u00FF]|(\\\\[\\t\\u0020-\\u007E\\u0080-\\u00FF]))*\"$/u;\nexport const QVALUE = /^(?:(0(?:\\.\\d{0,3})?)|(1(?:\\.0{0,3})?))$/u;\n"]}