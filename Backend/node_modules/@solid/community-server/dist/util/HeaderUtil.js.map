{"version":3,"file":"HeaderUtil.js","sourceRoot":"","sources":["../../src/util/HeaderUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IncomingHttpHeaders } from 'node:http';\nimport escapeStringRegexp from 'escape-string-regexp';\nimport { getLoggerFor } from '../logging/LogUtil';\nimport type { HttpResponse } from '../server/HttpResponse';\nimport { BadRequestHttpError } from './errors/BadRequestHttpError';\nimport type {\n  Accept,\n  AcceptCharset,\n  AcceptDatetime,\n  AcceptEncoding,\n  AcceptHeader,\n  AcceptLanguage,\n  LinkEntry,\n  LinkEntryParameters,\n} from './Header';\nimport { ContentType, QUOTED_STRING, QVALUE, SIMPLE_MEDIA_RANGE, TOKEN } from './Header';\n\nconst logger = getLoggerFor('HeaderUtil');\n\n// BNF based on https://tools.ietf.org/html/rfc7231\n//\n// Accept =          #( media-range [ accept-params ] )\n// Accept-Charset =  1#( ( charset / \"*\" ) [ weight ] )\n// Accept-Encoding  = #( codings [ weight ] )\n// Accept-Language = 1#( language-range [ weight ] )\n//\n// Content-Type = media-type\n\n// HELPER FUNCTIONS\n/**\n * Replaces all double quoted strings in the input string with `\"0\"`, `\"1\"`, etc.\n *\n * @param input - The Accept header string.\n *\n * @returns The transformed string and a map with keys `\"0\"`, etc. and values the original string that was there.\n *\n * @throws BadRequestHttpError\n * Thrown if invalid characters are detected in a quoted string.\n */\nexport function transformQuotedStrings(input: string): { result: string; replacements: Record<string, string> } {\n  let idx = 0;\n  const replacements: Record<string, string> = {};\n  const result = input.replaceAll(/\"(?:[^\"\\\\]|\\\\.)*\"/gu, (match): string => {\n    // Not all characters allowed in quoted strings, see BNF above\n    if (!QUOTED_STRING.test(match)) {\n      logger.warn(`Invalid quoted string in header: ${match}`);\n      throw new BadRequestHttpError(`Invalid quoted string in header: ${match}`);\n    }\n    const replacement = `\"${idx}\"`;\n    replacements[replacement] = match.slice(1, -1);\n    idx += 1;\n    return replacement;\n  });\n  return { result, replacements };\n}\n\n/**\n * Splits the input string on commas, trims all parts and filters out empty ones.\n *\n * @param input - Input header string.\n *\n * @returns An array of trimmed strings.\n */\nexport function splitAndClean(input: string): string[] {\n  return input.split(',')\n    .map((part): string => part.trim())\n    .filter((part): boolean => part.length > 0);\n}\n\n/**\n * Converts a qvalue to a number.\n * Returns 1 if the value is not a valid number or 1 if it is more than 1.\n * Returns 0 if the value is negative.\n * Otherwise, the parsed value is returned.\n *\n * @param qvalue - Value to convert.\n */\nfunction parseQValue(qvalue: string): number {\n  const result = Number(qvalue);\n  if (Number.isNaN(result) || result >= 1) {\n    return 1;\n  }\n  if (result < 0) {\n    return 0;\n  }\n  return result;\n}\n\n/**\n * Logs a warning to indicate there was an invalid value.\n * Throws a {@link BadRequestHttpError} in case `strict` is `true`.\n *\n * @param message - Message to log and potentially put in the error.\n * @param strict - `true` if an error needs to be thrown.\n */\nfunction handleInvalidValue(message: string, strict: boolean): void | never {\n  logger.warn(message);\n  if (strict) {\n    throw new BadRequestHttpError(message);\n  }\n}\n\n/**\n * Parses a list of split parameters and checks their validity. Parameters with invalid\n * syntax are ignored and not returned.\n *\n * @param parameters - A list of split parameters (token [ \"=\" ( token / quoted-string ) ])\n * @param replacements - The double quoted strings that need to be replaced.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An array of name/value objects corresponding to the parameters.\n */\nexport function parseParameters(parameters: string[], replacements: Record<string, string>, strict = false):\n{ name: string; value: string }[] {\n  const parsed: { name: string; value: string }[] = [];\n  for (const param of parameters) {\n    const [ name, rawValue ] = param.split('=').map((str): string => str.trim());\n\n    // Test replaced string for easier check\n    // parameter  = token \"=\" ( token / quoted-string )\n    // second part is optional for certain parameters\n    if (!(TOKEN.test(name) && (!rawValue || /^\"\\d+\"$/u.test(rawValue) || TOKEN.test(rawValue)))) {\n      handleInvalidValue(`Invalid parameter value: ${name}=${replacements[rawValue] || rawValue\n      } does not match (token ( \"=\" ( token / quoted-string ))?). `, strict);\n      continue;\n    }\n\n    let value = rawValue;\n    if (value in replacements) {\n      value = replacements[rawValue];\n    }\n\n    parsed.push({ name, value });\n  }\n  return parsed;\n}\n\n/**\n * Parses a single media range with corresponding parameters from an Accept header.\n * For every parameter value that is a double quoted string,\n * we check if it is a key in the replacements map.\n * If yes the value from the map gets inserted instead.\n * Invalid q values and parameter values are ignored and not returned.\n *\n * @param part - A string corresponding to a media range and its corresponding parameters.\n * @param replacements - The double quoted strings that need to be replaced.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An object corresponding to the header string, or\n * undefined if an invalid type or sub-type is detected.\n */\nfunction parseAcceptPart(part: string, replacements: Record<string, string>, strict: boolean): Accept | undefined {\n  const [ range, ...parameters ] = part.split(';').map((param): string => param.trim());\n\n  // No reason to test differently for * since we don't check if the type exists\n  if (!SIMPLE_MEDIA_RANGE.test(range)) {\n    handleInvalidValue(\n      `Invalid Accept range: ${range} does not match ( \"*/*\" / ( token \"/\" \"*\" ) / ( token \"/\" token ) )`,\n      strict,\n    );\n    return;\n  }\n\n  let weight = 1;\n  const mediaTypeParams: Record<string, string> = {};\n  const extensionParams: Record<string, string> = {};\n  let map = mediaTypeParams;\n  const parsedParams = parseParameters(parameters, replacements);\n  for (const { name, value } of parsedParams) {\n    if (name === 'q') {\n      // Extension parameters appear after the q value\n      map = extensionParams;\n      if (!QVALUE.test(value)) {\n        handleInvalidValue(`Invalid q value for range ${range}: ${value\n        } does not match ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] ).`, strict);\n      }\n      weight = parseQValue(value);\n    } else {\n      if (!value && map !== extensionParams) {\n        handleInvalidValue(\n          `Invalid Accept parameter ${name}: ` +\n          `Accept parameter values are not optional when preceding the q value`,\n          strict,\n        );\n        continue;\n      }\n      map[name] = value || '';\n    }\n  }\n\n  return {\n    range,\n    weight,\n    parameters: {\n      mediaType: mediaTypeParams,\n      extension: extensionParams,\n    },\n  };\n}\n\n/**\n * Parses an Accept-* header where each part is only a value and a weight, so roughly /.*(q=.*)?/ separated by commas.\n * The returned weights default to 1 if no q value is found or the q value is invalid.\n *\n * @param input - Input header string.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An array of ranges and weights.\n */\nfunction parseNoParameters(input: string, strict = false): AcceptHeader[] {\n  const parts = splitAndClean(input);\n\n  return parts.map((part): AcceptHeader => {\n    const [ range, qvalue ] = part.split(';').map((param): string => param.trim());\n    const result = { range, weight: 1 };\n    if (qvalue) {\n      if (!qvalue.startsWith('q=')) {\n        handleInvalidValue(`Only q parameters are allowed in ${input}`, strict);\n        return result;\n      }\n      const val = qvalue.slice(2);\n      if (!QVALUE.test(val)) {\n        handleInvalidValue(`Invalid q value for range ${range}: ${val\n        } does not match ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] ).`, strict);\n      }\n      result.weight = parseQValue(val);\n    }\n    return result;\n  }).sort((left, right): number => right.weight - left.weight);\n}\n\n// EXPORTED FUNCTIONS\n\n/**\n * Parses an Accept header string.\n *\n * @param input - The Accept header string.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An array of {@link Accept} objects, sorted by weight. Accept parts\n * with invalid syntax are ignored and removed from the returned array.\n */\nexport function parseAccept(input: string, strict = false): Accept[] {\n  // Quoted strings could prevent split from having correct results\n  const { result, replacements } = transformQuotedStrings(input);\n\n  const accepts: Accept[] = [];\n  for (const part of splitAndClean(result)) {\n    const partOrUndef = parseAcceptPart(part, replacements, strict);\n\n    if (partOrUndef !== undefined) {\n      accepts.push(partOrUndef);\n    }\n  }\n  return accepts.sort((left, right): number => right.weight - left.weight);\n}\n\n/**\n * Parses an Accept-Charset header string.\n *\n * @param input - The Accept-Charset header string.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An array of {@link AcceptCharset} objects, sorted by weight. Invalid ranges\n * are ignored and not returned.\n */\nexport function parseAcceptCharset(input: string, strict = false): AcceptCharset[] {\n  const results = parseNoParameters(input);\n  return results.filter((result): boolean => {\n    if (!TOKEN.test(result.range)) {\n      handleInvalidValue(\n        `Invalid Accept-Charset range: ${result.range} does not match (content-coding / \"identity\" / \"*\")`,\n        strict,\n      );\n      return false;\n    }\n    return true;\n  });\n}\n\n/**\n * Parses an Accept-Encoding header string.\n *\n * @param input - The Accept-Encoding header string.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An array of {@link AcceptEncoding} objects, sorted by weight. Invalid ranges\n * are ignored and not returned.\n */\nexport function parseAcceptEncoding(input: string, strict = false): AcceptEncoding[] {\n  const results = parseNoParameters(input);\n  return results.filter((result): boolean => {\n    if (!TOKEN.test(result.range)) {\n      handleInvalidValue(`Invalid Accept-Encoding range: ${result.range} does not match (charset / \"*\")`, strict);\n      return false;\n    }\n    return true;\n  });\n}\n\n/**\n * Parses an Accept-Language header string.\n *\n * @param input - The Accept-Language header string.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An array of {@link AcceptLanguage} objects, sorted by weight. Invalid ranges\n * are ignored and not returned.\n */\nexport function parseAcceptLanguage(input: string, strict = false): AcceptLanguage[] {\n  const results = parseNoParameters(input);\n  return results.filter((result): boolean => {\n    // (1*8ALPHA *(\"-\" 1*8alphanum)) / \"*\"\n    if (result.range !== '*' && !/^[a-zA-Z]{1,8}(?:-[a-zA-Z0-9]{1,8})*$/u.test(result.range)) {\n      handleInvalidValue(\n        `Invalid Accept-Language range: ${result.range} does not match ((1*8ALPHA *(\"-\" 1*8alphanum)) / \"*\")`,\n        strict,\n      );\n      return false;\n    }\n    return true;\n  });\n}\n\n// eslint-disable-next-line max-len\nconst rfc1123Date = /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} \\d{2}:\\d{2}:\\d{2} GMT$/u;\n\n/**\n * Parses an Accept-DateTime header string.\n *\n * @param input - The Accept-DateTime header string.\n * @param strict - Determines if invalid values throw errors (`true`) or log warnings (`false`). Defaults to `false`.\n *\n * @returns An array with a single {@link AcceptDatetime} object,\n * or an empty array if a range in an invalid format is detected.\n */\nexport function parseAcceptDateTime(input: string, strict = false): AcceptDatetime[] {\n  const range = input.trim();\n  if (!range) {\n    return [];\n  }\n  if (!rfc1123Date.test(range)) {\n    handleInvalidValue(`Invalid Accept-DateTime range: ${range} does not match the RFC1123 format`, strict);\n    return [];\n  }\n  return [{ range, weight: 1 }];\n}\n\n/**\n * Adds a header value without overriding previous values.\n */\nexport function addHeader(response: HttpResponse, name: string, value: string | string[]): void {\n  let allValues: string[] = [];\n  if (response.hasHeader(name)) {\n    let oldValues = response.getHeader(name)!;\n    if (typeof oldValues === 'string') {\n      oldValues = [ oldValues ];\n    } else if (typeof oldValues === 'number') {\n      oldValues = [ `${oldValues}` ];\n    }\n    allValues = oldValues;\n  }\n  if (Array.isArray(value)) {\n    allValues.push(...value);\n  } else {\n    allValues.push(value);\n  }\n  response.setHeader(name, allValues.length === 1 ? allValues[0] : allValues);\n}\n\n/**\n * Parses the Content-Type header and also parses any parameters in the header.\n *\n * @param input - The Content-Type header string.\n *\n * @returns A {@link ContentType} object containing the value and optional parameters.\n *\n * @throws BadRequestHttpError\n * Thrown on invalid header syntax.\n */\nexport function parseContentType(input: string): ContentType {\n  // Quoted strings could prevent split from having correct results\n  const { result, replacements } = transformQuotedStrings(input);\n  const [ value, ...params ] = result.split(';').map((str): string => str.trim());\n  if (!SIMPLE_MEDIA_RANGE.test(value)) {\n    logger.warn(`Invalid content-type: ${value}`);\n    throw new BadRequestHttpError(`Invalid content-type: ${value} does not match ( token \"/\" token )`);\n  }\n\n  const contentType = new ContentType(value);\n  for (const param of parseParameters(params, replacements)) {\n    contentType.parameters[param.name] = param.value;\n  }\n  return contentType;\n}\n\n/**\n * The Forwarded header from RFC7239\n */\nexport interface Forwarded {\n  /** The user-agent facing interface of the proxy */\n  by?: string;\n  /** The node making the request to the proxy */\n  for?: string;\n  /** The host request header field as received by the proxy */\n  host?: string;\n  /** The protocol used to make the request */\n  proto?: string;\n}\n\n/**\n * Parses a Forwarded header value and will fall back to X-Forwarded-* headers.\n *\n * @param headers - The incoming HTTP headers.\n *\n * @returns The parsed Forwarded header.\n */\nexport function parseForwarded(headers: IncomingHttpHeaders): Forwarded {\n  const forwarded: Record<string, string> = {};\n  if (headers.forwarded) {\n    for (const pair of headers.forwarded.replace(/\\s*,.*/u, '').split(';')) {\n      const components = /^(by|for|host|proto)=(.+)$/u.exec(pair);\n      if (components) {\n        forwarded[components[1]] = components[2];\n      }\n    }\n  } else {\n    const suffixes = [ 'host', 'proto' ];\n    for (const suffix of suffixes) {\n      const value = headers[`x-forwarded-${suffix}`] as string;\n      if (value) {\n        forwarded[suffix] = value.trim().replace(/\\s*,.*/u, '');\n      }\n    }\n  }\n  return forwarded;\n}\n\n/**\n * Parses the link header(s) and returns an array of LinkEntry objects.\n *\n * @param link - A single link header or an array of link headers\n *\n * @returns A LinkEntry array, LinkEntry contains a link and a params Record&lt;string,string&gt;\n */\nexport function parseLinkHeader(link: string | string[] = []): LinkEntry[] {\n  const linkHeaders = Array.isArray(link) ? link : [ link ];\n  const links: LinkEntry[] = [];\n  for (const entry of linkHeaders) {\n    const { result, replacements } = transformQuotedStrings(entry);\n    for (const part of splitAndClean(result)) {\n      const [ target, ...parameters ] = part.split(/\\s*;\\s*/u);\n      if (/^[^<]|[^>]$/u.test(target)) {\n        logger.warn(`Invalid link header ${part}.`);\n        continue;\n      }\n\n      // RFC 8288 - Web Linking (https://datatracker.ietf.org/doc/html/rfc8288)\n      //\n      //     The rel parameter MUST be\n      //     present but MUST NOT appear more than once in a given link-value;\n      //     occurrences after the first MUST be ignored by parsers.\n      //\n      const params: Record<string, string> = {};\n      for (const { name, value } of parseParameters(parameters, replacements)) {\n        if (name === 'rel' && 'rel' in params) {\n          continue;\n        }\n        params[name] = value;\n      }\n\n      if (!('rel' in params)) {\n        logger.warn(`Invalid link header ${part} contains no 'rel' parameter.`);\n        continue;\n      }\n\n      links.push({ target: target.slice(1, -1), parameters: params as LinkEntryParameters });\n    }\n  }\n  return links;\n}\n\n// Map used as a simple cache in the helper function matchesAuthorizationScheme.\nconst authSchemeRegexCache: Map<string, RegExp> = new Map();\n/**\n * Checks if the value of an HTTP Authorization header matches a specific scheme (e.g. Basic, Bearer, etc).\n *\n * @param scheme - Name of the authorization scheme (case insensitive).\n * @param authorization - The value of the Authorization header (may be undefined).\n *\n * @returns True if the Authorization header uses the specified scheme, false otherwise.\n */\nexport function matchesAuthorizationScheme(scheme: string, authorization?: string): boolean {\n  const lowerCaseScheme = scheme.toLowerCase();\n  if (!authSchemeRegexCache.has(lowerCaseScheme)) {\n    authSchemeRegexCache.set(lowerCaseScheme, new RegExp(`^${escapeStringRegexp(lowerCaseScheme)} `, 'iu'));\n  }\n  // Support authorization being undefined (for the sake of usability).\n  return typeof authorization !== 'undefined' && authSchemeRegexCache.get(lowerCaseScheme)!.test(authorization);\n}\n\n/**\n * Checks if the scheme part of the specified url matches at least one of the provided options.\n *\n * @param url - A string representing the URL.\n * @param schemes - Scheme value options (the function will check whether at least one matches the URL scheme).\n *\n * @returns True if the URL scheme matches at least one of the provided options, false otherwise.\n */\nexport function hasScheme(url: string, ...schemes: string[]): boolean {\n  const schemeOptions = new Set(schemes.map((item): string => item.toLowerCase()));\n  const urlSchemeResult = /^(.+?):\\/\\//u.exec(url);\n  return urlSchemeResult ? schemeOptions.has(urlSchemeResult[1].toLowerCase()) : false;\n}\n"]}