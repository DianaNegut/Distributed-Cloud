{"version":3,"file":"IterableUtil.js","sourceRoot":"","sources":["../../src/util/IterableUtil.ts"],"names":[],"mappings":"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","sourcesContent":["// Utility functions for iterables that avoid array conversion\n\n/**\n * Creates a new iterable with the results of calling a provided function on every element in the calling array.\n * Similar to the {@link Array.prototype.map} function.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable on which to call the map function.\n * @param callbackFn - Function that is called for every element.\n * @param thisArg - Value to use as `this` when executing `callbackFn`.\n */\nexport function* map<TIn, TOut>(\n  iterable: Iterable<TIn>,\n  callbackFn: (element: TIn, index: number) => TOut,\n  thisArg?: unknown,\n): Iterable<TOut> {\n  const boundMapFn = callbackFn.bind(thisArg);\n  let count = 0;\n  for (const value of iterable) {\n    yield boundMapFn(value, count);\n    count += 1;\n  }\n}\n\n/**\n * Creates a new iterable with all elements that pass the test implemented by the provided function.\n * Similar to the {@link Array.prototype.filter} function.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable on which to call the map function.\n * @param callbackFn - Function that is called to test every element.\n * @param thisArg - Value to use as `this` when executing `callbackFn`.\n */\nexport function* filter<T>(\n  iterable: Iterable<T>,\n  callbackFn: (element: T, index: number) => boolean,\n  thisArg?: unknown,\n): Iterable<T> {\n  const boundFilterFn = callbackFn.bind(thisArg);\n  let count = 0;\n  for (const value of iterable) {\n    if (boundFilterFn(value, count)) {\n      yield value;\n    }\n    count += 1;\n  }\n}\n\n/**\n * Creates a new iterable that is a concatenation of all the iterables in the input.\n *\n * @param iterables - An iterable of which the contents will be concatenated into a new iterable.\n */\nexport function* concat<T>(iterables: Iterable<Iterable<T>>): Iterable<T> {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\n/**\n * Returns the first element in the provided iterable that satisfies the provided testing function.\n * If no values satisfy the testing function, `undefined` is returned.\n * Similar to the {@link Array.prototype.find} function.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable on which to call the map function.\n * @param callbackFn - Function that is called to test every element.\n * @param thisArg - Value to use as `this` when executing `callbackFn`.\n */\nexport function find<T>(iterable: Iterable<T>, callbackFn: (element: T, index: number) => boolean, thisArg?: unknown):\nT | undefined {\n  const boundMapFn = callbackFn.bind(thisArg);\n  const count = 0;\n  for (const value of iterable) {\n    if (boundMapFn(value, count)) {\n      return value;\n    }\n  }\n}\n\n/**\n * Similar to the {@link Array.prototype.reduce} function, but for an iterable.\n * See the documentation of the above function for more details.\n * The first element will be used as the initial value.\n *\n * @param iterable - Iterable of which to reduce the elements.\n * @param callbackFn - A reducer function.\n */\nexport function reduce<TIn>(iterable: Iterable<TIn>,\n  callbackFn: (previousValue: TIn, currentValue: TIn, currentIndex: number) => TIn): TIn;\n/**\n * Similar to the {@link Array.prototype.reduce} function, but for an iterable.\n * See the documentation of the above function for more details.\n *\n * @param iterable - Iterable of which to reduce the elements.\n * @param callbackFn - A reducer function.\n * @param initialValue - The value to start from.\n */\nexport function reduce<TIn, TOut>(\n  iterable: Iterable<TIn>,\n  callbackFn: (previousValue: TOut, currentValue: TIn, currentIndex: number) => TOut, initialValue: TOut\n): TOut;\nexport function reduce<TIn, TOut>(\n  iterable: Iterable<TIn>,\n  callbackFn: (previousValue: TOut, currentValue: TIn, currentIndex: number) => TOut,\n  initialValue?: TOut,\n): TOut {\n  const iterator = iterable[Symbol.iterator]();\n  let count = 0;\n  if (!initialValue) {\n    const next = iterator.next();\n    if (next.done) {\n      throw new TypeError('Iterable is empty and no initial value was provided.');\n    }\n    // `initialValue` being undefined means the first signature was used where TIn === TOut\n    initialValue = next.value as unknown as TOut;\n    count += 1;\n  }\n  let previousValue = initialValue;\n  let next = iterator.next();\n  while (!next.done) {\n    previousValue = callbackFn(previousValue, next.value, count);\n    next = iterator.next();\n    count += 1;\n  }\n  return previousValue;\n}\n\n/**\n * Helper function for {@link sortedAsyncMerge}.\n *\n * Returns the next result of an AsyncIterator, or undefined if the iterator is finished.\n */\nasync function nextAsyncEntry<T>(iterator: AsyncIterator<T>): Promise<T | undefined> {\n  const result = await iterator.next();\n  if (result.done) {\n    return;\n  }\n  return result.value;\n}\n\n/**\n * Helper function for {@link sortedAsyncMerge}.\n *\n * Compares the next results of all `iterators` and returns the first one,\n * determined by the provided `comparator`.\n *\n * `results` should contain the first result of all these iterators.\n * This array will also be updated, replacing the result of the iterator whose result was chosen by the next one.\n */\nasync function findNextSorted<T>(\n  iterators: AsyncIterator<T>[],\n  results: (T | undefined)[],\n  comparator: (left: T, right: T) => number,\n): Promise<T | undefined> {\n  let best: { idx: number; value: T } | undefined;\n  // For every iterator: see if their next result is the best one so far\n  for (let i = 0; i < iterators.length; ++i) {\n    const value = results[i];\n    if (typeof value !== 'undefined') {\n      let compare = 1;\n      if (best) {\n        compare = comparator(best.value, value);\n      }\n\n      if (compare > 0) {\n        best = { idx: i, value };\n      }\n    }\n  }\n\n  if (best) {\n    // Advance the iterator that returned the new result\n    results[best.idx] = await nextAsyncEntry(iterators[best.idx]);\n  }\n\n  // Will return undefined if `best` was never initialized above\n  return best?.value;\n}\n\n/**\n * Merges the results of several sorted iterators.\n * In case the results of the individual iterators are not sorted the outcome results will also not be sorted.\n *\n * @param iterators - The iterators whose results need to be merged.\n * @param comparator - The comparator to use to compare the results.\n */\nexport async function* sortedAsyncMerge<T>(iterators: AsyncIterator<T>[], comparator?: (left: T, right: T) => number):\nAsyncIterable<T> {\n  if (!comparator) {\n    comparator = (left, right): number => {\n      if (left < right) {\n        return -1;\n      }\n      return left > right ? 1 : 0;\n    };\n  }\n\n  // Initialize the array to the first result of every iterator\n  const results: (T | undefined)[] = [];\n  for (const iterator of iterators) {\n    results.push(await nextAsyncEntry(iterator));\n  }\n\n  // Keep returning results as long as we find them\n  while (true) {\n    const next = await findNextSorted(iterators, results, comparator);\n    if (typeof next === 'undefined') {\n      return;\n    }\n    yield next;\n  }\n}\n\n/**\n * Converts an `AsyncIterator` to an array.\n */\nexport async function asyncToArray<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n  const arr: T[] = [];\n  for await (const result of iterable) {\n    arr.push(result);\n  }\n  return arr;\n}\n"]}