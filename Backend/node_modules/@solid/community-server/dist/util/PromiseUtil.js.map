{"version":3,"file":"PromiseUtil.js","sourceRoot":"","sources":["../../src/util/PromiseUtil.ts"],"names":[],"mappings":";;AAUA,8BAEC;AAOD,sDAMC;AAgBD,kCAUC;AAMD,oCAiBC;AA1ED,yCAAkC;AAClC,0DAA8D;AAI9D;;;;GAIG;AACH,SAAgB,SAAS,CAAI,MAAyB;IACpD,OAAO,iBAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;AACjC,CAAC;AAED;;;;GAIG;AACH,SAAgB,qBAAqB,CAAY,MAA2B,EAAE,QAA4B;IAExG,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;QACtB,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,EAAQ,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;IACnD,CAAC;IACD,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC;AAC1B,CAAC;AAED,SAAS,IAAI,KAAU,CAAC;AAExB;;;;;;;;;;;GAWG;AACI,KAAK,UAAU,WAAW,CAAC,UAA8B;IAC9D,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAQ,EAAE;QACnC,SAAS,aAAa,CAAC,KAAc;YACnC,IAAI,KAAK,EAAE,CAAC;gBACV,OAAO,CAAC,IAAI,CAAC,CAAC;YAChB,CAAC;QACH,CAAC;QACD,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAC,SAAS,EAAiB,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC;aAChG,IAAI,CAAC,GAAS,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;GAGG;AACI,KAAK,UAAU,YAAY,CAAI,QAAuB,EAAE,YAAY,GAAG,KAAK;IACjF,4BAA4B;IAC5B,MAAM,MAAM,GAAQ,EAAE,CAAC;IACvB,MAAM,MAAM,GAAY,EAAE,CAAC;IAC3B,KAAK,MAAM,MAAM,IAAI,MAAM,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC;QACxD,IAAI,MAAM,CAAC,MAAM,KAAK,WAAW,EAAE,CAAC;YAClC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC5B,CAAC;aAAM,IAAI,CAAC,YAAY,EAAE,CAAC;YACzB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAe,CAAC,CAAC;QACtC,CAAC;IACH,CAAC;IAED,yBAAyB;IACzB,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACtB,MAAM,IAAA,oCAAoB,EAAC,MAAM,CAAC,CAAC;IACrC,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["import { types } from 'node:util';\nimport { createAggregateError } from './errors/HttpErrorUtil';\n\nexport type PromiseOrValue<T> = T | Promise<T>;\n\n/**\n * Verifies if the given value is a Promise or not.\n *\n * @param object - Object to check.\n */\nexport function isPromise<T>(object: PromiseOrValue<T>): object is Promise<T> {\n  return types.isPromise(object);\n}\n\n/**\n * Calls `callback` with the resolved value of `object`.\n * In case `object` is a Promise, the result will also be a Promise,\n * otherwise the result will be sync.\n */\nexport function resolvePromiseOrValue<TIn, TOut>(object: PromiseOrValue<TIn>, callback: (val: TIn) => TOut):\nPromiseOrValue<TOut> {\n  if (isPromise(object)) {\n    return object.then((val): TOut => callback(val));\n  }\n  return callback(object);\n}\n\nfunction noop(): void {}\n\n/**\n * A function that simulates the Array.some behaviour but on an array of Promises.\n * Returns true if at least one promise returns true.\n * Returns false if all promises return false or error.\n *\n * @remarks\n *\n * Predicates provided as input must be implemented considering\n * the following points:\n * 1. if they throw an error, it won't be propagated;\n * 2. throwing an error should be logically equivalent to returning false.\n */\nexport async function promiseSome(predicates: Promise<boolean>[]): Promise<boolean> {\n  return new Promise((resolve): void => {\n    function resolveIfTrue(value: boolean): void {\n      if (value) {\n        resolve(true);\n      }\n    }\n    Promise.all(predicates.map(async(predicate): Promise<void> => predicate.then(resolveIfTrue, noop)))\n      .then((): void => resolve(false), noop);\n  });\n}\n\n/**\n * Obtains the values of all fulfilled promises.\n * If there are rejections (and `ignoreErrors` is false), throws a combined error of all rejected promises.\n */\nexport async function allFulfilled<T>(promises: Promise<T> [], ignoreErrors = false): Promise<T[]> {\n  // Collect values and errors\n  const values: T[] = [];\n  const errors: Error[] = [];\n  for (const result of await Promise.allSettled(promises)) {\n    if (result.status === 'fulfilled') {\n      values.push(result.value);\n    } else if (!ignoreErrors) {\n      errors.push(result.reason as Error);\n    }\n  }\n\n  // Either throw or return\n  if (errors.length > 0) {\n    throw createAggregateError(errors);\n  }\n  return values;\n}\n"]}