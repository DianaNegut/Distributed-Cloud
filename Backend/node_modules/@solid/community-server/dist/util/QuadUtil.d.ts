import type { Readable } from 'node:stream';
import type { NamedNode, Quad, Term } from '@rdfjs/types';
import type { ParserOptions, Store } from 'n3';
import type { Guarded } from './GuardedStream';
/**
 * Helper function for serializing an array of quads, with as result a Readable object.
 *
 * @param quads - The array of quads.
 * @param contentType - The content-type to serialize to.
 *
 * @returns The Readable object.
 */
export declare function serializeQuads(quads: Quad[], contentType?: string): Guarded<Readable>;
/**
 * Helper function to convert a Readable into an array of quads.
 *
 * @param readable - The readable object.
 * @param options - Options for the parser.
 *
 * @returns A promise containing the array of quads.
 */
export declare function parseQuads(readable: Guarded<Readable>, options?: ParserOptions): Promise<Quad[]>;
/**
 * Filter out duplicate quads from an array.
 *
 * @param quads - Quads to filter.
 *
 * @returns A new array containing the unique quads.
 */
export declare function uniqueQuads(quads: Quad[]): Quad[];
/**
 * Converts a term to a number. Returns undefined if the term was undefined.
 *
 * @param term - Term to parse.
 * @param radix - Radix to use when parsing. Default is 10.
 */
export declare function termToInt(term?: Term, radix?: number): number | undefined;
/**
 * Represents a triple pattern to be used as a filter.
 */
export declare class FilterPattern {
    readonly subject: NamedNode | null;
    readonly predicate: NamedNode | null;
    readonly object: NamedNode | null;
    /**
     * @param subject - Optionally filter based on a specific subject.
     * @param predicate - Optionally filter based on a predicate.
     * @param object - Optionally filter based on a specific object.
     */
    constructor(subject?: string, predicate?: string, object?: string);
}
/**
 * Represents a binding result from a SPARQL query.
 * The keys are the values of the Variable objects,
 * while the values are the terms mapped to those variables in a query result.
 */
export type SimpleBinding = Record<string, Term>;
/**
 * Finds the matching bindings in the given data set for the given BGP query.
 *
 * @param bgp - BGP to solve
 * @param data - Dataset to query.
 */
export declare function solveBgp(bgp: Quad[], data: Store): SimpleBinding[];
/**
 * Queries a data store with a pattern to find all resulting bindings.
 * Before matching the pattern with the store,
 * the given binding is applied to the pattern first.
 *
 * The resulting binding includes the given binding.
 *
 * @param pattern - Pattern to match with the data store.
 * @param binding - Pattern to first apply to the given pattern.
 * @param data - Data store to query.
 */
export declare function getAppliedBindings(pattern: Quad, binding: SimpleBinding, data: Store): SimpleBinding[];
/**
 * Finds the binding necessary to match the given pattern to the given quad.
 * This function assumes it has been verified that the pattern can match the quad.
 *
 * @param pattern - Pattern that can match the quad.
 * @param match - A quad that can be matched by the given pattern.
 */
export declare function matchBinding(pattern: Quad, match: Quad): SimpleBinding;
