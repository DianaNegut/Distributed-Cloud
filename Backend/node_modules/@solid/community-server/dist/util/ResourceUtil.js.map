{"version":3,"file":"ResourceUtil.js","sourceRoot":"","sources":["../../src/util/ResourceUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import arrayifyStream from 'arrayify-stream';\nimport { DataFactory } from 'n3';\nimport { BasicRepresentation } from '../http/representation/BasicRepresentation';\nimport type { Representation } from '../http/representation/Representation';\nimport { RepresentationMetadata } from '../http/representation/RepresentationMetadata';\nimport type { Conditions } from '../storage/conditions/Conditions';\nimport type { ETagHandler } from '../storage/conditions/ETagHandler';\nimport { NotModifiedHttpError } from './errors/NotModifiedHttpError';\nimport { guardedStreamFrom } from './StreamUtil';\nimport { toLiteral } from './TermUtil';\nimport { CONTENT_TYPE_TERM, DC, HH, LDP, RDF, SOLID_META, XSD } from './Vocabularies';\nimport namedNode = DataFactory.namedNode;\n\n/**\n * Helper function to generate type quads for a Container or Resource.\n *\n * @param metadata - Metadata to add to.\n * @param isContainer - If the identifier corresponds to a container.\n */\nexport function addResourceMetadata(metadata: RepresentationMetadata, isContainer: boolean): void {\n  if (isContainer) {\n    metadata.add(RDF.terms.type, LDP.terms.Container);\n    metadata.add(RDF.terms.type, LDP.terms.BasicContainer);\n  }\n  metadata.add(RDF.terms.type, LDP.terms.Resource);\n}\n\n/**\n * Updates the dc:modified time to the given time.\n *\n * @param metadata - Metadata to update.\n * @param date - Last modified date. Defaults to current time.\n */\nexport function updateModifiedDate(metadata: RepresentationMetadata, date = new Date()): void {\n  // Milliseconds get lost in some serializations, potentially causing mismatches\n  const lastModified = new Date(date);\n  lastModified.setMilliseconds(0);\n  metadata.set(DC.terms.modified, toLiteral(lastModified.toISOString(), XSD.terms.dateTime));\n}\n\n/**\n * Links a template file with a given content-type to the metadata using the SOLID_META.template predicate.\n *\n * @param metadata - Metadata to update.\n * @param templateFile - Path to the template.\n * @param contentType - Content-type of the template after it is rendered.\n */\nexport function addTemplateMetadata(metadata: RepresentationMetadata, templateFile: string, contentType: string):\nvoid {\n  const templateNode = namedNode(templateFile);\n  metadata.add(SOLID_META.terms.template, templateNode);\n  metadata.addQuad(templateNode, CONTENT_TYPE_TERM, contentType);\n}\n\n/**\n * Helper function to clone a representation, the original representation can still be used.\n * This function loads the entire stream in memory.\n *\n * @param representation - The representation to clone.\n *\n * @returns The cloned representation.\n */\nexport async function cloneRepresentation(representation: Representation): Promise<BasicRepresentation> {\n  const data = await arrayifyStream(representation.data);\n  const result = new BasicRepresentation(\n    data,\n    new RepresentationMetadata(representation.metadata),\n    representation.binary,\n  );\n  representation.data = guardedStreamFrom(data);\n  return result;\n}\n\n/**\n * Verify whether the given {@link Representation} matches the given conditions.\n * If true, add the corresponding ETag to the body metadata.\n * If not, destroy the data stream and throw a {@link NotModifiedHttpError} with the same ETag.\n * If `conditions` is not defined, nothing will happen.\n *\n * This uses the strict conditions check which takes the content type into account;\n * therefore, this should only be called after content negotiation, when it is certain what the output will be.\n *\n * Note that browsers only keep track of one ETag, and the Vary header has no impact on this,\n * meaning the browser could send us the ETag for a Turtle resource even though it is requesting JSON-LD;\n * this is why we have to check ETags after content negotiation.\n *\n * @param body - The representation to compare the conditions against.\n * @param eTagHandler - Used to generate the ETag to return with the 304 response.\n * @param conditions - The conditions to assert.\n */\nexport function assertReadConditions(body: Representation, eTagHandler: ETagHandler, conditions?: Conditions): void {\n  const eTag = eTagHandler.getETag(body.metadata);\n  if (conditions && !conditions.matchesMetadata(body.metadata, true)) {\n    body.data.destroy();\n    const error = new NotModifiedHttpError(eTag);\n\n    // From RFC 9111:\n    // > the cache MUST add each header field in the provided response to the stored response,\n    // > replacing field values that are already present\n    // So we need to make sure to send either no partial headers, or the exact same headers.\n    // By adding the metadata of the original resource here, we ensure we send the same headers.\n    error.metadata.identifier = body.metadata.identifier;\n    error.metadata.addQuads(body.metadata.quads());\n\n    throw error;\n  }\n  body.metadata.set(HH.terms.etag, eTag);\n}\n"]}