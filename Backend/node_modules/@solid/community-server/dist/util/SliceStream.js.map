{"version":3,"file":"SliceStream.js","sourceRoot":"","sources":["../../src/util/SliceStream.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Readable, TransformCallback, TransformOptions } from 'node:stream';\nimport { Transform } from 'node:stream';\nimport { RangeNotSatisfiedHttpError } from './errors/RangeNotSatisfiedHttpError';\nimport { pipeSafely } from './StreamUtil';\n\nexport interface SliceStreamOptions extends TransformOptions {\n  start: number;\n  end?: number;\n  size?: number;\n}\n\n/**\n * A stream that slices a part out of another stream.\n * `start` and `end` are inclusive.\n * If `end` is not defined it is until the end of the stream.\n *\n * Negative `start` values can be used to instead slice that many streams off the end of the stream.\n * This requires the `size` field to be defined.\n *\n * Both object and non-object streams are supported.\n * This needs to be explicitly specified,\n * as the class makes no assumptions based on the object mode of the source stream.\n */\nexport class SliceStream extends Transform {\n  protected readonly source: Readable;\n  protected remainingSkip: number;\n  protected remainingRead: number;\n\n  public constructor(source: Readable, options: SliceStreamOptions) {\n    super(options);\n    let start = options.start;\n    const end = options.end ?? Number.POSITIVE_INFINITY;\n    if (options.start < 0) {\n      if (typeof options.size === 'number') {\n        // `start` is a negative number here so need to add\n        start = options.size + start;\n      } else {\n        throw new RangeNotSatisfiedHttpError('Slicing data at the end of a stream requires a known size.');\n      }\n    }\n\n    if (start >= end) {\n      throw new RangeNotSatisfiedHttpError('Range start should be less than end.');\n    }\n\n    // Not using `end` variable as that could be infinity\n    if (typeof options.end === 'number' && typeof options.size === 'number' && options.end >= options.size) {\n      throw new RangeNotSatisfiedHttpError('Range end should be less than the total size.');\n    }\n\n    this.remainingSkip = start;\n    // End value is inclusive\n    this.remainingRead = end - options.start + 1;\n\n    this.source = source;\n    pipeSafely(source, this);\n  }\n\n  // eslint-disable-next-line ts/naming-convention\n  public _transform(chunk: unknown, encoding: BufferEncoding, callback: TransformCallback): void {\n    this.source.pause();\n    if (this.writableObjectMode) {\n      this.objectSlice(chunk);\n    } else {\n      this.binarySlice(chunk as Buffer);\n    }\n\n    this.source.resume();\n    callback();\n  }\n\n  protected binarySlice(chunk: Buffer): void {\n    let length = chunk.length;\n    if (this.remainingSkip > 0) {\n      chunk = chunk.subarray(this.remainingSkip);\n      this.remainingSkip -= length - chunk.length;\n      length = chunk.length;\n    }\n    if (length > 0 && this.remainingSkip <= 0) {\n      chunk = chunk.subarray(0, this.remainingRead);\n      this.push(chunk);\n      this.remainingRead -= length;\n      this.checkEnd();\n    }\n  }\n\n  protected objectSlice(chunk: unknown): void {\n    if (this.remainingSkip > 0) {\n      this.remainingSkip -= 1;\n    } else {\n      this.remainingRead -= 1;\n      this.push(chunk);\n      this.checkEnd();\n    }\n  }\n\n  /**\n   * Stop piping the source stream and close everything once the slice is finished.\n   */\n  protected checkEnd(): void {\n    if (this.remainingRead <= 0) {\n      this.source.unpipe();\n      this.end();\n      this.source.destroy();\n    }\n  }\n}\n"]}