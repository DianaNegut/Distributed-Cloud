{"version":3,"file":"TimerUtil.js","sourceRoot":"","sources":["../../src/util/TimerUtil.ts"],"names":[],"mappings":";;AASA,0CAkBC;AA1BD,kDAAwD;AAExD;;;;;GAKG;AACH,SAAgB,eAAe,CAC7B,MAAc,EACd,OAAe,EACf,QAAsD,EACtD,EAAW,EACX,GAAG,IAAa;IAEhB,KAAK,UAAU,YAAY,CAAC,GAAG,MAAe;QAC5C,IAAI,CAAC;YACH,yEAAyE;YACzE,wDAAwD;YACxD,OAAO,MAAM,QAAQ,CAAC,GAAG,MAAM,CAAC,CAAC;QACnC,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,MAAM,CAAC,KAAK,CAAC,mCAAmC,OAAO,MAAM,IAAA,8BAAkB,EAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAC5F,CAAC;IACH,CAAC;IACD,kDAAkD;IAClD,OAAO,WAAW,CAAC,YAAY,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,CAAC;AAChD,CAAC","sourcesContent":["import type { Logger } from '../logging/Logger';\nimport { createErrorMessage } from './errors/ErrorUtil';\n\n/**\n * Wraps the callback for {@link setInterval} so errors get caught and logged.\n * Parameters are identical to the {@link setInterval} parameters starting from the 3rd argument.\n * The logger and message will be used when the callback throws an error.\n * Supports asynchronous callback functions.\n */\nexport function setSafeInterval<TArgs>(\n  logger: Logger,\n  message: string,\n  callback: (...cbArgs: TArgs[]) => Promise<void> | void,\n  ms?: number,\n  ...args: TArgs[]\n): NodeJS.Timeout {\n  async function safeCallback(...cbArgs: TArgs[]): Promise<void> {\n    try {\n      // We don't know if the callback is async or not so this way we make sure\n      // the full function execution is done in the try block.\n      return await callback(...cbArgs);\n    } catch (error: unknown) {\n      logger.error(`Error during interval callback: ${message} - ${createErrorMessage(error)}`);\n    }\n  }\n  // eslint-disable-next-line ts/no-misused-promises\n  return setInterval(safeCallback, ms, ...args);\n}\n"]}