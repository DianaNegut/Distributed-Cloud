"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PREFERRED_PREFIX_TERM = exports.PREFERRED_PREFIX = exports.CONTENT_TYPE_TERM = exports.CONTENT_TYPE = exports.CONTENT_LENGTH_TERM = exports.CONTENT_LENGTH = exports.XSD = exports.VCARD = exports.VANN = exports.SOLID_META = exports.SOLID_HTTP = exports.SOLID_ERROR_TERM = exports.SOLID_ERROR = exports.SOLID_AS = exports.SOLID = exports.RDFS = exports.RDF = exports.POSIX = exports.PIM = exports.OIDC = exports.NOTIFY = exports.MA = exports.LDP = exports.JSON_LD = exports.IANA = exports.HTTP = exports.HH = exports.FOAF = exports.DC = exports.AUTH = exports.AS = exports.ACP = exports.ACL = void 0;
exports.createVocabulary = createVocabulary;
exports.extendVocabulary = extendVocabulary;
const n3_1 = require("n3");
/**
 * Creates a {@link ValueVocabulary} with the given `baseUri` as namespace and all `localNames` as entries.
 */
function createValueVocabulary(baseUri, localNames) {
    const expanded = {};
    // Expose the listed local names as properties
    for (const localName of localNames) {
        expanded[localName] = `${baseUri}${localName}`;
    }
    return {
        namespace: baseUri,
        ...expanded,
    };
}
/**
 * Creates a {@link TermVocabulary} based on the provided {@link ValueVocabulary}.
 */
function createTermVocabulary(values) {
    // Need to cast since `fromEntries` typings aren't strict enough
    return Object.fromEntries(Object.entries(values).map(([key, value]) => [key, n3_1.DataFactory.namedNode(value)]));
}
/**
 * Creates a {@link Vocabulary} with the given `baseUri` as namespace and all `localNames` as entries.
 * The values are the local names expanded from the given base URI as strings.
 * The `terms` field contains all the same values but as {@link NamedNode} instead.
 */
function createVocabulary(baseUri, ...localNames) {
    const values = createValueVocabulary(baseUri, localNames);
    return {
        ...values,
        terms: createTermVocabulary(values),
    };
}
/**
 * Creates a new {@link Vocabulary} that extends an existing one by adding new local names.
 *
 * @param vocabulary - The {@link Vocabulary} to extend.
 * @param newNames - The new local names that need to be added.
 */
function extendVocabulary(vocabulary, ...newNames) {
    const localNames = Object.keys(vocabulary)
        .filter((key) => key !== 'terms' && key !== 'namespace');
    const allNames = [...localNames, ...newNames];
    return createVocabulary(vocabulary.namespace, ...allNames);
}
exports.ACL = createVocabulary('http://www.w3.org/ns/auth/acl#', 'accessTo', 'agent', 'agentClass', 'agentGroup', 'AuthenticatedAgent', 'Authorization', 'default', 'mode', 'Write', 'Read', 'Append', 'Control');
exports.ACP = createVocabulary('http://www.w3.org/ns/solid/acp#', 
// Used for ACP middleware headers
'AccessControlResource', 'grant', 'attribute', 
// Access Control Resource
'resource', 'accessControl', 'memberAccessControl', 
// Access Control,
'apply', 
// Policy
'allow', 'deny', 'allOf', 'anyOf', 'noneOf', 
// Matcher
'agent', 'client', 'issuer', 'vc');
exports.AS = createVocabulary('https://www.w3.org/ns/activitystreams#', 'object', 'target', 'Add', 'Create', 'Delete', 'Remove', 'Update');
exports.AUTH = createVocabulary('urn:solid:auth:', 'userMode', 'publicMode');
exports.DC = createVocabulary('http://purl.org/dc/terms/', 'description', 'modified', 'title');
exports.FOAF = createVocabulary('http://xmlns.com/foaf/0.1/', 'Agent');
exports.HH = createVocabulary('http://www.w3.org/2011/http-headers#', 'content-length', 'etag');
exports.HTTP = createVocabulary('http://www.w3.org/2011/http#', 'statusCodeNumber');
exports.IANA = createVocabulary('http://www.w3.org/ns/iana/media-types/');
exports.JSON_LD = createVocabulary('http://www.w3.org/ns/json-ld#', 'context');
exports.LDP = createVocabulary('http://www.w3.org/ns/ldp#', 'contains', 'BasicContainer', 'Container', 'Resource');
exports.MA = createVocabulary('http://www.w3.org/ns/ma-ont#', 'format');
exports.NOTIFY = createVocabulary('http://www.w3.org/ns/solid/notifications#', 'accept', 'channelType', 'endAt', 'feature', 'rate', 'receiveFrom', 'startAt', 'state', 'sender', 'sendTo', 'subscription', 'topic', 'webhookAuth', 'WebhookChannel2023', 'WebSocketChannel2023', 'StreamingHTTPChannel2023');
exports.OIDC = createVocabulary('http://www.w3.org/ns/solid/oidc#', 'redirect_uris');
exports.PIM = createVocabulary('http://www.w3.org/ns/pim/space#', 'Storage');
exports.POSIX = createVocabulary('http://www.w3.org/ns/posix/stat#', 'mtime', 'size');
exports.RDF = createVocabulary('http://www.w3.org/1999/02/22-rdf-syntax-ns#', 'type');
exports.RDFS = createVocabulary('http://www.w3.org/2000/01/rdf-schema#', 'label');
exports.SOLID = createVocabulary('http://www.w3.org/ns/solid/terms#', 'deletes', 'inserts', 'oidcIssuer', 'oidcIssuerRegistrationToken', 'oidcRegistration', 'storageDescription', 'where', 'InsertDeletePatch');
exports.SOLID_AS = createVocabulary('urn:npm:solid:community-server:activity:', 'activity');
exports.SOLID_ERROR = createVocabulary('urn:npm:solid:community-server:error:', 'disallowedMethod', 
// Boolean value used to indicate that no response body should be returned for this error
'emptyBody', 'errorCode', 'errorResponse', 'stack', 'target');
// Used to pass parameters to error templates
exports.SOLID_ERROR_TERM = createVocabulary('urn:npm:solid:community-server:error-term:', 
// Identifier of the resource responsible for the error
'path');
exports.SOLID_HTTP = createVocabulary('urn:npm:solid:community-server:http:', 'accountCookie', 
// When the above cookie expires, expects an ISO date string
'accountCookieExpiration', 
// Unit, start, and end are used for range headers
'end', 'location', 'start', 'slug', 'unit');
exports.SOLID_META = createVocabulary('urn:npm:solid:community-server:meta:', 
// This identifier is used as graph for all metadata that is generated on the fly and should not be stored
'ResponseMetadata', 
// This is used to identify templates that can be used for the representation of a resource
'template', 
// This is used to store Content-Type Parameters
'contentTypeParameter', 'value', 
// This is used to indicate whether metadata should be preserved or not during a PUT operation
'preserve', 
// These predicates are used to describe the requested access in case of an unauthorized request
'requestedAccess', 'accessTarget', 'accessMode');
exports.VANN = createVocabulary('http://purl.org/vocab/vann/', 'preferredNamespacePrefix');
exports.VCARD = createVocabulary('http://www.w3.org/2006/vcard/ns#', 'hasMember');
exports.XSD = createVocabulary('http://www.w3.org/2001/XMLSchema#', 'dateTime', 'duration', 'integer', 'string');
// Alias for commonly used types
exports.CONTENT_LENGTH = exports.HH['content-length'];
exports.CONTENT_LENGTH_TERM = exports.HH.terms['content-length'];
exports.CONTENT_TYPE = exports.MA.format;
exports.CONTENT_TYPE_TERM = exports.MA.terms.format;
exports.PREFERRED_PREFIX = exports.VANN.preferredNamespacePrefix;
exports.PREFERRED_PREFIX_TERM = exports.VANN.terms.preferredNamespacePrefix;
//# sourceMappingURL=Vocabularies.js.map