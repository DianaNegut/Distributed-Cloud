{"version":3,"file":"HttpError.js","sourceRoot":"","sources":["../../../src/util/errors/HttpError.ts"],"names":[],"mappings":";;;AAeA,oDAEC;AA4ED,wDAaC;AAzGD,6FAA0F;AAC1F,0CAAqD;AACrD,kDAAyD;AACzD,2CAAsC;AAQtC;;GAEG;AACH,SAAgB,oBAAoB,CAAC,UAAkB;IACrD,OAAO,IAAA,sBAAW,EAAC,GAAG,0BAAW,CAAC,SAAS,IAAI,UAAU,EAAE,CAAC,CAAC;AAC/D,CAAC;AAED;;;GAGG;AACH,MAAa,SAAqC,SAAQ,KAAK;IAC7C,UAAU,CAAI;IACd,KAAK,CAAW;IAChB,SAAS,CAAS;IAClB,QAAQ,CAAyB;IAEjD;;;;;;;OAOG;IACH,YAAmB,UAAa,EAAE,IAAY,EAAE,OAAgB,EAAE,UAA4B,EAAE;QAC9F,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,IAAI,IAAI,UAAU,EAAE,CAAC;QACvD,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,IAAI,IAAI,+CAAsB,EAAE,CAAC;QACjE,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC1B,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,KAAc;QACrC,OAAO,IAAA,mBAAO,EAAC,KAAK,CAAC;YACnB,OAAQ,KAAmB,CAAC,UAAU,KAAK,QAAQ;YACnD,OAAO,CAAE,KAAmB,CAAC,QAAQ,CAAC,CAAC;IAC3C,CAAC;IAED;;OAEG;IACO,gBAAgB;QACxB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,0BAAW,CAAC,KAAK,CAAC,aAAa,EAAE,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QAC1F,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,mBAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE,IAAA,oBAAS,EAAC,IAAI,CAAC,UAAU,EAAE,kBAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;IAChG,CAAC;CACF;AArCD,8BAqCC;AAuBD;;;;;;;;;GASG;AACH,SAAgB,sBAAsB,CAAuB,UAAiB,EAAE,IAAY;IAC1F,OAAO,MAAM,iBAAkB,SAAQ,SAAgB;QAC9C,MAAM,CAAU,UAAU,GAAG,UAAU,CAAC;QACxC,MAAM,CAAU,GAAG,GAAG,oBAAoB,CAAC,UAAU,CAAC,CAAC;QAE9D,YAAmB,OAAgB,EAAE,OAA0B;YAC7D,KAAK,CAAC,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAC5C,CAAC;QAEM,MAAM,CAAC,UAAU,CAAC,KAAc;YACrC,OAAO,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,UAAU,KAAK,UAAU,CAAC;QACxE,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import type { NamedNode } from '@rdfjs/types';\nimport { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport { toLiteral, toNamedTerm } from '../TermUtil';\nimport { HTTP, SOLID_ERROR, XSD } from '../Vocabularies';\nimport { isError } from './ErrorUtil';\n\nexport interface HttpErrorOptions {\n  cause?: unknown;\n  errorCode?: string;\n  metadata?: RepresentationMetadata;\n}\n\n/**\n * Returns a URI that is unique for the given status code.\n */\nexport function generateHttpErrorUri(statusCode: number): NamedNode {\n  return toNamedTerm(`${SOLID_ERROR.namespace}H${statusCode}`);\n}\n\n/**\n * A class for all errors that could be thrown by Solid.\n * All errors inheriting from this should fix the status code thereby hiding the HTTP internals from other components.\n */\nexport class HttpError<T extends number = number> extends Error implements HttpErrorOptions {\n  public readonly statusCode: T;\n  public readonly cause?: unknown;\n  public readonly errorCode: string;\n  public readonly metadata: RepresentationMetadata;\n\n  /**\n   * Creates a new HTTP error. Subclasses should call this with their fixed status code.\n   *\n   * @param statusCode - HTTP status code needed for the HTTP response.\n   * @param name - Error name. Useful for logging and stack tracing.\n   * @param message - Error message.\n   * @param options - Optional options.\n   */\n  public constructor(statusCode: T, name: string, message?: string, options: HttpErrorOptions = {}) {\n    super(message);\n    this.statusCode = statusCode;\n    this.name = name;\n    this.cause = options.cause;\n    this.errorCode = options.errorCode ?? `H${statusCode}`;\n    this.metadata = options.metadata ?? new RepresentationMetadata();\n    this.generateMetadata();\n  }\n\n  public static isInstance(error: unknown): error is HttpError {\n    return isError(error) &&\n      typeof (error as HttpError).statusCode === 'number' &&\n      Boolean((error as HttpError).metadata);\n  }\n\n  /**\n   * Initializes the error metadata.\n   */\n  protected generateMetadata(): void {\n    this.metadata.add(SOLID_ERROR.terms.errorResponse, generateHttpErrorUri(this.statusCode));\n    this.metadata.add(HTTP.terms.statusCodeNumber, toLiteral(this.statusCode, XSD.terms.integer));\n  }\n}\n\n/**\n * Interface describing what an HttpError class should look like.\n * This helps us make sure all HttpError classes have the same utility static functions.\n */\nexport interface HttpErrorClass<TCode extends number = number> {\n  new(message?: string, options?: HttpErrorOptions): HttpError<TCode>;\n\n  /**\n   * The status code corresponding to this error class.\n   */\n  readonly statusCode: TCode;\n  /**\n   * A unique URI identifying this error class.\n   */\n  readonly uri: NamedNode;\n  /**\n   * Checks whether the given error is an instance of this class.\n   */\n  readonly isInstance: (error: unknown) => error is HttpError<TCode>;\n}\n\n/**\n * Generates a new HttpError class with the given status code and name.\n * In general, status codes are used to uniquely identify error types,\n * so there should be no 2 classes with the same value there.\n *\n * To make sure Components.js can work with these newly generated classes,\n * the generated class should be called `BaseHttpError` as that name is an entry in `.componentsignore`.\n * The actual class should then extend `BaseHttpError` and have a correct constructor,\n * so the Components.js generator can generate the correct components JSON-LD file during build.\n */\nexport function generateHttpErrorClass<TCode extends number>(statusCode: TCode, name: string): HttpErrorClass<TCode> {\n  return class SpecificHttpError extends HttpError<TCode> {\n    public static readonly statusCode = statusCode;\n    public static readonly uri = generateHttpErrorUri(statusCode);\n\n    public constructor(message?: string, options?: HttpErrorOptions) {\n      super(statusCode, name, message, options);\n    }\n\n    public static isInstance(error: unknown): error is SpecificHttpError {\n      return HttpError.isInstance(error) && error.statusCode === statusCode;\n    }\n  };\n}\n"]}