{"version":3,"file":"HttpErrorUtil.js","sourceRoot":"","sources":["../../../src/util/errors/HttpErrorUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { RepresentationMetadata } from '../../http/representation/RepresentationMetadata';\nimport { toPredicateTerm } from '../TermUtil';\nimport { SOLID_ERROR_TERM } from '../Vocabularies';\nimport { BadRequestHttpError } from './BadRequestHttpError';\nimport { createErrorMessage } from './ErrorUtil';\nimport { HttpError } from './HttpError';\nimport { InternalServerError } from './InternalServerError';\nimport Dict = NodeJS.Dict;\n\n/**\n * Adds the given terms to error metadata.\n * The keys will be converted to predicates by prepending them with the `SOLID_ERROR_TERM` namespace.\n * The values will become literals.\n *\n * @param terms - Terms to add to the metadata.\n * @param metadata - Metadata to add the terms to. A new metadata object will be created if this is undefined.\n */\nexport function errorTermsToMetadata(terms: Dict<string>, metadata?: RepresentationMetadata): RepresentationMetadata {\n  metadata = metadata ?? new RepresentationMetadata();\n  for (const [ key, value ] of Object.entries(terms)) {\n    if (value) {\n      metadata.add(toPredicateTerm(`${SOLID_ERROR_TERM.namespace}${key}`), value);\n    }\n  }\n  return metadata;\n}\n\n/**\n * Extracts all the error metadata terms and converts them to a simple object.\n * All predicates in the `SOLID_ERROR_TERM` namespace will be found.\n * The namespace will be removed from the predicate and the remainder will be used as a key.\n * The object literal values will be used as values in the resulting object.\n *\n * @param metadata - Metadata to extract the terms from.\n */\nexport function extractErrorTerms(metadata: RepresentationMetadata): Dict<string> {\n  const errorQuads = metadata.quads()\n    .filter((quad): boolean => quad.predicate.value.startsWith(SOLID_ERROR_TERM.namespace));\n\n  const errorTerms: Dict<string> = {};\n  for (const quad of errorQuads) {\n    errorTerms[quad.predicate.value.slice(SOLID_ERROR_TERM.namespace.length)] = quad.object.value;\n  }\n  return errorTerms;\n}\n\n/**\n * Combines a list of errors into a single HttpError.\n * Status code depends on the input errors. If they all share the same status code that code will be re-used.\n * If they are all within the 4xx range, 400 will be used, otherwise 500.\n *\n * @param errors - Errors to combine.\n */\nexport function createAggregateError(errors: Error[]): HttpError {\n  const httpErrors = errors.map((error): HttpError =>\n    HttpError.isInstance(error) ? error : new InternalServerError(createErrorMessage(error)));\n  const messages = httpErrors.map((error: Error): string => error.message).filter((msg): boolean => msg.length > 0);\n\n  // Let message depend on the messages that were present.\n  // This prevents a bunch of empty strings being joined in the case most of them were 404s.\n  let message: string;\n  if (messages.length === 0) {\n    message = '';\n  } else if (messages.length === 1) {\n    message = messages[0];\n  } else {\n    message = `Multiple handler errors: ${messages.join(', ')}`;\n  }\n\n  // Check if all errors have the same status code\n  if (httpErrors.length > 0 && httpErrors.every((error): boolean => error.statusCode === httpErrors[0].statusCode)) {\n    return new HttpError(httpErrors[0].statusCode, httpErrors[0].name, message);\n  }\n\n  // Find the error range (4xx or 5xx)\n  if (httpErrors.some((error): boolean => error.statusCode >= 500)) {\n    return new InternalServerError(message);\n  }\n  return new BadRequestHttpError(message);\n}\n"]}