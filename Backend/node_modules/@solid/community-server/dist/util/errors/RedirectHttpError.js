"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedirectHttpError = void 0;
exports.generateRedirectHttpErrorClass = generateRedirectHttpErrorClass;
const n3_1 = require("n3");
const Vocabularies_1 = require("../Vocabularies");
const HttpError_1 = require("./HttpError");
/**
 * An error corresponding to a 3xx status code.
 * Includes the location it redirects to.
 */
class RedirectHttpError extends HttpError_1.HttpError {
    location;
    constructor(statusCode, name, location, message, options) {
        super(statusCode, name, message, options);
        this.location = location;
        this.metadata.add(Vocabularies_1.SOLID_HTTP.terms.location, n3_1.DataFactory.namedNode(location));
    }
    static isInstance(error) {
        return HttpError_1.HttpError.isInstance(error) && typeof error.location === 'string';
    }
}
exports.RedirectHttpError = RedirectHttpError;
/**
 * Generates a {@link RedirectHttpErrorClass}, similar to how {@link generateHttpErrorClass} works.
 * The difference is that here a `location` field also gets set and the `getInstance` method
 * also uses the {@link RedirectHttpError.isInstance} function.
 */
function generateRedirectHttpErrorClass(code, name) {
    return class SpecificRedirectHttpError extends RedirectHttpError {
        static statusCode = code;
        static uri = (0, HttpError_1.generateHttpErrorUri)(code);
        constructor(location, message, options) {
            super(code, name, location, message, options);
        }
        static isInstance(error) {
            return RedirectHttpError.isInstance(error) && error.statusCode === code;
        }
    };
}
//# sourceMappingURL=RedirectHttpError.js.map