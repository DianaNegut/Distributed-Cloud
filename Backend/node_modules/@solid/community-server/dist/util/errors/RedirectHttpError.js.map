{"version":3,"file":"RedirectHttpError.js","sourceRoot":"","sources":["../../../src/util/errors/RedirectHttpError.ts"],"names":[],"mappings":";;;AAoCA,wEAgBC;AApDD,2BAAiC;AACjC,kDAA6C;AAE7C,2CAA8D;AAE9D;;;GAGG;AACH,MAAa,iBAAiD,SAAQ,qBAAgB;IACpE,QAAQ,CAAS;IAEjC,YAAmB,UAAiB,EAAE,IAAY,EAAE,QAAgB,EAAE,OAAgB,EAAE,OAA0B;QAChH,KAAK,CAAC,UAAU,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAC1C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,yBAAU,CAAC,KAAK,CAAC,QAAQ,EAAE,gBAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;IAChF,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,KAAc;QACrC,OAAO,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,OAAQ,KAA2B,CAAC,QAAQ,KAAK,QAAQ,CAAC;IAClG,CAAC;CACF;AAZD,8CAYC;AAUD;;;;GAIG;AACH,SAAgB,8BAA8B,CAC5C,IAAW,EACX,IAAY;IAEZ,OAAO,MAAM,yBAA0B,SAAQ,iBAAwB;QAC9D,MAAM,CAAU,UAAU,GAAG,IAAI,CAAC;QAClC,MAAM,CAAU,GAAG,GAAG,IAAA,gCAAoB,EAAC,IAAI,CAAC,CAAC;QAExD,YAAmB,QAAgB,EAAE,OAAgB,EAAE,OAA0B;YAC/E,KAAK,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAChD,CAAC;QAEM,MAAM,CAAC,UAAU,CAAC,KAAc;YACrC,OAAO,iBAAiB,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,UAAU,KAAK,IAAI,CAAC;QAC1E,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import { DataFactory } from 'n3';\nimport { SOLID_HTTP } from '../Vocabularies';\nimport type { HttpErrorClass, HttpErrorOptions } from './HttpError';\nimport { generateHttpErrorUri, HttpError } from './HttpError';\n\n/**\n * An error corresponding to a 3xx status code.\n * Includes the location it redirects to.\n */\nexport class RedirectHttpError<TCode extends number = number> extends HttpError<TCode> {\n  public readonly location: string;\n\n  public constructor(statusCode: TCode, name: string, location: string, message?: string, options?: HttpErrorOptions) {\n    super(statusCode, name, message, options);\n    this.location = location;\n    this.metadata.add(SOLID_HTTP.terms.location, DataFactory.namedNode(location));\n  }\n\n  public static isInstance(error: unknown): error is RedirectHttpError {\n    return HttpError.isInstance(error) && typeof (error as RedirectHttpError).location === 'string';\n  }\n}\n\n/**\n * Interface describing what a {@link RedirectHttpError} class should look like.\n * Makes sure a `location` value is always needed.\n */\nexport interface RedirectHttpErrorClass<TCode extends number = number> extends Omit<HttpErrorClass<TCode>, 'new'> {\n  new(location: string, message?: string, options?: HttpErrorOptions): RedirectHttpError<TCode>;\n}\n\n/**\n * Generates a {@link RedirectHttpErrorClass}, similar to how {@link generateHttpErrorClass} works.\n * The difference is that here a `location` field also gets set and the `getInstance` method\n * also uses the {@link RedirectHttpError.isInstance} function.\n */\nexport function generateRedirectHttpErrorClass<TCode extends number>(\n  code: TCode,\n  name: string,\n): RedirectHttpErrorClass<TCode> {\n  return class SpecificRedirectHttpError extends RedirectHttpError<TCode> {\n    public static readonly statusCode = code;\n    public static readonly uri = generateHttpErrorUri(code);\n\n    public constructor(location: string, message?: string, options?: HttpErrorOptions) {\n      super(code, name, location, message, options);\n    }\n\n    public static isInstance(error: unknown): error is SpecificRedirectHttpError {\n      return RedirectHttpError.isInstance(error) && error.statusCode === code;\n    }\n  };\n}\n"]}