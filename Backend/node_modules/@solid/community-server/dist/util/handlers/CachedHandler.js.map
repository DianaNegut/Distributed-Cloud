{"version":3,"file":"CachedHandler.js","sourceRoot":"","sources":["../../../src/util/handlers/CachedHandler.ts"],"names":[],"mappings":";;;AAAA,iDAA8C;AAI9C;;;;;;;;;GASG;AACH,MAAa,aAAgE,SAAQ,2BAAuB;IACzF,MAAM,CAA0B;IAChC,MAAM,CAAiC;IAEvC,KAAK,CAAmC;IAEzD,YAAmB,MAA+B,EAAE,MAAiB;QACnE,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,MAAM,EAAE,CAAC;YACX,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACxB,MAAM,IAAI,KAAK,CAAC,iEAAiE,CAAC,CAAC;YACrF,CAAC;YACD,iDAAiD;YACjD,4DAA4D;YAC5D,yDAAyD;YACzD,2EAA2E;YAC3E,IAAI,CAAC,MAAM,GAAG,MAAuC,CAAC;QACxD,CAAC;QACD,IAAI,CAAC,KAAK,GAAG,IAAI,OAAO,EAAE,CAAC;IAC7B,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAU;QAC/B,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACjC,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QAE1D,IAAI,GAAG,EAAE,GAAG,CAAC,IAAI,CAAC,GAAG,EAAG,CAAC,EAAE,CAAC;YAC1B,OAAO;QACT,CAAC;QAED,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACtC,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,KAAU;QAC5B,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACjC,MAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAE,CAAC;QAEjE,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAG,CAAC;QACxB,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC1B,IAAI,MAAM,EAAE,CAAC;YACX,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACzC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QAErB,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;OAGG;IACO,OAAO,CAAC,KAAU;QAC1B,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;YACjB,OAAO,CAAE,KAAK,CAAE,CAAC;QACnB,CAAC;QAED,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAU,EAAE,CAAC,KAAK,CAAC,KAAK,CAAW,CAA0B,CAAC;IAC7F,CAAC;IAED;;;;;;;;OAQG;IACO,eAAe,CAAC,KAAU,EAAE,IAAc,EAAE,KAAuC,EAAE,MAAM,GAAG,KAAK;QAE3G,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACtB,OAAO,KAA8B,CAAC;QACxC,CAAC;QAED,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACpB,IAAI,SAAS,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAiD,CAAC;QAC/E,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,OAAO;YACT,CAAC;YACD,SAAS,GAAG,IAAI,OAAO,EAA2B,CAAC;YACnD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;QAC5B,CAAC;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;IACvE,CAAC;CACF;AAxFD,sCAwFC","sourcesContent":["import { AsyncHandler } from './AsyncHandler';\n\ntype NestedMap<TOut> = TOut | WeakMap<object, NestedMap<TOut>>;\n\n/**\n * Caches output data from the source handler based on the input object.\n * The `fields` parameter can be used to instead use one or more specific entries from the input object as cache key,\n * so has as actual required typing `(keyof TIn)[]`.\n *\n * A {@link WeakMap} is used internally so strict object equality determines cache hits,\n * and data will be removed once the key stops existing.\n * This also means that the cache key needs to be an object.\n * Errors will be thrown in case a primitive is used.\n */\nexport class CachedHandler<TIn extends Record<string, unknown>, TOut = void> extends AsyncHandler<TIn, TOut> {\n  private readonly source: AsyncHandler<TIn, TOut>;\n  private readonly fields?: [keyof TIn, ...(keyof TIn)[]];\n\n  private readonly cache: WeakMap<object, NestedMap<TOut>>;\n\n  public constructor(source: AsyncHandler<TIn, TOut>, fields?: string[]) {\n    super();\n    this.source = source;\n    if (fields) {\n      if (fields.length === 0) {\n        throw new Error('The fields parameter needs to have at least 1 entry if defined.');\n      }\n      // This is the first of many casts in this class.\n      // All of them are 100% correct though and are a consequence\n      // of the cache depth depending on the length of `fields`\n      // and the Node.js array functions not always having strict enough typings.\n      this.fields = fields as [keyof TIn, ...(keyof TIn)[]];\n    }\n    this.cache = new WeakMap();\n  }\n\n  public async canHandle(input: TIn): Promise<void> {\n    const keys = this.getKeys(input);\n    const map = this.findDestination(input, keys, this.cache);\n\n    if (map?.has(keys.pop()!)) {\n      return;\n    }\n\n    return this.source.canHandle(input);\n  }\n\n  public async handle(input: TIn): Promise<TOut> {\n    const keys = this.getKeys(input);\n    const map = this.findDestination(input, keys, this.cache, true)!;\n\n    const key = keys.pop()!;\n    let result = map.get(key);\n    if (result) {\n      return result;\n    }\n\n    result = await this.source.handle(input);\n    map.set(key, result);\n\n    return result;\n  }\n\n  /**\n   * Extracts the values that will be used as keys from the input object.\n   * In case the `fields` value was undefined, this will return an array containing the input object itself.\n   */\n  protected getKeys(input: TIn): [object, ...object[]] {\n    if (!this.fields) {\n      return [ input ];\n    }\n\n    return this.fields.map((field): object => input[field] as object) as [object, ...object[]];\n  }\n\n  /**\n   * Returns the `WeakMap` that contains actual objects that were cached,\n   * so the last `WeakMap` in the chain of maps.\n   *\n   * Returns `undefined` if no such map exists because earlier keys were not cached.\n   *\n   * Will always return a map if `ensure` is set to true,\n   * in such a case the intermediate maps will be created and added to the previous map.\n   */\n  protected findDestination(input: TIn, keys: object[], cache: WeakMap<object, NestedMap<TOut>>, ensure = false):\n  WeakMap<object, TOut> | undefined {\n    if (keys.length === 1) {\n      return cache as WeakMap<object, TOut>;\n    }\n\n    const key = keys[0];\n    let nextCache = cache.get(key) as WeakMap<object, NestedMap<TOut>> | undefined;\n    if (!nextCache) {\n      if (!ensure) {\n        return;\n      }\n      nextCache = new WeakMap<object, NestedMap<TOut>>();\n      cache.set(key, nextCache);\n    }\n\n    return this.findDestination(input, keys.slice(1), nextCache, ensure);\n  }\n}\n"]}