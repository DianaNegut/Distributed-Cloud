{"version":3,"file":"BaseIdentifierStrategy.js","sourceRoot":"","sources":["../../../src/util/identifiers/BaseIdentifierStrategy.ts"],"names":[],"mappings":";;;AACA,2DAA+D;AAC/D,uEAAoE;AACpE,0CAAoD;AAGpD;;GAEG;AACH,MAAM,WAAW,GAAG,mBAAmB,CAAC;AAExC;;GAEG;AACH,MAAM,SAAS,GAAG,MAAM,CAAC;AAEzB;;;;;;;GAOG;AACH,MAAsB,sBAAsB;IAGnC,kBAAkB,CAAC,UAA8B;QACtD,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,EAAE,CAAC;YACzC,MAAM,IAAI,yCAAmB,CAC3B,kBAAkB,UAAU,CAAC,IAAI,8CAA8C,EAC/E,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAA,oCAAoB,EAAC,EAAE,IAAI,EAAE,UAAU,CAAC,IAAI,EAAE,CAAC,EAAE,CAClF,CAAC;QACJ,CAAC;QACD,IAAI,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,EAAE,CAAC;YACrC,MAAM,IAAI,yCAAmB,CAAC,+BAA+B,UAAU,CAAC,IAAI,kCAAkC,CAAC,CAAC;QAClH,CAAC;QAED,2DAA2D;QAC3D,MAAM,KAAK,GAAG,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAChD,OAAO,EAAE,IAAI,EAAE,KAAM,CAAC,CAAC,CAAC,EAAE,CAAC;IAC7B,CAAC;IAIM,QAAQ,CAAC,SAA6B,EAAE,UAA8B,EAAE,UAAmB;QAChG,IAAI,CAAC,IAAA,gCAAqB,EAAC,SAAS,CAAC,EAAE,CAAC;YACtC,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC;YAChD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,UAAU,EAAE,CAAC;YACf,OAAO,IAAI,CAAC;QACd,CAAC;QAED,MAAM,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1D,wFAAwF;QACxF,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;CACF;AAtCD,wDAsCC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { errorTermsToMetadata } from '../errors/HttpErrorUtil';\nimport { InternalServerError } from '../errors/InternalServerError';\nimport { isContainerIdentifier } from '../PathUtil';\nimport type { IdentifierStrategy } from './IdentifierStrategy';\n\n/**\n * Regular expression used to determine the parent container of a resource.\n */\nconst parentRegex = /^(.+\\/)[^/]+\\/*$/u;\n\n/**\n * Used during containment check to determine if an identifier is a direct child or not.\n */\nconst tailRegex = /\\/./u;\n\n/**\n * Provides a default implementation for `getParentContainer`\n * which checks if the identifier is supported and not a root container.\n * If not, the last part before the first relevant slash will be removed to find the parent.\n *\n * Provides a default implementation for `contains`\n * which does standard slash-semantics based string comparison.\n */\nexport abstract class BaseIdentifierStrategy implements IdentifierStrategy {\n  public abstract supportsIdentifier(identifier: ResourceIdentifier): boolean;\n\n  public getParentContainer(identifier: ResourceIdentifier): ResourceIdentifier {\n    if (!this.supportsIdentifier(identifier)) {\n      throw new InternalServerError(\n        `The identifier ${identifier.path} is outside the configured identifier space.`,\n        { errorCode: 'E0001', metadata: errorTermsToMetadata({ path: identifier.path }) },\n      );\n    }\n    if (this.isRootContainer(identifier)) {\n      throw new InternalServerError(`Cannot obtain the parent of ${identifier.path} because it is a root container.`);\n    }\n\n    // Due to the checks above we know this will always succeed\n    const match = parentRegex.exec(identifier.path);\n    return { path: match![1] };\n  }\n\n  public abstract isRootContainer(identifier: ResourceIdentifier): boolean;\n\n  public contains(container: ResourceIdentifier, identifier: ResourceIdentifier, transitive: boolean): boolean {\n    if (!isContainerIdentifier(container)) {\n      return false;\n    }\n\n    if (!identifier.path.startsWith(container.path)) {\n      return false;\n    }\n\n    if (transitive) {\n      return true;\n    }\n\n    const tail = identifier.path.slice(container.path.length);\n    // If there is at least one `/` followed by a char this is not a direct parent container\n    return !tailRegex.test(tail);\n  }\n}\n"]}