{"version":3,"file":"BaseReadWriteLocker.js","sourceRoot":"","sources":["../../../src/util/locking/BaseReadWriteLocker.ts"],"names":[],"mappings":";;;AAEA,iEAA8D;AAG9D;;;;;;;;;;;;;;GAcG;AACH,MAAsB,mBAAoB,SAAQ,2CAAoB;IACjD,WAAW,CAAiB;IAE/C;;;OAGG;IACH,YAAsB,cAA8B,EAAE,WAA2B;QAC/E,KAAK,CAAC,cAAc,CAAC,CAAC;QACtB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACjC,CAAC;IAEM,KAAK,CAAC,YAAY,CAAI,UAA8B,EAAE,WAAoC;QAC/F,MAAM,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;QACvC,IAAI,CAAC;YACH,OAAO,MAAM,WAAW,EAAE,CAAC;QAC7B,CAAC;gBAAS,CAAC;YACT,MAAM,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,CAAC;QACzC,CAAC;IACH,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,eAAe,CAAC,UAA8B;QAC1D,MAAM,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,KAAK,IAAkB,EAAE;YACpE,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;YACrD,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;gBAChB,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACxC,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,eAAe,CAAC,UAA8B;QAC1D,MAAM,IAAI,CAAC,qBAAqB,CAAC,UAAU,EAAE,KAAK,IAAkB,EAAE;YACpE,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;YACrD,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;gBAChB,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACxC,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,qBAAqB,CAAI,UAA8B,EAAE,WAAoC;QAEzG,MAAM,IAAI,GAAG,IAAI,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;QACrD,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC;YACH,OAAO,MAAM,WAAW,EAAE,CAAC;QAC7B,CAAC;gBAAS,CAAC;YACT,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACvC,CAAC;IACH,CAAC;CAkBF;AA3ED,kDA2EC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { PromiseOrValue } from '../PromiseUtil';\nimport { EqualReadWriteLocker } from './EqualReadWriteLocker';\nimport type { ResourceLocker } from './ResourceLocker';\n\n/**\n * A {@link ReadWriteLocker} that allows for multiple simultaneous read operations.\n * Write operations will be blocked as long as read operations are not finished.\n * New read operations are allowed while this is going on, which will cause write operations to wait longer.\n *\n * Based on https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock#Using_two_mutexes .\n * As soon as 1 read lock request is made, the main lock is locked.\n * Internally a counter keeps track of the amount of active read locks.\n * Only when this number reaches 0 will the main lock be released again.\n * The internal count lock is only locked to increase/decrease this counter and is released afterwards.\n * This allows for multiple read operations, although only 1 at the time can update the counter,\n * which means there can still be a small waiting period if there are multiple simultaneous read operations.\n *\n * Classes extending this need to implement `getCountLockIdentifier` and `modifyCount`.\n */\nexport abstract class BaseReadWriteLocker extends EqualReadWriteLocker {\n  protected readonly countLocker: ResourceLocker;\n\n  /**\n   * @param resourceLocker - Used for creating read and write locks.\n   * @param countLocker - Used for creating locks when updating the counter.\n   */\n  protected constructor(resourceLocker: ResourceLocker, countLocker: ResourceLocker) {\n    super(resourceLocker);\n    this.countLocker = countLocker;\n  }\n\n  public async withReadLock<T>(identifier: ResourceIdentifier, whileLocked: () => PromiseOrValue<T>): Promise<T> {\n    await this.acquireReadLock(identifier);\n    try {\n      return await whileLocked();\n    } finally {\n      await this.releaseReadLock(identifier);\n    }\n  }\n\n  /**\n   * Safely updates the count before starting a read operation.\n   */\n  private async acquireReadLock(identifier: ResourceIdentifier): Promise<void> {\n    await this.withInternalCountLock(identifier, async(): Promise<void> => {\n      const count = await this.modifyCount(identifier, +1);\n      if (count === 1) {\n        await this.locker.acquire(identifier);\n      }\n    });\n  }\n\n  /**\n   * Safely decreases the count after the read operation is finished.\n   */\n  private async releaseReadLock(identifier: ResourceIdentifier): Promise<void> {\n    await this.withInternalCountLock(identifier, async(): Promise<void> => {\n      const count = await this.modifyCount(identifier, -1);\n      if (count === 0) {\n        await this.locker.release(identifier);\n      }\n    });\n  }\n\n  /**\n   * Safely runs an action on the count.\n   */\n  private async withInternalCountLock<T>(identifier: ResourceIdentifier, whileLocked: () => PromiseOrValue<T>):\n  Promise<T> {\n    const read = this.getCountLockIdentifier(identifier);\n    await this.countLocker.acquire(read);\n    try {\n      return await whileLocked();\n    } finally {\n      await this.countLocker.release(read);\n    }\n  }\n\n  /**\n   * Generate the identifier that will be used to acquire the count lock for the given identifier.\n   * There will be cases where this lock needs to be acquired\n   * while an active lock on the main resource is still being maintained.\n   * This means that if the input `resourceLocker` and `countLocker` use the same locking system\n   * this generated identifier needs to be different.\n   */\n  protected abstract getCountLockIdentifier(identifier: ResourceIdentifier): ResourceIdentifier;\n\n  /**\n   * Update the counter that keeps track of having open read locks there currently are.\n   *\n   * @param identifier - Identifier on which to update the number of read locks.\n   * @param mod - `+1` or `-1`.\n   */\n  protected abstract modifyCount(identifier: ResourceIdentifier, mod: number): PromiseOrValue<number>;\n}\n"]}