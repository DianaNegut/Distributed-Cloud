{"version":3,"file":"FileSystemResourceLocker.js","sourceRoot":"","sources":["../../../src/util/locking/FileSystemResourceLocker.ts"],"names":[],"mappings":"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","sourcesContent":["import { createHash } from 'node:crypto';\nimport { ensureDir, remove } from 'fs-extra';\nimport type { LockOptions, UnlockOptions } from 'proper-lockfile';\nimport { lock, unlock } from 'proper-lockfile';\nimport type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport type { Finalizable } from '../../init/final/Finalizable';\nimport type { Initializable } from '../../init/Initializable';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { createErrorMessage } from '../errors/ErrorUtil';\nimport { InternalServerError } from '../errors/InternalServerError';\nimport type { AttemptSettings } from '../LockUtils';\nimport { retryFunction } from '../LockUtils';\nimport { joinFilePath } from '../PathUtil';\nimport type { ResourceLocker } from './ResourceLocker';\n\nconst defaultLockOptions: LockOptions = {\n  // This must be set to false! If not every lock request will try to resolve the path to the file.\n  // Since however this locker maps all locks to a common internal folder that might be non-existing on start,\n  // resolving those paths would throw an filesystem error.\n  realpath: false,\n  /** The number of retries or a [retry](https://www.npmjs.org/package/retry) options object, defaults to 0 */\n  retries: 0,\n};\n\nconst defaultUnlockOptions: UnlockOptions = {\n  // This must be set to false! If not every lock request will try to resolve the path to the file.\n  // Since however this locker maps all locks to a common internal folder that might be non-existing on start,\n  // resolving those paths would throw an filesystem error.\n  realpath: false,\n};\n\nconst attemptDefaults: Required<AttemptSettings> = { retryCount: -1, retryDelay: 50, retryJitter: 30 };\n\n/**\n * Argument interface of the FileSystemResourceLocker constructor.\n */\ninterface FileSystemResourceLockerArgs {\n  /** The root filepath of where the server is allowed to write files */\n  rootFilePath: string;\n  /**\n   * The path to the directory where locks will be stored (relative to rootFilePath)\n   * _[default is `/.internal/locks`]_\n   */\n  lockDirectory?: string;\n  /** Custom settings concerning retrying locks */\n  attemptSettings?: AttemptSettings;\n  /**\n   * Throws an error when a lock is compromised, instead of logging an error.\n   */\n  throwOnCompromise?: boolean;\n}\n\nfunction isCodedError(err: unknown): err is { code: string } & Error {\n  return typeof err === 'object' && err !== null && 'code' in err;\n}\n\n/**\n * A resource locker making use of the [proper-lockfile](https://www.npmjs.com/package/proper-lockfile) library.\n * Note that no locks are kept in memory, thus this is considered thread- and process-safe.\n * While it stores the actual locks on disk, it also tracks them in memory for when they need to be released.\n * This means only the worker thread that acquired a lock can release it again,\n * making this implementation unusable in combination with a wrapping read/write lock implementation.\n *\n * This **proper-lockfile** library has its own retry mechanism for the operations, since a lock/unlock call will\n * either resolve successfully or reject immediately with the causing error. The retry function of the library\n * however will be ignored and replaced by our own LockUtils' {@link retryFunction} function.\n */\nexport class FileSystemResourceLocker implements ResourceLocker, Initializable, Finalizable {\n  protected readonly logger = getLoggerFor(this);\n  private readonly attemptSettings: Required<AttemptSettings>;\n  private readonly lockOptions: LockOptions;\n  private readonly throwOnCompromise?: boolean;\n  /** Folder that stores the locks */\n  private readonly lockFolder: string;\n  private finalized = false;\n\n  /**\n   * Create a new FileSystemResourceLocker\n   *\n   * @param args - Configures the locker using the specified FileSystemResourceLockerArgs instance.\n   */\n  public constructor(args: FileSystemResourceLockerArgs) {\n    const { rootFilePath, lockDirectory, attemptSettings } = args;\n    // Need to create lock options for this instance due to the custom `onCompromised`\n    this.lockOptions = { ...defaultLockOptions, onCompromised: this.customOnCompromised.bind(this) };\n    this.attemptSettings = { ...attemptDefaults, ...attemptSettings };\n    this.throwOnCompromise = args.throwOnCompromise;\n    this.lockFolder = joinFilePath(rootFilePath, lockDirectory ?? '/.internal/locks');\n  }\n\n  /**\n   * Wrapper function for all (un)lock operations. Any errors coming from the `fn()` will be swallowed.\n   * Only `ENOTACQUIRED` errors wills be thrown (trying to release lock that didn't exist).\n   * This wrapper returns undefined because {@link retryFunction} expects that when a retry needs to happen.\n   *\n   * @param fn - The function reference to swallow errors from.\n   *\n   * @returns Boolean or undefined.\n   */\n  private swallowErrors(fn: () => Promise<unknown>): () => Promise<unknown> {\n    return async(): Promise<unknown> => {\n      try {\n        await fn();\n        return true;\n      } catch (err: unknown) {\n        // Only this error should be thrown\n        if (isCodedError(err) && err.code === 'ENOTACQUIRED') {\n          throw err;\n        }\n      }\n    };\n  }\n\n  public async acquire(identifier: ResourceIdentifier): Promise<void> {\n    const { path } = identifier;\n    this.logger.debug(`Acquiring lock for ${path}`);\n    try {\n      const opt = this.generateOptions(identifier, this.lockOptions);\n      await retryFunction(\n        this.swallowErrors(lock.bind(null, path, opt)),\n        this.attemptSettings,\n      );\n    } catch (err: unknown) {\n      throw new InternalServerError(\n        `Error trying to acquire lock for ${path}. ${createErrorMessage(err)}`,\n        { cause: err },\n      );\n    }\n  }\n\n  public async release(identifier: ResourceIdentifier): Promise<void> {\n    const { path } = identifier;\n    this.logger.debug(`Releasing lock for ${path}`);\n    try {\n      const opt = this.generateOptions(identifier, defaultUnlockOptions);\n      await retryFunction(\n        this.swallowErrors(unlock.bind(null, path, opt)),\n        this.attemptSettings,\n      );\n    } catch (err: unknown) {\n      throw new InternalServerError(\n        `Error trying to release lock for ${path}.  ${createErrorMessage(err)}`,\n        { cause: err },\n      );\n    }\n  }\n\n  /**\n   * Map the identifier path to a unique path inside the {@link lockFolder}.\n   *\n   * @param identifier - ResourceIdentifier to generate (Un)LockOptions for.\n   *\n   * @returns Full path.\n   */\n  private toLockfilePath(identifier: ResourceIdentifier): string {\n    const hash = createHash('md5');\n    const { path } = identifier;\n    return joinFilePath(this.lockFolder, hash.update(path).digest('hex'));\n  }\n\n  /**\n   * Generate LockOptions or UnlockOptions depending on the type of defauls given.\n   * A custom lockFilePath mapping strategy will be used.\n   *\n   * @param identifier - ResourceIdentifier to generate (Un)LockOptions for\n   * @param defaults - The default options. (lockFilePath will get overwritten)\n   *\n   * @returns LockOptions or UnlockOptions\n   */\n  private generateOptions<T>(identifier: ResourceIdentifier, defaults: T): T {\n    const lockfilePath = this.toLockfilePath(identifier);\n    return {\n      ...defaults,\n      lockfilePath,\n    };\n  }\n\n  /**\n   * Initializer method to be executed on server start. This makes sure that no pre-existing (dangling) locks\n   * remain on disk, so that request will not be blocked because a lock was acquired in the previous server instance.\n   *\n   * NOTE: this also removes locks created by the GreedyReadWriteLocker.\n   * (See issue: https://github.com/CommunitySolidServer/CommunitySolidServer/issues/1358)\n   */\n  public async initialize(): Promise<void> {\n    // Remove all existing (dangling) locks so new requests are not blocked (by removing the lock folder).\n    await remove(this.lockFolder);\n    // Put the folder back since `proper-lockfile` depends on its existence.\n    return ensureDir(this.lockFolder);\n  }\n\n  public async finalize(): Promise<void> {\n    // Register that finalize was called by setting a state variable.\n    this.finalized = true;\n    // NOTE: in contrast with initialize(), the lock folder is not cleared here, as the proper-lock library\n    // manages these files and will attempt to clear existing files when the process is shutdown gracefully.\n  }\n\n  /**\n   * This function is used to override the proper-lock onCompromised function.\n   * Once the locker was finalized, it will log the provided error instead of throwing it\n   * This allows for a clean shutdown procedure.\n   */\n  private customOnCompromised(err: Error): void {\n    if (this.finalized) {\n      this.logger.warn(`onCompromised was called with error: ${err.message}`);\n    } else if (this.throwOnCompromise) {\n      throw err;\n    } else {\n      this.logger.error(`Lock was compromised: ${err.message}`);\n    }\n  }\n}\n"]}