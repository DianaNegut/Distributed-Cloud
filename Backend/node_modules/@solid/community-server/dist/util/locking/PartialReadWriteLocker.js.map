{"version":3,"file":"PartialReadWriteLocker.js","sourceRoot":"","sources":["../../../src/util/locking/PartialReadWriteLocker.ts"],"names":[],"mappings":";;;AACA,+DAA4D;AAC5D,iEAA8D;AAG9D;;;;;;;;GAQG;AACH,MAAa,sBAAuB,SAAQ,yCAAmB;IAC5C,SAAS,CAAsB;IAEhD,YAAmB,MAAsB;QACvC,gFAAgF;QAChF,wFAAwF;QACxF,wGAAwG;QACxG,uDAAuD;QACvD,0FAA0F;QAC1F,0EAA0E;QAC1E,iEAAiE;QACjE,KAAK,CAAC,MAAM,EAAE,IAAI,2CAAoB,EAAE,CAAC,CAAC;QAC1C,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;IAC7B,CAAC;IAES,sBAAsB,CAAC,UAA8B;QAC7D,OAAO,UAAU,CAAC;IACpB,CAAC;IAES,WAAW,CAAC,UAA8B,EAAE,GAAW;QAC/D,MAAM,QAAQ,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC;QAClE,IAAI,QAAQ,KAAK,CAAC,EAAE,CAAC;YACnB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAChD,CAAC;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF;AA5BD,wDA4BC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { BaseReadWriteLocker } from './BaseReadWriteLocker';\nimport { MemoryResourceLocker } from './MemoryResourceLocker';\nimport type { ResourceLocker } from './ResourceLocker';\n\n/**\n * A {@link BaseReadWriteLocker} that stores the counter and its associated locks in memory.\n * The consequence of this is that multiple read requests are possible as long as they occur on the same worker thread.\n * A read request from a different worker thread will have to wait\n * until those from the current worker thread are finished.\n *\n * The main reason for this class is due to the file locker that we use only allowing locks to be released\n * by the same worker thread that acquired them.\n */\nexport class PartialReadWriteLocker extends BaseReadWriteLocker {\n  private readonly readCount: Map<string, number>;\n\n  public constructor(locker: ResourceLocker) {\n    // This goes against how we generally link classes together using Components.js.\n    // The reason for doing this is that `MemoryResourceLocker` implements `SingleThreaded`,\n    // meaning that when the server is started with worker threads an error will be thrown by Components.js.\n    // Instantiating it here \"hides\" it from Components.js.\n    // If at some point in the future this causes issues because we want to split up the code,\n    // this should not be blocking and an alternative solution should be used,\n    // such as removing the SingleThreaded interface from the locker.\n    super(locker, new MemoryResourceLocker());\n    this.readCount = new Map();\n  }\n\n  protected getCountLockIdentifier(identifier: ResourceIdentifier): ResourceIdentifier {\n    return identifier;\n  }\n\n  protected modifyCount(identifier: ResourceIdentifier, mod: number): number {\n    const modified = (this.readCount.get(identifier.path) ?? 0) + mod;\n    if (modified === 0) {\n      this.readCount.delete(identifier.path);\n    } else {\n      this.readCount.set(identifier.path, modified);\n    }\n    return modified;\n  }\n}\n"]}