{"version":3,"file":"WrappedExpiringReadWriteLocker.js","sourceRoot":"","sources":["../../../src/util/locking/WrappedExpiringReadWriteLocker.ts"],"names":[],"mappings":";;;AACA,mDAAqD;AACrD,uEAAoE;AAMpE;;GAEG;AACH,MAAa,8BAA8B;IACtB,MAAM,GAAG,IAAA,sBAAY,EAAC,IAAI,CAAC,CAAC;IAE5B,MAAM,CAAkB;IACxB,UAAU,CAAS;IAEtC;;;OAGG;IACH,YAAmB,MAAuB,EAAE,UAAkB;QAC5D,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,YAAY,CACvB,UAA8B,EAC9B,WAA4D;QAE5D,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,EAAE,KAAK,IAAe,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC,CAAC;IACpH,CAAC;IAEM,KAAK,CAAC,aAAa,CACxB,UAA8B,EAC9B,WAA4D;QAE5D,OAAO,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,UAAU,EAAE,KAAK,IAAe,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,WAAW,CAAC,CAAC,CAAC;IACrH,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,eAAe,CAC3B,UAA8B,EAC9B,WAA4D;QAE5D,IAAI,KAAc,CAAC;QACnB,IAAI,aAA4B,CAAC;QAEjC,uDAAuD;QACvD,MAAM,YAAY,GAAG,IAAI,OAAO,CAAQ,CAAC,OAAO,EAAE,MAAM,EAAQ,EAAE;YAChE,4EAA4E;YAC5E,aAAa,GAAG,GAAY,EAAE,CAAC,UAAU,CAAC,GAAS,EAAE;gBACnD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,sBAAsB,IAAI,CAAC,UAAU,SAAS,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;gBACnF,MAAM,CAAC,IAAI,yCAAmB,CAAC,sBAAsB,IAAI,CAAC,UAAU,SAAS,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;YACnG,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;YAEpB,KAAK,GAAG,aAAa,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;QAEH,qBAAqB;QACrB,MAAM,UAAU,GAAG,GAAS,EAAE;YAC5B,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,4BAA4B,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YACnE,YAAY,CAAC,KAAK,CAAC,CAAC;YACpB,KAAK,GAAG,aAAa,EAAE,CAAC;QAC1B,CAAC,CAAC;QAEF,4DAA4D;QAC5D,KAAK,UAAU,cAAc;YAC3B,IAAI,CAAC;gBACH,OAAO,MAAM,WAAW,CAAC,UAAU,CAAC,CAAC;YACvC,CAAC;oBAAS,CAAC;gBACT,YAAY,CAAC,KAAK,CAAC,CAAC;YACtB,CAAC;QACH,CAAC;QAED,OAAO,OAAO,CAAC,IAAI,CAAC,CAAE,YAAY,EAAE,cAAc,EAAE,CAAE,CAAC,CAAC;IAC1D,CAAC;CACF;AAtED,wEAsEC","sourcesContent":["import type { ResourceIdentifier } from '../../http/representation/ResourceIdentifier';\nimport { getLoggerFor } from '../../logging/LogUtil';\nimport { InternalServerError } from '../errors/InternalServerError';\nimport type { PromiseOrValue } from '../PromiseUtil';\nimport type { ExpiringReadWriteLocker } from './ExpiringReadWriteLocker';\nimport type { ReadWriteLocker } from './ReadWriteLocker';\nimport Timeout = NodeJS.Timeout;\n\n/**\n * Wraps around an existing {@link ReadWriteLocker} and adds expiration logic to prevent locks from getting stuck.\n */\nexport class WrappedExpiringReadWriteLocker implements ExpiringReadWriteLocker {\n  protected readonly logger = getLoggerFor(this);\n\n  protected readonly locker: ReadWriteLocker;\n  protected readonly expiration: number;\n\n  /**\n   * @param locker - Instance of ResourceLocker to use for acquiring a lock.\n   * @param expiration - Time in ms after which the lock expires.\n   */\n  public constructor(locker: ReadWriteLocker, expiration: number) {\n    this.locker = locker;\n    this.expiration = expiration;\n  }\n\n  public async withReadLock<T>(\n    identifier: ResourceIdentifier,\n    whileLocked: (maintainLock: () => void) => PromiseOrValue<T>,\n  ): Promise<T> {\n    return this.locker.withReadLock(identifier, async(): Promise<T> => this.expiringPromise(identifier, whileLocked));\n  }\n\n  public async withWriteLock<T>(\n    identifier: ResourceIdentifier,\n    whileLocked: (maintainLock: () => void) => PromiseOrValue<T>,\n  ): Promise<T> {\n    return this.locker.withWriteLock(identifier, async(): Promise<T> => this.expiringPromise(identifier, whileLocked));\n  }\n\n  /**\n   * Creates a Promise that either resolves the given input function or rejects if time runs out,\n   * whichever happens first. The input function can reset the timer by calling the `maintainLock` function\n   * it receives. The ResourceIdentifier is only used for logging.\n   */\n  private async expiringPromise<T>(\n    identifier: ResourceIdentifier,\n    whileLocked: (maintainLock: () => void) => PromiseOrValue<T>,\n  ): Promise<T> {\n    let timer: Timeout;\n    let createTimeout: () => Timeout;\n\n    // Promise that throws an error when the timer finishes\n    const timerPromise = new Promise<never>((resolve, reject): void => {\n      // Starts the timer that will cause this promise to error after a given time\n      createTimeout = (): Timeout => setTimeout((): void => {\n        this.logger.error(`Lock expired after ${this.expiration}ms on ${identifier.path}`);\n        reject(new InternalServerError(`Lock expired after ${this.expiration}ms on ${identifier.path}`));\n      }, this.expiration);\n\n      timer = createTimeout();\n    });\n\n    // Restarts the timer\n    const renewTimer = (): void => {\n      this.logger.verbose(`Renewed expiring lock on ${identifier.path}`);\n      clearTimeout(timer);\n      timer = createTimeout();\n    };\n\n    // Runs the main function and cleans up the timer afterwards\n    async function runWithTimeout(): Promise<T> {\n      try {\n        return await whileLocked(renewTimer);\n      } finally {\n        clearTimeout(timer);\n      }\n    }\n\n    return Promise.race([ timerPromise, runWithTimeout() ]);\n  }\n}\n"]}